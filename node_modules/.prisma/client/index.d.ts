
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MedicalStore
 * 
 */
export type MedicalStore = $Result.DefaultSelection<Prisma.$MedicalStorePayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Medicine
 * 
 */
export type Medicine = $Result.DefaultSelection<Prisma.$MedicinePayload>
/**
 * Model Variation
 * 
 */
export type Variation = $Result.DefaultSelection<Prisma.$VariationPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model MedicineInstance
 * 
 */
export type MedicineInstance = $Result.DefaultSelection<Prisma.$MedicineInstancePayload>
/**
 * Model SubUnit
 * 
 */
export type SubUnit = $Result.DefaultSelection<Prisma.$SubUnitPayload>
/**
 * Model MedicineLocation
 * 
 */
export type MedicineLocation = $Result.DefaultSelection<Prisma.$MedicineLocationPayload>
/**
 * Model MedicalStoreMedicine
 * 
 */
export type MedicalStoreMedicine = $Result.DefaultSelection<Prisma.$MedicalStoreMedicinePayload>
/**
 * Model MedicineExpiry
 * 
 */
export type MedicineExpiry = $Result.DefaultSelection<Prisma.$MedicineExpiryPayload>
/**
 * Model StockTransaction
 * 
 */
export type StockTransaction = $Result.DefaultSelection<Prisma.$StockTransactionPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model SoldItems
 * 
 */
export type SoldItems = $Result.DefaultSelection<Prisma.$SoldItemsPayload>
/**
 * Model ReturnedItems
 * 
 */
export type ReturnedItems = $Result.DefaultSelection<Prisma.$ReturnedItemsPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPERADMIN: 'SUPERADMIN',
  ADMIN: 'ADMIN',
  EMPLOYEE: 'EMPLOYEE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  CREDIT: 'CREDIT'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const DiscountType: {
  CUSTOMER_DEMAND: 'CUSTOMER_DEMAND',
  EMPLOYEE_BENEFIT: 'EMPLOYEE_BENEFIT',
  GOVERNMENT_SERVANT: 'GOVERNMENT_SERVANT',
  PENSIONER: 'PENSIONER'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const ReturnType: {
  CUSTOMER_RETURN: 'CUSTOMER_RETURN',
  COMPANY_RETURN: 'COMPANY_RETURN'
};

export type ReturnType = (typeof ReturnType)[keyof typeof ReturnType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type ReturnType = $Enums.ReturnType

export const ReturnType: typeof $Enums.ReturnType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalStore`: Exposes CRUD operations for the **MedicalStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalStores
    * const medicalStores = await prisma.medicalStore.findMany()
    * ```
    */
  get medicalStore(): Prisma.MedicalStoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicine`: Exposes CRUD operations for the **Medicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicines
    * const medicines = await prisma.medicine.findMany()
    * ```
    */
  get medicine(): Prisma.MedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variation`: Exposes CRUD operations for the **Variation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variations
    * const variations = await prisma.variation.findMany()
    * ```
    */
  get variation(): Prisma.VariationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineInstance`: Exposes CRUD operations for the **MedicineInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineInstances
    * const medicineInstances = await prisma.medicineInstance.findMany()
    * ```
    */
  get medicineInstance(): Prisma.MedicineInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subUnit`: Exposes CRUD operations for the **SubUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubUnits
    * const subUnits = await prisma.subUnit.findMany()
    * ```
    */
  get subUnit(): Prisma.SubUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineLocation`: Exposes CRUD operations for the **MedicineLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineLocations
    * const medicineLocations = await prisma.medicineLocation.findMany()
    * ```
    */
  get medicineLocation(): Prisma.MedicineLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalStoreMedicine`: Exposes CRUD operations for the **MedicalStoreMedicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalStoreMedicines
    * const medicalStoreMedicines = await prisma.medicalStoreMedicine.findMany()
    * ```
    */
  get medicalStoreMedicine(): Prisma.MedicalStoreMedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineExpiry`: Exposes CRUD operations for the **MedicineExpiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineExpiries
    * const medicineExpiries = await prisma.medicineExpiry.findMany()
    * ```
    */
  get medicineExpiry(): Prisma.MedicineExpiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransaction`: Exposes CRUD operations for the **StockTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransactions
    * const stockTransactions = await prisma.stockTransaction.findMany()
    * ```
    */
  get stockTransaction(): Prisma.StockTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soldItems`: Exposes CRUD operations for the **SoldItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SoldItems
    * const soldItems = await prisma.soldItems.findMany()
    * ```
    */
  get soldItems(): Prisma.SoldItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnedItems`: Exposes CRUD operations for the **ReturnedItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnedItems
    * const returnedItems = await prisma.returnedItems.findMany()
    * ```
    */
  get returnedItems(): Prisma.ReturnedItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    MedicalStore: 'MedicalStore',
    Company: 'Company',
    Supplier: 'Supplier',
    Medicine: 'Medicine',
    Variation: 'Variation',
    Batch: 'Batch',
    MedicineInstance: 'MedicineInstance',
    SubUnit: 'SubUnit',
    MedicineLocation: 'MedicineLocation',
    MedicalStoreMedicine: 'MedicalStoreMedicine',
    MedicineExpiry: 'MedicineExpiry',
    StockTransaction: 'StockTransaction',
    PurchaseOrder: 'PurchaseOrder',
    Order: 'Order',
    Customer: 'Customer',
    SoldItems: 'SoldItems',
    ReturnedItems: 'ReturnedItems',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "medicalStore" | "company" | "supplier" | "medicine" | "variation" | "batch" | "medicineInstance" | "subUnit" | "medicineLocation" | "medicalStoreMedicine" | "medicineExpiry" | "stockTransaction" | "purchaseOrder" | "order" | "customer" | "soldItems" | "returnedItems" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MedicalStore: {
        payload: Prisma.$MedicalStorePayload<ExtArgs>
        fields: Prisma.MedicalStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>
          }
          findFirst: {
            args: Prisma.MedicalStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>
          }
          findMany: {
            args: Prisma.MedicalStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>[]
          }
          create: {
            args: Prisma.MedicalStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>
          }
          createMany: {
            args: Prisma.MedicalStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalStoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>[]
          }
          delete: {
            args: Prisma.MedicalStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>
          }
          update: {
            args: Prisma.MedicalStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>
          }
          deleteMany: {
            args: Prisma.MedicalStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalStoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>[]
          }
          upsert: {
            args: Prisma.MedicalStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStorePayload>
          }
          aggregate: {
            args: Prisma.MedicalStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalStore>
          }
          groupBy: {
            args: Prisma.MedicalStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalStoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalStoreCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalStoreCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Medicine: {
        payload: Prisma.$MedicinePayload<ExtArgs>
        fields: Prisma.MedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findFirst: {
            args: Prisma.MedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findMany: {
            args: Prisma.MedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          create: {
            args: Prisma.MedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          createMany: {
            args: Prisma.MedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          delete: {
            args: Prisma.MedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          update: {
            args: Prisma.MedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          deleteMany: {
            args: Prisma.MedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          upsert: {
            args: Prisma.MedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          aggregate: {
            args: Prisma.MedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicine>
          }
          groupBy: {
            args: Prisma.MedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineCountAggregateOutputType> | number
          }
        }
      }
      Variation: {
        payload: Prisma.$VariationPayload<ExtArgs>
        fields: Prisma.VariationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          findFirst: {
            args: Prisma.VariationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          findMany: {
            args: Prisma.VariationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>[]
          }
          create: {
            args: Prisma.VariationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          createMany: {
            args: Prisma.VariationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>[]
          }
          delete: {
            args: Prisma.VariationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          update: {
            args: Prisma.VariationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          deleteMany: {
            args: Prisma.VariationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>[]
          }
          upsert: {
            args: Prisma.VariationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          aggregate: {
            args: Prisma.VariationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariation>
          }
          groupBy: {
            args: Prisma.VariationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationCountArgs<ExtArgs>
            result: $Utils.Optional<VariationCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      MedicineInstance: {
        payload: Prisma.$MedicineInstancePayload<ExtArgs>
        fields: Prisma.MedicineInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>
          }
          findFirst: {
            args: Prisma.MedicineInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>
          }
          findMany: {
            args: Prisma.MedicineInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>[]
          }
          create: {
            args: Prisma.MedicineInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>
          }
          createMany: {
            args: Prisma.MedicineInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>[]
          }
          delete: {
            args: Prisma.MedicineInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>
          }
          update: {
            args: Prisma.MedicineInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>
          }
          deleteMany: {
            args: Prisma.MedicineInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineInstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>[]
          }
          upsert: {
            args: Prisma.MedicineInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineInstancePayload>
          }
          aggregate: {
            args: Prisma.MedicineInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineInstance>
          }
          groupBy: {
            args: Prisma.MedicineInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineInstanceCountAggregateOutputType> | number
          }
        }
      }
      SubUnit: {
        payload: Prisma.$SubUnitPayload<ExtArgs>
        fields: Prisma.SubUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>
          }
          findFirst: {
            args: Prisma.SubUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>
          }
          findMany: {
            args: Prisma.SubUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>[]
          }
          create: {
            args: Prisma.SubUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>
          }
          createMany: {
            args: Prisma.SubUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>[]
          }
          delete: {
            args: Prisma.SubUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>
          }
          update: {
            args: Prisma.SubUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>
          }
          deleteMany: {
            args: Prisma.SubUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>[]
          }
          upsert: {
            args: Prisma.SubUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubUnitPayload>
          }
          aggregate: {
            args: Prisma.SubUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubUnit>
          }
          groupBy: {
            args: Prisma.SubUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubUnitCountArgs<ExtArgs>
            result: $Utils.Optional<SubUnitCountAggregateOutputType> | number
          }
        }
      }
      MedicineLocation: {
        payload: Prisma.$MedicineLocationPayload<ExtArgs>
        fields: Prisma.MedicineLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>
          }
          findFirst: {
            args: Prisma.MedicineLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>
          }
          findMany: {
            args: Prisma.MedicineLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>[]
          }
          create: {
            args: Prisma.MedicineLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>
          }
          createMany: {
            args: Prisma.MedicineLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>[]
          }
          delete: {
            args: Prisma.MedicineLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>
          }
          update: {
            args: Prisma.MedicineLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>
          }
          deleteMany: {
            args: Prisma.MedicineLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>[]
          }
          upsert: {
            args: Prisma.MedicineLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineLocationPayload>
          }
          aggregate: {
            args: Prisma.MedicineLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineLocation>
          }
          groupBy: {
            args: Prisma.MedicineLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineLocationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineLocationCountAggregateOutputType> | number
          }
        }
      }
      MedicalStoreMedicine: {
        payload: Prisma.$MedicalStoreMedicinePayload<ExtArgs>
        fields: Prisma.MedicalStoreMedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalStoreMedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalStoreMedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>
          }
          findFirst: {
            args: Prisma.MedicalStoreMedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalStoreMedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>
          }
          findMany: {
            args: Prisma.MedicalStoreMedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>[]
          }
          create: {
            args: Prisma.MedicalStoreMedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>
          }
          createMany: {
            args: Prisma.MedicalStoreMedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalStoreMedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>[]
          }
          delete: {
            args: Prisma.MedicalStoreMedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>
          }
          update: {
            args: Prisma.MedicalStoreMedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>
          }
          deleteMany: {
            args: Prisma.MedicalStoreMedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalStoreMedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalStoreMedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>[]
          }
          upsert: {
            args: Prisma.MedicalStoreMedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalStoreMedicinePayload>
          }
          aggregate: {
            args: Prisma.MedicalStoreMedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalStoreMedicine>
          }
          groupBy: {
            args: Prisma.MedicalStoreMedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalStoreMedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalStoreMedicineCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalStoreMedicineCountAggregateOutputType> | number
          }
        }
      }
      MedicineExpiry: {
        payload: Prisma.$MedicineExpiryPayload<ExtArgs>
        fields: Prisma.MedicineExpiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineExpiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineExpiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>
          }
          findFirst: {
            args: Prisma.MedicineExpiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineExpiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>
          }
          findMany: {
            args: Prisma.MedicineExpiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>[]
          }
          create: {
            args: Prisma.MedicineExpiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>
          }
          createMany: {
            args: Prisma.MedicineExpiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineExpiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>[]
          }
          delete: {
            args: Prisma.MedicineExpiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>
          }
          update: {
            args: Prisma.MedicineExpiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>
          }
          deleteMany: {
            args: Prisma.MedicineExpiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineExpiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineExpiryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>[]
          }
          upsert: {
            args: Prisma.MedicineExpiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineExpiryPayload>
          }
          aggregate: {
            args: Prisma.MedicineExpiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineExpiry>
          }
          groupBy: {
            args: Prisma.MedicineExpiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineExpiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineExpiryCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineExpiryCountAggregateOutputType> | number
          }
        }
      }
      StockTransaction: {
        payload: Prisma.$StockTransactionPayload<ExtArgs>
        fields: Prisma.StockTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          findFirst: {
            args: Prisma.StockTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          findMany: {
            args: Prisma.StockTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          create: {
            args: Prisma.StockTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          createMany: {
            args: Prisma.StockTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          delete: {
            args: Prisma.StockTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          update: {
            args: Prisma.StockTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          deleteMany: {
            args: Prisma.StockTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          upsert: {
            args: Prisma.StockTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          aggregate: {
            args: Prisma.StockTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransaction>
          }
          groupBy: {
            args: Prisma.StockTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransactionCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      SoldItems: {
        payload: Prisma.$SoldItemsPayload<ExtArgs>
        fields: Prisma.SoldItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoldItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoldItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>
          }
          findFirst: {
            args: Prisma.SoldItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoldItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>
          }
          findMany: {
            args: Prisma.SoldItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>[]
          }
          create: {
            args: Prisma.SoldItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>
          }
          createMany: {
            args: Prisma.SoldItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SoldItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>[]
          }
          delete: {
            args: Prisma.SoldItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>
          }
          update: {
            args: Prisma.SoldItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>
          }
          deleteMany: {
            args: Prisma.SoldItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SoldItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SoldItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>[]
          }
          upsert: {
            args: Prisma.SoldItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoldItemsPayload>
          }
          aggregate: {
            args: Prisma.SoldItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoldItems>
          }
          groupBy: {
            args: Prisma.SoldItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoldItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoldItemsCountArgs<ExtArgs>
            result: $Utils.Optional<SoldItemsCountAggregateOutputType> | number
          }
        }
      }
      ReturnedItems: {
        payload: Prisma.$ReturnedItemsPayload<ExtArgs>
        fields: Prisma.ReturnedItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnedItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnedItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>
          }
          findFirst: {
            args: Prisma.ReturnedItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnedItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>
          }
          findMany: {
            args: Prisma.ReturnedItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>[]
          }
          create: {
            args: Prisma.ReturnedItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>
          }
          createMany: {
            args: Prisma.ReturnedItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnedItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>[]
          }
          delete: {
            args: Prisma.ReturnedItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>
          }
          update: {
            args: Prisma.ReturnedItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>
          }
          deleteMany: {
            args: Prisma.ReturnedItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnedItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReturnedItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>[]
          }
          upsert: {
            args: Prisma.ReturnedItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnedItemsPayload>
          }
          aggregate: {
            args: Prisma.ReturnedItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnedItems>
          }
          groupBy: {
            args: Prisma.ReturnedItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnedItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnedItemsCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnedItemsCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    medicalStore?: MedicalStoreOmit
    company?: CompanyOmit
    supplier?: SupplierOmit
    medicine?: MedicineOmit
    variation?: VariationOmit
    batch?: BatchOmit
    medicineInstance?: MedicineInstanceOmit
    subUnit?: SubUnitOmit
    medicineLocation?: MedicineLocationOmit
    medicalStoreMedicine?: MedicalStoreMedicineOmit
    medicineExpiry?: MedicineExpiryOmit
    stockTransaction?: StockTransactionOmit
    purchaseOrder?: PurchaseOrderOmit
    order?: OrderOmit
    customer?: CustomerOmit
    soldItems?: SoldItemsOmit
    returnedItems?: ReturnedItemsOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    children: number
    orders: number
    auditLogs: number
    purchaseOrders: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | UserCountOutputTypeCountChildrenArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    purchaseOrders?: boolean | UserCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type MedicalStoreCountOutputType
   */

  export type MedicalStoreCountOutputType = {
    medicines: number
    locations: number
    purchaseOrders: number
    stockTransactions: number
    companies: number
    suppliers: number
  }

  export type MedicalStoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicines?: boolean | MedicalStoreCountOutputTypeCountMedicinesArgs
    locations?: boolean | MedicalStoreCountOutputTypeCountLocationsArgs
    purchaseOrders?: boolean | MedicalStoreCountOutputTypeCountPurchaseOrdersArgs
    stockTransactions?: boolean | MedicalStoreCountOutputTypeCountStockTransactionsArgs
    companies?: boolean | MedicalStoreCountOutputTypeCountCompaniesArgs
    suppliers?: boolean | MedicalStoreCountOutputTypeCountSuppliersArgs
  }

  // Custom InputTypes
  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreCountOutputType
     */
    select?: MedicalStoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeCountMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalStoreMedicineWhereInput
  }

  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineLocationWhereInput
  }

  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }

  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * MedicalStoreCountOutputType without action
   */
  export type MedicalStoreCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    suppliers: number
    medicines: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | CompanyCountOutputTypeCountSuppliersArgs
    medicines?: boolean | CompanyCountOutputTypeCountMedicinesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    medicines: number
    purchaseOrders: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicines?: boolean | SupplierCountOutputTypeCountMedicinesArgs
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type MedicineCountOutputType
   */

  export type MedicineCountOutputType = {
    variations: number
    locations: number
    medicalStoreMedicines: number
    expiryRecords: number
    soldItems: number
    returnedItems: number
  }

  export type MedicineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variations?: boolean | MedicineCountOutputTypeCountVariationsArgs
    locations?: boolean | MedicineCountOutputTypeCountLocationsArgs
    medicalStoreMedicines?: boolean | MedicineCountOutputTypeCountMedicalStoreMedicinesArgs
    expiryRecords?: boolean | MedicineCountOutputTypeCountExpiryRecordsArgs
    soldItems?: boolean | MedicineCountOutputTypeCountSoldItemsArgs
    returnedItems?: boolean | MedicineCountOutputTypeCountReturnedItemsArgs
  }

  // Custom InputTypes
  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineCountOutputType
     */
    select?: MedicineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountVariationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineLocationWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountMedicalStoreMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalStoreMedicineWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountExpiryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineExpiryWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountSoldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoldItemsWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountReturnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnedItemsWhereInput
  }


  /**
   * Count Type VariationCountOutputType
   */

  export type VariationCountOutputType = {
    batches: number
    instances: number
  }

  export type VariationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | VariationCountOutputTypeCountBatchesArgs
    instances?: boolean | VariationCountOutputTypeCountInstancesArgs
  }

  // Custom InputTypes
  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationCountOutputType
     */
    select?: VariationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineInstanceWhereInput
  }


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    instances: number
    soldItems: number
    returnedItems: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | BatchCountOutputTypeCountInstancesArgs
    soldItems?: boolean | BatchCountOutputTypeCountSoldItemsArgs
    returnedItems?: boolean | BatchCountOutputTypeCountReturnedItemsArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineInstanceWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountSoldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoldItemsWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountReturnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnedItemsWhereInput
  }


  /**
   * Count Type MedicineInstanceCountOutputType
   */

  export type MedicineInstanceCountOutputType = {
    locations: number
    subunits: number
    stockTransactions: number
  }

  export type MedicineInstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | MedicineInstanceCountOutputTypeCountLocationsArgs
    subunits?: boolean | MedicineInstanceCountOutputTypeCountSubunitsArgs
    stockTransactions?: boolean | MedicineInstanceCountOutputTypeCountStockTransactionsArgs
  }

  // Custom InputTypes
  /**
   * MedicineInstanceCountOutputType without action
   */
  export type MedicineInstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstanceCountOutputType
     */
    select?: MedicineInstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineInstanceCountOutputType without action
   */
  export type MedicineInstanceCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineLocationWhereInput
  }

  /**
   * MedicineInstanceCountOutputType without action
   */
  export type MedicineInstanceCountOutputTypeCountSubunitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubUnitWhereInput
  }

  /**
   * MedicineInstanceCountOutputType without action
   */
  export type MedicineInstanceCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }


  /**
   * Count Type SubUnitCountOutputType
   */

  export type SubUnitCountOutputType = {
    soldItems: number
    returnedItems: number
  }

  export type SubUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soldItems?: boolean | SubUnitCountOutputTypeCountSoldItemsArgs
    returnedItems?: boolean | SubUnitCountOutputTypeCountReturnedItemsArgs
  }

  // Custom InputTypes
  /**
   * SubUnitCountOutputType without action
   */
  export type SubUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnitCountOutputType
     */
    select?: SubUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubUnitCountOutputType without action
   */
  export type SubUnitCountOutputTypeCountSoldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoldItemsWhereInput
  }

  /**
   * SubUnitCountOutputType without action
   */
  export type SubUnitCountOutputTypeCountReturnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnedItemsWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    batches: number
    stockTransactions: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | PurchaseOrderCountOutputTypeCountBatchesArgs
    stockTransactions?: boolean | PurchaseOrderCountOutputTypeCountStockTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    soldItems: number
    returnedItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soldItems?: boolean | OrderCountOutputTypeCountSoldItemsArgs
    returnedItems?: boolean | OrderCountOutputTypeCountReturnedItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountSoldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoldItemsWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReturnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnedItemsWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    medicalStoreId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    medicalStoreId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    phoneNumber: string | null
    email: string | null
    employeeId: string | null
    password: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    parentId: number | null
    medicalStoreId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    phoneNumber: string | null
    email: string | null
    employeeId: string | null
    password: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    parentId: number | null
    medicalStoreId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    phoneNumber: number
    email: number
    employeeId: number
    password: number
    role: number
    isActive: number
    parentId: number
    medicalStoreId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    parentId?: true
    medicalStoreId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    parentId?: true
    medicalStoreId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    phoneNumber?: true
    email?: true
    employeeId?: true
    password?: true
    role?: true
    isActive?: true
    parentId?: true
    medicalStoreId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    phoneNumber?: true
    email?: true
    employeeId?: true
    password?: true
    role?: true
    isActive?: true
    parentId?: true
    medicalStoreId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    phoneNumber?: true
    email?: true
    employeeId?: true
    password?: true
    role?: true
    isActive?: true
    parentId?: true
    medicalStoreId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive: boolean
    parentId: number | null
    medicalStoreId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phoneNumber?: boolean
    email?: boolean
    employeeId?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    parentId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | User$parentArgs<ExtArgs>
    children?: boolean | User$childrenArgs<ExtArgs>
    medicalStore?: boolean | User$medicalStoreArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    purchaseOrders?: boolean | User$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phoneNumber?: boolean
    email?: boolean
    employeeId?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    parentId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | User$parentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phoneNumber?: boolean
    email?: boolean
    employeeId?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    parentId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | User$parentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phoneNumber?: boolean
    email?: boolean
    employeeId?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    parentId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "phoneNumber" | "email" | "employeeId" | "password" | "role" | "isActive" | "parentId" | "medicalStoreId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | User$parentArgs<ExtArgs>
    children?: boolean | User$childrenArgs<ExtArgs>
    medicalStore?: boolean | User$medicalStoreArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    purchaseOrders?: boolean | User$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | User$parentArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | User$parentArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      parent: Prisma.$UserPayload<ExtArgs> | null
      children: Prisma.$UserPayload<ExtArgs>[]
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      city: string
      phoneNumber: string
      email: string
      employeeId: string
      password: string
      role: $Enums.Role
      isActive: boolean
      parentId: number | null
      medicalStoreId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends User$parentArgs<ExtArgs> = {}>(args?: Subset<T, User$parentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends User$childrenArgs<ExtArgs> = {}>(args?: Subset<T, User$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalStore<T extends User$medicalStoreArgs<ExtArgs> = {}>(args?: Subset<T, User$medicalStoreArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends User$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly employeeId: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly parentId: FieldRef<"User", 'Int'>
    readonly medicalStoreId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.parent
   */
  export type User$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.children
   */
  export type User$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.medicalStore
   */
  export type User$medicalStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    where?: MedicalStoreWhereInput
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.purchaseOrders
   */
  export type User$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MedicalStore
   */

  export type AggregateMedicalStore = {
    _count: MedicalStoreCountAggregateOutputType | null
    _avg: MedicalStoreAvgAggregateOutputType | null
    _sum: MedicalStoreSumAggregateOutputType | null
    _min: MedicalStoreMinAggregateOutputType | null
    _max: MedicalStoreMaxAggregateOutputType | null
  }

  export type MedicalStoreAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type MedicalStoreSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type MedicalStoreMinAggregateOutputType = {
    id: number | null
    ownerId: number | null
    name: string | null
    address: string | null
    licenseNumber: string | null
    phoneNumber: string | null
    ntnNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalStoreMaxAggregateOutputType = {
    id: number | null
    ownerId: number | null
    name: string | null
    address: string | null
    licenseNumber: string | null
    phoneNumber: string | null
    ntnNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalStoreCountAggregateOutputType = {
    id: number
    ownerId: number
    name: number
    address: number
    licenseNumber: number
    phoneNumber: number
    ntnNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalStoreAvgAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type MedicalStoreSumAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type MedicalStoreMinAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    address?: true
    licenseNumber?: true
    phoneNumber?: true
    ntnNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalStoreMaxAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    address?: true
    licenseNumber?: true
    phoneNumber?: true
    ntnNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalStoreCountAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    address?: true
    licenseNumber?: true
    phoneNumber?: true
    ntnNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalStore to aggregate.
     */
    where?: MedicalStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStores to fetch.
     */
    orderBy?: MedicalStoreOrderByWithRelationInput | MedicalStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalStores
    **/
    _count?: true | MedicalStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalStoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalStoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalStoreMaxAggregateInputType
  }

  export type GetMedicalStoreAggregateType<T extends MedicalStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalStore[P]>
      : GetScalarType<T[P], AggregateMedicalStore[P]>
  }




  export type MedicalStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalStoreWhereInput
    orderBy?: MedicalStoreOrderByWithAggregationInput | MedicalStoreOrderByWithAggregationInput[]
    by: MedicalStoreScalarFieldEnum[] | MedicalStoreScalarFieldEnum
    having?: MedicalStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalStoreCountAggregateInputType | true
    _avg?: MedicalStoreAvgAggregateInputType
    _sum?: MedicalStoreSumAggregateInputType
    _min?: MedicalStoreMinAggregateInputType
    _max?: MedicalStoreMaxAggregateInputType
  }

  export type MedicalStoreGroupByOutputType = {
    id: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt: Date
    updatedAt: Date
    _count: MedicalStoreCountAggregateOutputType | null
    _avg: MedicalStoreAvgAggregateOutputType | null
    _sum: MedicalStoreSumAggregateOutputType | null
    _min: MedicalStoreMinAggregateOutputType | null
    _max: MedicalStoreMaxAggregateOutputType | null
  }

  type GetMedicalStoreGroupByPayload<T extends MedicalStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalStoreGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalStoreGroupByOutputType[P]>
        }
      >
    >


  export type MedicalStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    licenseNumber?: boolean
    phoneNumber?: boolean
    ntnNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    medicines?: boolean | MedicalStore$medicinesArgs<ExtArgs>
    locations?: boolean | MedicalStore$locationsArgs<ExtArgs>
    purchaseOrders?: boolean | MedicalStore$purchaseOrdersArgs<ExtArgs>
    stockTransactions?: boolean | MedicalStore$stockTransactionsArgs<ExtArgs>
    companies?: boolean | MedicalStore$companiesArgs<ExtArgs>
    suppliers?: boolean | MedicalStore$suppliersArgs<ExtArgs>
    _count?: boolean | MedicalStoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStore"]>

  export type MedicalStoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    licenseNumber?: boolean
    phoneNumber?: boolean
    ntnNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStore"]>

  export type MedicalStoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    licenseNumber?: boolean
    phoneNumber?: boolean
    ntnNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStore"]>

  export type MedicalStoreSelectScalar = {
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    licenseNumber?: boolean
    phoneNumber?: boolean
    ntnNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalStoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "name" | "address" | "licenseNumber" | "phoneNumber" | "ntnNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalStore"]>
  export type MedicalStoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    medicines?: boolean | MedicalStore$medicinesArgs<ExtArgs>
    locations?: boolean | MedicalStore$locationsArgs<ExtArgs>
    purchaseOrders?: boolean | MedicalStore$purchaseOrdersArgs<ExtArgs>
    stockTransactions?: boolean | MedicalStore$stockTransactionsArgs<ExtArgs>
    companies?: boolean | MedicalStore$companiesArgs<ExtArgs>
    suppliers?: boolean | MedicalStore$suppliersArgs<ExtArgs>
    _count?: boolean | MedicalStoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicalStoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MedicalStoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MedicalStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalStore"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      medicines: Prisma.$MedicalStoreMedicinePayload<ExtArgs>[]
      locations: Prisma.$MedicineLocationPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
      companies: Prisma.$CompanyPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ownerId: number
      name: string
      address: string
      licenseNumber: string
      phoneNumber: string
      ntnNumber: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalStore"]>
    composites: {}
  }

  type MedicalStoreGetPayload<S extends boolean | null | undefined | MedicalStoreDefaultArgs> = $Result.GetResult<Prisma.$MedicalStorePayload, S>

  type MedicalStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalStoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalStoreCountAggregateInputType | true
    }

  export interface MedicalStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalStore'], meta: { name: 'MedicalStore' } }
    /**
     * Find zero or one MedicalStore that matches the filter.
     * @param {MedicalStoreFindUniqueArgs} args - Arguments to find a MedicalStore
     * @example
     * // Get one MedicalStore
     * const medicalStore = await prisma.medicalStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalStoreFindUniqueArgs>(args: SelectSubset<T, MedicalStoreFindUniqueArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalStore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalStoreFindUniqueOrThrowArgs} args - Arguments to find a MedicalStore
     * @example
     * // Get one MedicalStore
     * const medicalStore = await prisma.medicalStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreFindFirstArgs} args - Arguments to find a MedicalStore
     * @example
     * // Get one MedicalStore
     * const medicalStore = await prisma.medicalStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalStoreFindFirstArgs>(args?: SelectSubset<T, MedicalStoreFindFirstArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreFindFirstOrThrowArgs} args - Arguments to find a MedicalStore
     * @example
     * // Get one MedicalStore
     * const medicalStore = await prisma.medicalStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalStores
     * const medicalStores = await prisma.medicalStore.findMany()
     * 
     * // Get first 10 MedicalStores
     * const medicalStores = await prisma.medicalStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalStoreWithIdOnly = await prisma.medicalStore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalStoreFindManyArgs>(args?: SelectSubset<T, MedicalStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalStore.
     * @param {MedicalStoreCreateArgs} args - Arguments to create a MedicalStore.
     * @example
     * // Create one MedicalStore
     * const MedicalStore = await prisma.medicalStore.create({
     *   data: {
     *     // ... data to create a MedicalStore
     *   }
     * })
     * 
     */
    create<T extends MedicalStoreCreateArgs>(args: SelectSubset<T, MedicalStoreCreateArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalStores.
     * @param {MedicalStoreCreateManyArgs} args - Arguments to create many MedicalStores.
     * @example
     * // Create many MedicalStores
     * const medicalStore = await prisma.medicalStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalStoreCreateManyArgs>(args?: SelectSubset<T, MedicalStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalStores and returns the data saved in the database.
     * @param {MedicalStoreCreateManyAndReturnArgs} args - Arguments to create many MedicalStores.
     * @example
     * // Create many MedicalStores
     * const medicalStore = await prisma.medicalStore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalStores and only return the `id`
     * const medicalStoreWithIdOnly = await prisma.medicalStore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalStoreCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalStoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalStore.
     * @param {MedicalStoreDeleteArgs} args - Arguments to delete one MedicalStore.
     * @example
     * // Delete one MedicalStore
     * const MedicalStore = await prisma.medicalStore.delete({
     *   where: {
     *     // ... filter to delete one MedicalStore
     *   }
     * })
     * 
     */
    delete<T extends MedicalStoreDeleteArgs>(args: SelectSubset<T, MedicalStoreDeleteArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalStore.
     * @param {MedicalStoreUpdateArgs} args - Arguments to update one MedicalStore.
     * @example
     * // Update one MedicalStore
     * const medicalStore = await prisma.medicalStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalStoreUpdateArgs>(args: SelectSubset<T, MedicalStoreUpdateArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalStores.
     * @param {MedicalStoreDeleteManyArgs} args - Arguments to filter MedicalStores to delete.
     * @example
     * // Delete a few MedicalStores
     * const { count } = await prisma.medicalStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalStoreDeleteManyArgs>(args?: SelectSubset<T, MedicalStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalStores
     * const medicalStore = await prisma.medicalStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalStoreUpdateManyArgs>(args: SelectSubset<T, MedicalStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalStores and returns the data updated in the database.
     * @param {MedicalStoreUpdateManyAndReturnArgs} args - Arguments to update many MedicalStores.
     * @example
     * // Update many MedicalStores
     * const medicalStore = await prisma.medicalStore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalStores and only return the `id`
     * const medicalStoreWithIdOnly = await prisma.medicalStore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalStoreUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalStoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalStore.
     * @param {MedicalStoreUpsertArgs} args - Arguments to update or create a MedicalStore.
     * @example
     * // Update or create a MedicalStore
     * const medicalStore = await prisma.medicalStore.upsert({
     *   create: {
     *     // ... data to create a MedicalStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalStore we want to update
     *   }
     * })
     */
    upsert<T extends MedicalStoreUpsertArgs>(args: SelectSubset<T, MedicalStoreUpsertArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreCountArgs} args - Arguments to filter MedicalStores to count.
     * @example
     * // Count the number of MedicalStores
     * const count = await prisma.medicalStore.count({
     *   where: {
     *     // ... the filter for the MedicalStores we want to count
     *   }
     * })
    **/
    count<T extends MedicalStoreCountArgs>(
      args?: Subset<T, MedicalStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalStoreAggregateArgs>(args: Subset<T, MedicalStoreAggregateArgs>): Prisma.PrismaPromise<GetMedicalStoreAggregateType<T>>

    /**
     * Group by MedicalStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalStoreGroupByArgs['orderBy'] }
        : { orderBy?: MedicalStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalStore model
   */
  readonly fields: MedicalStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicines<T extends MedicalStore$medicinesArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStore$medicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends MedicalStore$locationsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStore$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends MedicalStore$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStore$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransactions<T extends MedicalStore$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStore$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends MedicalStore$companiesArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStore$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends MedicalStore$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStore$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalStore model
   */
  interface MedicalStoreFieldRefs {
    readonly id: FieldRef<"MedicalStore", 'Int'>
    readonly ownerId: FieldRef<"MedicalStore", 'Int'>
    readonly name: FieldRef<"MedicalStore", 'String'>
    readonly address: FieldRef<"MedicalStore", 'String'>
    readonly licenseNumber: FieldRef<"MedicalStore", 'String'>
    readonly phoneNumber: FieldRef<"MedicalStore", 'String'>
    readonly ntnNumber: FieldRef<"MedicalStore", 'String'>
    readonly createdAt: FieldRef<"MedicalStore", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalStore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalStore findUnique
   */
  export type MedicalStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStore to fetch.
     */
    where: MedicalStoreWhereUniqueInput
  }

  /**
   * MedicalStore findUniqueOrThrow
   */
  export type MedicalStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStore to fetch.
     */
    where: MedicalStoreWhereUniqueInput
  }

  /**
   * MedicalStore findFirst
   */
  export type MedicalStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStore to fetch.
     */
    where?: MedicalStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStores to fetch.
     */
    orderBy?: MedicalStoreOrderByWithRelationInput | MedicalStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalStores.
     */
    cursor?: MedicalStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalStores.
     */
    distinct?: MedicalStoreScalarFieldEnum | MedicalStoreScalarFieldEnum[]
  }

  /**
   * MedicalStore findFirstOrThrow
   */
  export type MedicalStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStore to fetch.
     */
    where?: MedicalStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStores to fetch.
     */
    orderBy?: MedicalStoreOrderByWithRelationInput | MedicalStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalStores.
     */
    cursor?: MedicalStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalStores.
     */
    distinct?: MedicalStoreScalarFieldEnum | MedicalStoreScalarFieldEnum[]
  }

  /**
   * MedicalStore findMany
   */
  export type MedicalStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStores to fetch.
     */
    where?: MedicalStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStores to fetch.
     */
    orderBy?: MedicalStoreOrderByWithRelationInput | MedicalStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalStores.
     */
    cursor?: MedicalStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStores.
     */
    skip?: number
    distinct?: MedicalStoreScalarFieldEnum | MedicalStoreScalarFieldEnum[]
  }

  /**
   * MedicalStore create
   */
  export type MedicalStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalStore.
     */
    data: XOR<MedicalStoreCreateInput, MedicalStoreUncheckedCreateInput>
  }

  /**
   * MedicalStore createMany
   */
  export type MedicalStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalStores.
     */
    data: MedicalStoreCreateManyInput | MedicalStoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalStore createManyAndReturn
   */
  export type MedicalStoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalStores.
     */
    data: MedicalStoreCreateManyInput | MedicalStoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalStore update
   */
  export type MedicalStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalStore.
     */
    data: XOR<MedicalStoreUpdateInput, MedicalStoreUncheckedUpdateInput>
    /**
     * Choose, which MedicalStore to update.
     */
    where: MedicalStoreWhereUniqueInput
  }

  /**
   * MedicalStore updateMany
   */
  export type MedicalStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalStores.
     */
    data: XOR<MedicalStoreUpdateManyMutationInput, MedicalStoreUncheckedUpdateManyInput>
    /**
     * Filter which MedicalStores to update
     */
    where?: MedicalStoreWhereInput
    /**
     * Limit how many MedicalStores to update.
     */
    limit?: number
  }

  /**
   * MedicalStore updateManyAndReturn
   */
  export type MedicalStoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * The data used to update MedicalStores.
     */
    data: XOR<MedicalStoreUpdateManyMutationInput, MedicalStoreUncheckedUpdateManyInput>
    /**
     * Filter which MedicalStores to update
     */
    where?: MedicalStoreWhereInput
    /**
     * Limit how many MedicalStores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalStore upsert
   */
  export type MedicalStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalStore to update in case it exists.
     */
    where: MedicalStoreWhereUniqueInput
    /**
     * In case the MedicalStore found by the `where` argument doesn't exist, create a new MedicalStore with this data.
     */
    create: XOR<MedicalStoreCreateInput, MedicalStoreUncheckedCreateInput>
    /**
     * In case the MedicalStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalStoreUpdateInput, MedicalStoreUncheckedUpdateInput>
  }

  /**
   * MedicalStore delete
   */
  export type MedicalStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
    /**
     * Filter which MedicalStore to delete.
     */
    where: MedicalStoreWhereUniqueInput
  }

  /**
   * MedicalStore deleteMany
   */
  export type MedicalStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalStores to delete
     */
    where?: MedicalStoreWhereInput
    /**
     * Limit how many MedicalStores to delete.
     */
    limit?: number
  }

  /**
   * MedicalStore.medicines
   */
  export type MedicalStore$medicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    where?: MedicalStoreMedicineWhereInput
    orderBy?: MedicalStoreMedicineOrderByWithRelationInput | MedicalStoreMedicineOrderByWithRelationInput[]
    cursor?: MedicalStoreMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalStoreMedicineScalarFieldEnum | MedicalStoreMedicineScalarFieldEnum[]
  }

  /**
   * MedicalStore.locations
   */
  export type MedicalStore$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    where?: MedicineLocationWhereInput
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    cursor?: MedicineLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineLocationScalarFieldEnum | MedicineLocationScalarFieldEnum[]
  }

  /**
   * MedicalStore.purchaseOrders
   */
  export type MedicalStore$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * MedicalStore.stockTransactions
   */
  export type MedicalStore$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * MedicalStore.companies
   */
  export type MedicalStore$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * MedicalStore.suppliers
   */
  export type MedicalStore$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * MedicalStore without action
   */
  export type MedicalStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStore
     */
    select?: MedicalStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStore
     */
    omit?: MedicalStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    companyCode: string | null
    name: string | null
    address: string | null
    phone: string | null
    mobile: string | null
    distributorCode: string | null
    ntnNumber: string | null
    registrationDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    medicalStoreId: number | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    companyCode: string | null
    name: string | null
    address: string | null
    phone: string | null
    mobile: string | null
    distributorCode: string | null
    ntnNumber: string | null
    registrationDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    medicalStoreId: number | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    companyCode: number
    name: number
    address: number
    phone: number
    mobile: number
    distributorCode: number
    ntnNumber: number
    registrationDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    medicalStoreId: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
    medicalStoreId?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
    medicalStoreId?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    companyCode?: true
    name?: true
    address?: true
    phone?: true
    mobile?: true
    distributorCode?: true
    ntnNumber?: true
    registrationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    medicalStoreId?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    companyCode?: true
    name?: true
    address?: true
    phone?: true
    mobile?: true
    distributorCode?: true
    ntnNumber?: true
    registrationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    medicalStoreId?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    companyCode?: true
    name?: true
    address?: true
    phone?: true
    mobile?: true
    distributorCode?: true
    ntnNumber?: true
    registrationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    medicalStoreId?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    companyCode: string
    name: string
    address: string
    phone: string | null
    mobile: string | null
    distributorCode: string | null
    ntnNumber: string | null
    registrationDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    medicalStoreId: number
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyCode?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    mobile?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    registrationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStoreId?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    suppliers?: boolean | Company$suppliersArgs<ExtArgs>
    medicines?: boolean | Company$medicinesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyCode?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    mobile?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    registrationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStoreId?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyCode?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    mobile?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    registrationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStoreId?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    companyCode?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    mobile?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    registrationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStoreId?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyCode" | "name" | "address" | "phone" | "mobile" | "distributorCode" | "ntnNumber" | "registrationDate" | "isActive" | "createdAt" | "updatedAt" | "medicalStoreId", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    suppliers?: boolean | Company$suppliersArgs<ExtArgs>
    medicines?: boolean | Company$medicinesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs>
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      medicines: Prisma.$MedicinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyCode: string
      name: string
      address: string
      phone: string | null
      mobile: string | null
      distributorCode: string | null
      ntnNumber: string | null
      registrationDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      medicalStoreId: number
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalStore<T extends MedicalStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStoreDefaultArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends Company$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Company$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicines<T extends Company$medicinesArgs<ExtArgs> = {}>(args?: Subset<T, Company$medicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly companyCode: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly mobile: FieldRef<"Company", 'String'>
    readonly distributorCode: FieldRef<"Company", 'String'>
    readonly ntnNumber: FieldRef<"Company", 'String'>
    readonly registrationDate: FieldRef<"Company", 'DateTime'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly medicalStoreId: FieldRef<"Company", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.suppliers
   */
  export type Company$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Company.medicines
   */
  export type Company$medicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    where?: MedicineWhereInput
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    cursor?: MedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    medicalStoreId: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    medicalStoreId: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    supplierCode: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    distributorCode: string | null
    ntnNumber: string | null
    isActive: boolean | null
    companyId: number | null
    medicalStoreId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    supplierCode: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    distributorCode: string | null
    ntnNumber: string | null
    isActive: boolean | null
    companyId: number | null
    medicalStoreId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    supplierCode: number
    name: number
    email: number
    phone: number
    address: number
    distributorCode: number
    ntnNumber: number
    isActive: number
    companyId: number
    medicalStoreId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    companyId?: true
    medicalStoreId?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    companyId?: true
    medicalStoreId?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    supplierCode?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    distributorCode?: true
    ntnNumber?: true
    isActive?: true
    companyId?: true
    medicalStoreId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    supplierCode?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    distributorCode?: true
    ntnNumber?: true
    isActive?: true
    companyId?: true
    medicalStoreId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    supplierCode?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    distributorCode?: true
    ntnNumber?: true
    isActive?: true
    companyId?: true
    medicalStoreId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    supplierCode: string | null
    name: string
    email: string | null
    phone: string | null
    address: string
    distributorCode: string
    ntnNumber: string | null
    isActive: boolean
    companyId: number
    medicalStoreId: number
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierCode?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    isActive?: boolean
    companyId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    medicines?: boolean | Supplier$medicinesArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierCode?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    isActive?: boolean
    companyId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierCode?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    isActive?: boolean
    companyId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    supplierCode?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    distributorCode?: boolean
    ntnNumber?: boolean
    isActive?: boolean
    companyId?: boolean
    medicalStoreId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierCode" | "name" | "email" | "phone" | "address" | "distributorCode" | "ntnNumber" | "isActive" | "companyId" | "medicalStoreId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    medicines?: boolean | Supplier$medicinesArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      medicines: Prisma.$MedicinePayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierCode: string | null
      name: string
      email: string | null
      phone: string | null
      address: string
      distributorCode: string
      ntnNumber: string | null
      isActive: boolean
      companyId: number
      medicalStoreId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalStore<T extends MedicalStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStoreDefaultArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicines<T extends Supplier$medicinesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$medicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly supplierCode: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly distributorCode: FieldRef<"Supplier", 'String'>
    readonly ntnNumber: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly companyId: FieldRef<"Supplier", 'Int'>
    readonly medicalStoreId: FieldRef<"Supplier", 'Int'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.medicines
   */
  export type Supplier$medicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    where?: MedicineWhereInput
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    cursor?: MedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Medicine
   */

  export type AggregateMedicine = {
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  export type MedicineAvgAggregateOutputType = {
    id: number | null
    minquantity: number | null
    companyId: number | null
    supplierId: number | null
  }

  export type MedicineSumAggregateOutputType = {
    id: number | null
    minquantity: number | null
    companyId: number | null
    supplierId: number | null
  }

  export type MedicineMinAggregateOutputType = {
    id: number | null
    name: string | null
    formula: string | null
    description: string | null
    minquantity: number | null
    companyId: number | null
    supplierId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineMaxAggregateOutputType = {
    id: number | null
    name: string | null
    formula: string | null
    description: string | null
    minquantity: number | null
    companyId: number | null
    supplierId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineCountAggregateOutputType = {
    id: number
    name: number
    formula: number
    description: number
    minquantity: number
    companyId: number
    supplierId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineAvgAggregateInputType = {
    id?: true
    minquantity?: true
    companyId?: true
    supplierId?: true
  }

  export type MedicineSumAggregateInputType = {
    id?: true
    minquantity?: true
    companyId?: true
    supplierId?: true
  }

  export type MedicineMinAggregateInputType = {
    id?: true
    name?: true
    formula?: true
    description?: true
    minquantity?: true
    companyId?: true
    supplierId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineMaxAggregateInputType = {
    id?: true
    name?: true
    formula?: true
    description?: true
    minquantity?: true
    companyId?: true
    supplierId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineCountAggregateInputType = {
    id?: true
    name?: true
    formula?: true
    description?: true
    minquantity?: true
    companyId?: true
    supplierId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicine to aggregate.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicines
    **/
    _count?: true | MedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineMaxAggregateInputType
  }

  export type GetMedicineAggregateType<T extends MedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicine[P]>
      : GetScalarType<T[P], AggregateMedicine[P]>
  }




  export type MedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineWhereInput
    orderBy?: MedicineOrderByWithAggregationInput | MedicineOrderByWithAggregationInput[]
    by: MedicineScalarFieldEnum[] | MedicineScalarFieldEnum
    having?: MedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineCountAggregateInputType | true
    _avg?: MedicineAvgAggregateInputType
    _sum?: MedicineSumAggregateInputType
    _min?: MedicineMinAggregateInputType
    _max?: MedicineMaxAggregateInputType
  }

  export type MedicineGroupByOutputType = {
    id: number
    name: string
    formula: string | null
    description: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  type GetMedicineGroupByPayload<T extends MedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineGroupByOutputType[P]>
        }
      >
    >


  export type MedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    formula?: boolean
    description?: boolean
    minquantity?: boolean
    companyId?: boolean
    supplierId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    variations?: boolean | Medicine$variationsArgs<ExtArgs>
    locations?: boolean | Medicine$locationsArgs<ExtArgs>
    medicalStoreMedicines?: boolean | Medicine$medicalStoreMedicinesArgs<ExtArgs>
    expiryRecords?: boolean | Medicine$expiryRecordsArgs<ExtArgs>
    soldItems?: boolean | Medicine$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | Medicine$returnedItemsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    formula?: boolean
    description?: boolean
    minquantity?: boolean
    companyId?: boolean
    supplierId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    formula?: boolean
    description?: boolean
    minquantity?: boolean
    companyId?: boolean
    supplierId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectScalar = {
    id?: boolean
    name?: boolean
    formula?: boolean
    description?: boolean
    minquantity?: boolean
    companyId?: boolean
    supplierId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "formula" | "description" | "minquantity" | "companyId" | "supplierId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["medicine"]>
  export type MedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    variations?: boolean | Medicine$variationsArgs<ExtArgs>
    locations?: boolean | Medicine$locationsArgs<ExtArgs>
    medicalStoreMedicines?: boolean | Medicine$medicalStoreMedicinesArgs<ExtArgs>
    expiryRecords?: boolean | Medicine$expiryRecordsArgs<ExtArgs>
    soldItems?: boolean | Medicine$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | Medicine$returnedItemsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type MedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $MedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicine"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      variations: Prisma.$VariationPayload<ExtArgs>[]
      locations: Prisma.$MedicineLocationPayload<ExtArgs>[]
      medicalStoreMedicines: Prisma.$MedicalStoreMedicinePayload<ExtArgs>[]
      expiryRecords: Prisma.$MedicineExpiryPayload<ExtArgs>[]
      soldItems: Prisma.$SoldItemsPayload<ExtArgs>[]
      returnedItems: Prisma.$ReturnedItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      formula: string | null
      description: string | null
      minquantity: number
      companyId: number
      supplierId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicine"]>
    composites: {}
  }

  type MedicineGetPayload<S extends boolean | null | undefined | MedicineDefaultArgs> = $Result.GetResult<Prisma.$MedicinePayload, S>

  type MedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineCountAggregateInputType | true
    }

  export interface MedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicine'], meta: { name: 'Medicine' } }
    /**
     * Find zero or one Medicine that matches the filter.
     * @param {MedicineFindUniqueArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineFindUniqueArgs>(args: SelectSubset<T, MedicineFindUniqueArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineFindUniqueOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineFindFirstArgs>(args?: SelectSubset<T, MedicineFindFirstArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicines
     * const medicines = await prisma.medicine.findMany()
     * 
     * // Get first 10 Medicines
     * const medicines = await prisma.medicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineWithIdOnly = await prisma.medicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineFindManyArgs>(args?: SelectSubset<T, MedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medicine.
     * @param {MedicineCreateArgs} args - Arguments to create a Medicine.
     * @example
     * // Create one Medicine
     * const Medicine = await prisma.medicine.create({
     *   data: {
     *     // ... data to create a Medicine
     *   }
     * })
     * 
     */
    create<T extends MedicineCreateArgs>(args: SelectSubset<T, MedicineCreateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicines.
     * @param {MedicineCreateManyArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineCreateManyArgs>(args?: SelectSubset<T, MedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicines and returns the data saved in the database.
     * @param {MedicineCreateManyAndReturnArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medicine.
     * @param {MedicineDeleteArgs} args - Arguments to delete one Medicine.
     * @example
     * // Delete one Medicine
     * const Medicine = await prisma.medicine.delete({
     *   where: {
     *     // ... filter to delete one Medicine
     *   }
     * })
     * 
     */
    delete<T extends MedicineDeleteArgs>(args: SelectSubset<T, MedicineDeleteArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medicine.
     * @param {MedicineUpdateArgs} args - Arguments to update one Medicine.
     * @example
     * // Update one Medicine
     * const medicine = await prisma.medicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineUpdateArgs>(args: SelectSubset<T, MedicineUpdateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicines.
     * @param {MedicineDeleteManyArgs} args - Arguments to filter Medicines to delete.
     * @example
     * // Delete a few Medicines
     * const { count } = await prisma.medicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineDeleteManyArgs>(args?: SelectSubset<T, MedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineUpdateManyArgs>(args: SelectSubset<T, MedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines and returns the data updated in the database.
     * @param {MedicineUpdateManyAndReturnArgs} args - Arguments to update many Medicines.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medicine.
     * @param {MedicineUpsertArgs} args - Arguments to update or create a Medicine.
     * @example
     * // Update or create a Medicine
     * const medicine = await prisma.medicine.upsert({
     *   create: {
     *     // ... data to create a Medicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicine we want to update
     *   }
     * })
     */
    upsert<T extends MedicineUpsertArgs>(args: SelectSubset<T, MedicineUpsertArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineCountArgs} args - Arguments to filter Medicines to count.
     * @example
     * // Count the number of Medicines
     * const count = await prisma.medicine.count({
     *   where: {
     *     // ... the filter for the Medicines we want to count
     *   }
     * })
    **/
    count<T extends MedicineCountArgs>(
      args?: Subset<T, MedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineAggregateArgs>(args: Subset<T, MedicineAggregateArgs>): Prisma.PrismaPromise<GetMedicineAggregateType<T>>

    /**
     * Group by Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineGroupByArgs['orderBy'] }
        : { orderBy?: MedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicine model
   */
  readonly fields: MedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variations<T extends Medicine$variationsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$variationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Medicine$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalStoreMedicines<T extends Medicine$medicalStoreMedicinesArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$medicalStoreMedicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expiryRecords<T extends Medicine$expiryRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$expiryRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soldItems<T extends Medicine$soldItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$soldItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnedItems<T extends Medicine$returnedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$returnedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicine model
   */
  interface MedicineFieldRefs {
    readonly id: FieldRef<"Medicine", 'Int'>
    readonly name: FieldRef<"Medicine", 'String'>
    readonly formula: FieldRef<"Medicine", 'String'>
    readonly description: FieldRef<"Medicine", 'String'>
    readonly minquantity: FieldRef<"Medicine", 'Int'>
    readonly companyId: FieldRef<"Medicine", 'Int'>
    readonly supplierId: FieldRef<"Medicine", 'Int'>
    readonly isActive: FieldRef<"Medicine", 'Boolean'>
    readonly createdAt: FieldRef<"Medicine", 'DateTime'>
    readonly updatedAt: FieldRef<"Medicine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medicine findUnique
   */
  export type MedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findUniqueOrThrow
   */
  export type MedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findFirst
   */
  export type MedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findFirstOrThrow
   */
  export type MedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findMany
   */
  export type MedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicines to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine create
   */
  export type MedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicine.
     */
    data: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
  }

  /**
   * Medicine createMany
   */
  export type MedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicine createManyAndReturn
   */
  export type MedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medicine update
   */
  export type MedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicine.
     */
    data: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
    /**
     * Choose, which Medicine to update.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine updateMany
   */
  export type MedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to update.
     */
    limit?: number
  }

  /**
   * Medicine updateManyAndReturn
   */
  export type MedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medicine upsert
   */
  export type MedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicine to update in case it exists.
     */
    where: MedicineWhereUniqueInput
    /**
     * In case the Medicine found by the `where` argument doesn't exist, create a new Medicine with this data.
     */
    create: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
    /**
     * In case the Medicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
  }

  /**
   * Medicine delete
   */
  export type MedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter which Medicine to delete.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine deleteMany
   */
  export type MedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicines to delete
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to delete.
     */
    limit?: number
  }

  /**
   * Medicine.variations
   */
  export type Medicine$variationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    where?: VariationWhereInput
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    cursor?: VariationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Medicine.locations
   */
  export type Medicine$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    where?: MedicineLocationWhereInput
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    cursor?: MedicineLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineLocationScalarFieldEnum | MedicineLocationScalarFieldEnum[]
  }

  /**
   * Medicine.medicalStoreMedicines
   */
  export type Medicine$medicalStoreMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    where?: MedicalStoreMedicineWhereInput
    orderBy?: MedicalStoreMedicineOrderByWithRelationInput | MedicalStoreMedicineOrderByWithRelationInput[]
    cursor?: MedicalStoreMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalStoreMedicineScalarFieldEnum | MedicalStoreMedicineScalarFieldEnum[]
  }

  /**
   * Medicine.expiryRecords
   */
  export type Medicine$expiryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    where?: MedicineExpiryWhereInput
    orderBy?: MedicineExpiryOrderByWithRelationInput | MedicineExpiryOrderByWithRelationInput[]
    cursor?: MedicineExpiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineExpiryScalarFieldEnum | MedicineExpiryScalarFieldEnum[]
  }

  /**
   * Medicine.soldItems
   */
  export type Medicine$soldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    where?: SoldItemsWhereInput
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    cursor?: SoldItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * Medicine.returnedItems
   */
  export type Medicine$returnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    where?: ReturnedItemsWhereInput
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    cursor?: ReturnedItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * Medicine without action
   */
  export type MedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
  }


  /**
   * Model Variation
   */

  export type AggregateVariation = {
    _count: VariationCountAggregateOutputType | null
    _avg: VariationAvgAggregateOutputType | null
    _sum: VariationSumAggregateOutputType | null
    _min: VariationMinAggregateOutputType | null
    _max: VariationMaxAggregateOutputType | null
  }

  export type VariationAvgAggregateOutputType = {
    id: number | null
    medicineId: number | null
    unitsPerPack: number | null
  }

  export type VariationSumAggregateOutputType = {
    id: number | null
    medicineId: number | null
    unitsPerPack: number | null
  }

  export type VariationMinAggregateOutputType = {
    id: number | null
    medicineId: number | null
    potency: string | null
    packaging: string | null
    unitType: string | null
    unitsPerPack: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationMaxAggregateOutputType = {
    id: number | null
    medicineId: number | null
    potency: string | null
    packaging: string | null
    unitType: string | null
    unitsPerPack: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationCountAggregateOutputType = {
    id: number
    medicineId: number
    potency: number
    packaging: number
    unitType: number
    unitsPerPack: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariationAvgAggregateInputType = {
    id?: true
    medicineId?: true
    unitsPerPack?: true
  }

  export type VariationSumAggregateInputType = {
    id?: true
    medicineId?: true
    unitsPerPack?: true
  }

  export type VariationMinAggregateInputType = {
    id?: true
    medicineId?: true
    potency?: true
    packaging?: true
    unitType?: true
    unitsPerPack?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationMaxAggregateInputType = {
    id?: true
    medicineId?: true
    potency?: true
    packaging?: true
    unitType?: true
    unitsPerPack?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationCountAggregateInputType = {
    id?: true
    medicineId?: true
    potency?: true
    packaging?: true
    unitType?: true
    unitsPerPack?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variation to aggregate.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variations
    **/
    _count?: true | VariationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationMaxAggregateInputType
  }

  export type GetVariationAggregateType<T extends VariationAggregateArgs> = {
        [P in keyof T & keyof AggregateVariation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariation[P]>
      : GetScalarType<T[P], AggregateVariation[P]>
  }




  export type VariationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationWhereInput
    orderBy?: VariationOrderByWithAggregationInput | VariationOrderByWithAggregationInput[]
    by: VariationScalarFieldEnum[] | VariationScalarFieldEnum
    having?: VariationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationCountAggregateInputType | true
    _avg?: VariationAvgAggregateInputType
    _sum?: VariationSumAggregateInputType
    _min?: VariationMinAggregateInputType
    _max?: VariationMaxAggregateInputType
  }

  export type VariationGroupByOutputType = {
    id: number
    medicineId: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt: Date
    updatedAt: Date
    _count: VariationCountAggregateOutputType | null
    _avg: VariationAvgAggregateOutputType | null
    _sum: VariationSumAggregateOutputType | null
    _min: VariationMinAggregateOutputType | null
    _max: VariationMaxAggregateOutputType | null
  }

  type GetVariationGroupByPayload<T extends VariationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationGroupByOutputType[P]>
            : GetScalarType<T[P], VariationGroupByOutputType[P]>
        }
      >
    >


  export type VariationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    potency?: boolean
    packaging?: boolean
    unitType?: boolean
    unitsPerPack?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    batches?: boolean | Variation$batchesArgs<ExtArgs>
    instances?: boolean | Variation$instancesArgs<ExtArgs>
    _count?: boolean | VariationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variation"]>

  export type VariationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    potency?: boolean
    packaging?: boolean
    unitType?: boolean
    unitsPerPack?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variation"]>

  export type VariationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    potency?: boolean
    packaging?: boolean
    unitType?: boolean
    unitsPerPack?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variation"]>

  export type VariationSelectScalar = {
    id?: boolean
    medicineId?: boolean
    potency?: boolean
    packaging?: boolean
    unitType?: boolean
    unitsPerPack?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicineId" | "potency" | "packaging" | "unitType" | "unitsPerPack" | "createdAt" | "updatedAt", ExtArgs["result"]["variation"]>
  export type VariationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    batches?: boolean | Variation$batchesArgs<ExtArgs>
    instances?: boolean | Variation$instancesArgs<ExtArgs>
    _count?: boolean | VariationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type VariationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $VariationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variation"
    objects: {
      medicine: Prisma.$MedicinePayload<ExtArgs>
      batches: Prisma.$BatchPayload<ExtArgs>[]
      instances: Prisma.$MedicineInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicineId: number
      potency: string
      packaging: string
      unitType: string
      unitsPerPack: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variation"]>
    composites: {}
  }

  type VariationGetPayload<S extends boolean | null | undefined | VariationDefaultArgs> = $Result.GetResult<Prisma.$VariationPayload, S>

  type VariationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationCountAggregateInputType | true
    }

  export interface VariationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variation'], meta: { name: 'Variation' } }
    /**
     * Find zero or one Variation that matches the filter.
     * @param {VariationFindUniqueArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationFindUniqueArgs>(args: SelectSubset<T, VariationFindUniqueArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Variation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationFindUniqueOrThrowArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationFindFirstArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationFindFirstArgs>(args?: SelectSubset<T, VariationFindFirstArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationFindFirstOrThrowArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variations
     * const variations = await prisma.variation.findMany()
     * 
     * // Get first 10 Variations
     * const variations = await prisma.variation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationWithIdOnly = await prisma.variation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationFindManyArgs>(args?: SelectSubset<T, VariationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Variation.
     * @param {VariationCreateArgs} args - Arguments to create a Variation.
     * @example
     * // Create one Variation
     * const Variation = await prisma.variation.create({
     *   data: {
     *     // ... data to create a Variation
     *   }
     * })
     * 
     */
    create<T extends VariationCreateArgs>(args: SelectSubset<T, VariationCreateArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Variations.
     * @param {VariationCreateManyArgs} args - Arguments to create many Variations.
     * @example
     * // Create many Variations
     * const variation = await prisma.variation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationCreateManyArgs>(args?: SelectSubset<T, VariationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variations and returns the data saved in the database.
     * @param {VariationCreateManyAndReturnArgs} args - Arguments to create many Variations.
     * @example
     * // Create many Variations
     * const variation = await prisma.variation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variations and only return the `id`
     * const variationWithIdOnly = await prisma.variation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Variation.
     * @param {VariationDeleteArgs} args - Arguments to delete one Variation.
     * @example
     * // Delete one Variation
     * const Variation = await prisma.variation.delete({
     *   where: {
     *     // ... filter to delete one Variation
     *   }
     * })
     * 
     */
    delete<T extends VariationDeleteArgs>(args: SelectSubset<T, VariationDeleteArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Variation.
     * @param {VariationUpdateArgs} args - Arguments to update one Variation.
     * @example
     * // Update one Variation
     * const variation = await prisma.variation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationUpdateArgs>(args: SelectSubset<T, VariationUpdateArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Variations.
     * @param {VariationDeleteManyArgs} args - Arguments to filter Variations to delete.
     * @example
     * // Delete a few Variations
     * const { count } = await prisma.variation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationDeleteManyArgs>(args?: SelectSubset<T, VariationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variations
     * const variation = await prisma.variation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationUpdateManyArgs>(args: SelectSubset<T, VariationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variations and returns the data updated in the database.
     * @param {VariationUpdateManyAndReturnArgs} args - Arguments to update many Variations.
     * @example
     * // Update many Variations
     * const variation = await prisma.variation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variations and only return the `id`
     * const variationWithIdOnly = await prisma.variation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Variation.
     * @param {VariationUpsertArgs} args - Arguments to update or create a Variation.
     * @example
     * // Update or create a Variation
     * const variation = await prisma.variation.upsert({
     *   create: {
     *     // ... data to create a Variation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variation we want to update
     *   }
     * })
     */
    upsert<T extends VariationUpsertArgs>(args: SelectSubset<T, VariationUpsertArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Variations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationCountArgs} args - Arguments to filter Variations to count.
     * @example
     * // Count the number of Variations
     * const count = await prisma.variation.count({
     *   where: {
     *     // ... the filter for the Variations we want to count
     *   }
     * })
    **/
    count<T extends VariationCountArgs>(
      args?: Subset<T, VariationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationAggregateArgs>(args: Subset<T, VariationAggregateArgs>): Prisma.PrismaPromise<GetVariationAggregateType<T>>

    /**
     * Group by Variation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationGroupByArgs['orderBy'] }
        : { orderBy?: VariationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variation model
   */
  readonly fields: VariationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batches<T extends Variation$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Variation$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instances<T extends Variation$instancesArgs<ExtArgs> = {}>(args?: Subset<T, Variation$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variation model
   */
  interface VariationFieldRefs {
    readonly id: FieldRef<"Variation", 'Int'>
    readonly medicineId: FieldRef<"Variation", 'Int'>
    readonly potency: FieldRef<"Variation", 'String'>
    readonly packaging: FieldRef<"Variation", 'String'>
    readonly unitType: FieldRef<"Variation", 'String'>
    readonly unitsPerPack: FieldRef<"Variation", 'Int'>
    readonly createdAt: FieldRef<"Variation", 'DateTime'>
    readonly updatedAt: FieldRef<"Variation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Variation findUnique
   */
  export type VariationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation findUniqueOrThrow
   */
  export type VariationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation findFirst
   */
  export type VariationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variations.
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variations.
     */
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Variation findFirstOrThrow
   */
  export type VariationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variations.
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variations.
     */
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Variation findMany
   */
  export type VariationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variations to fetch.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variations.
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Variation create
   */
  export type VariationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * The data needed to create a Variation.
     */
    data: XOR<VariationCreateInput, VariationUncheckedCreateInput>
  }

  /**
   * Variation createMany
   */
  export type VariationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variations.
     */
    data: VariationCreateManyInput | VariationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variation createManyAndReturn
   */
  export type VariationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * The data used to create many Variations.
     */
    data: VariationCreateManyInput | VariationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variation update
   */
  export type VariationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * The data needed to update a Variation.
     */
    data: XOR<VariationUpdateInput, VariationUncheckedUpdateInput>
    /**
     * Choose, which Variation to update.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation updateMany
   */
  export type VariationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variations.
     */
    data: XOR<VariationUpdateManyMutationInput, VariationUncheckedUpdateManyInput>
    /**
     * Filter which Variations to update
     */
    where?: VariationWhereInput
    /**
     * Limit how many Variations to update.
     */
    limit?: number
  }

  /**
   * Variation updateManyAndReturn
   */
  export type VariationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * The data used to update Variations.
     */
    data: XOR<VariationUpdateManyMutationInput, VariationUncheckedUpdateManyInput>
    /**
     * Filter which Variations to update
     */
    where?: VariationWhereInput
    /**
     * Limit how many Variations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variation upsert
   */
  export type VariationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * The filter to search for the Variation to update in case it exists.
     */
    where: VariationWhereUniqueInput
    /**
     * In case the Variation found by the `where` argument doesn't exist, create a new Variation with this data.
     */
    create: XOR<VariationCreateInput, VariationUncheckedCreateInput>
    /**
     * In case the Variation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationUpdateInput, VariationUncheckedUpdateInput>
  }

  /**
   * Variation delete
   */
  export type VariationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter which Variation to delete.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation deleteMany
   */
  export type VariationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variations to delete
     */
    where?: VariationWhereInput
    /**
     * Limit how many Variations to delete.
     */
    limit?: number
  }

  /**
   * Variation.batches
   */
  export type Variation$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Variation.instances
   */
  export type Variation$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    where?: MedicineInstanceWhereInput
    orderBy?: MedicineInstanceOrderByWithRelationInput | MedicineInstanceOrderByWithRelationInput[]
    cursor?: MedicineInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineInstanceScalarFieldEnum | MedicineInstanceScalarFieldEnum[]
  }

  /**
   * Variation without action
   */
  export type VariationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    price: number | null
    variationId: number | null
    purchaseOrderId: number | null
  }

  export type BatchSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    price: number | null
    variationId: number | null
    purchaseOrderId: number | null
  }

  export type BatchMinAggregateOutputType = {
    id: number | null
    batchNo: string | null
    mfgDate: Date | null
    expiryDate: Date | null
    quantity: number | null
    price: number | null
    variationId: number | null
    purchaseOrderId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchMaxAggregateOutputType = {
    id: number | null
    batchNo: string | null
    mfgDate: Date | null
    expiryDate: Date | null
    quantity: number | null
    price: number | null
    variationId: number | null
    purchaseOrderId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    batchNo: number
    mfgDate: number
    expiryDate: number
    quantity: number
    price: number
    variationId: number
    purchaseOrderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    variationId?: true
    purchaseOrderId?: true
  }

  export type BatchSumAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    variationId?: true
    purchaseOrderId?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    batchNo?: true
    mfgDate?: true
    expiryDate?: true
    quantity?: true
    price?: true
    variationId?: true
    purchaseOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    batchNo?: true
    mfgDate?: true
    expiryDate?: true
    quantity?: true
    price?: true
    variationId?: true
    purchaseOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    batchNo?: true
    mfgDate?: true
    expiryDate?: true
    quantity?: true
    price?: true
    variationId?: true
    purchaseOrderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: number
    batchNo: string
    mfgDate: Date
    expiryDate: Date
    quantity: number
    price: number
    variationId: number
    purchaseOrderId: number | null
    createdAt: Date
    updatedAt: Date
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNo?: boolean
    mfgDate?: boolean
    expiryDate?: boolean
    quantity?: boolean
    price?: boolean
    variationId?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Batch$purchaseOrderArgs<ExtArgs>
    instances?: boolean | Batch$instancesArgs<ExtArgs>
    soldItems?: boolean | Batch$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | Batch$returnedItemsArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNo?: boolean
    mfgDate?: boolean
    expiryDate?: boolean
    quantity?: boolean
    price?: boolean
    variationId?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Batch$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNo?: boolean
    mfgDate?: boolean
    expiryDate?: boolean
    quantity?: boolean
    price?: boolean
    variationId?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Batch$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    batchNo?: boolean
    mfgDate?: boolean
    expiryDate?: boolean
    quantity?: boolean
    price?: boolean
    variationId?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchNo" | "mfgDate" | "expiryDate" | "quantity" | "price" | "variationId" | "purchaseOrderId" | "createdAt" | "updatedAt", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Batch$purchaseOrderArgs<ExtArgs>
    instances?: boolean | Batch$instancesArgs<ExtArgs>
    soldItems?: boolean | Batch$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | Batch$returnedItemsArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Batch$purchaseOrderArgs<ExtArgs>
  }
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Batch$purchaseOrderArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      variation: Prisma.$VariationPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      instances: Prisma.$MedicineInstancePayload<ExtArgs>[]
      soldItems: Prisma.$SoldItemsPayload<ExtArgs>[]
      returnedItems: Prisma.$ReturnedItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      batchNo: string
      mfgDate: Date
      expiryDate: Date
      quantity: number
      price: number
      variationId: number
      purchaseOrderId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends VariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariationDefaultArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends Batch$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Batch$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    instances<T extends Batch$instancesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soldItems<T extends Batch$soldItemsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$soldItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnedItems<T extends Batch$returnedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$returnedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'Int'>
    readonly batchNo: FieldRef<"Batch", 'String'>
    readonly mfgDate: FieldRef<"Batch", 'DateTime'>
    readonly expiryDate: FieldRef<"Batch", 'DateTime'>
    readonly quantity: FieldRef<"Batch", 'Int'>
    readonly price: FieldRef<"Batch", 'Float'>
    readonly variationId: FieldRef<"Batch", 'Int'>
    readonly purchaseOrderId: FieldRef<"Batch", 'Int'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly updatedAt: FieldRef<"Batch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.purchaseOrder
   */
  export type Batch$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * Batch.instances
   */
  export type Batch$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    where?: MedicineInstanceWhereInput
    orderBy?: MedicineInstanceOrderByWithRelationInput | MedicineInstanceOrderByWithRelationInput[]
    cursor?: MedicineInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineInstanceScalarFieldEnum | MedicineInstanceScalarFieldEnum[]
  }

  /**
   * Batch.soldItems
   */
  export type Batch$soldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    where?: SoldItemsWhereInput
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    cursor?: SoldItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * Batch.returnedItems
   */
  export type Batch$returnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    where?: ReturnedItemsWhereInput
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    cursor?: ReturnedItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model MedicineInstance
   */

  export type AggregateMedicineInstance = {
    _count: MedicineInstanceCountAggregateOutputType | null
    _avg: MedicineInstanceAvgAggregateOutputType | null
    _sum: MedicineInstanceSumAggregateOutputType | null
    _min: MedicineInstanceMinAggregateOutputType | null
    _max: MedicineInstanceMaxAggregateOutputType | null
  }

  export type MedicineInstanceAvgAggregateOutputType = {
    id: number | null
    variationId: number | null
    batchId: number | null
    quantity: number | null
    purchasePrice: number | null
    sellingPrice: number | null
  }

  export type MedicineInstanceSumAggregateOutputType = {
    id: number | null
    variationId: number | null
    batchId: number | null
    quantity: number | null
    purchasePrice: number | null
    sellingPrice: number | null
  }

  export type MedicineInstanceMinAggregateOutputType = {
    id: number | null
    variationId: number | null
    batchId: number | null
    expiryDate: Date | null
    quantity: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineInstanceMaxAggregateOutputType = {
    id: number | null
    variationId: number | null
    batchId: number | null
    expiryDate: Date | null
    quantity: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineInstanceCountAggregateOutputType = {
    id: number
    variationId: number
    batchId: number
    expiryDate: number
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineInstanceAvgAggregateInputType = {
    id?: true
    variationId?: true
    batchId?: true
    quantity?: true
    purchasePrice?: true
    sellingPrice?: true
  }

  export type MedicineInstanceSumAggregateInputType = {
    id?: true
    variationId?: true
    batchId?: true
    quantity?: true
    purchasePrice?: true
    sellingPrice?: true
  }

  export type MedicineInstanceMinAggregateInputType = {
    id?: true
    variationId?: true
    batchId?: true
    expiryDate?: true
    quantity?: true
    purchasePrice?: true
    sellingPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineInstanceMaxAggregateInputType = {
    id?: true
    variationId?: true
    batchId?: true
    expiryDate?: true
    quantity?: true
    purchasePrice?: true
    sellingPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineInstanceCountAggregateInputType = {
    id?: true
    variationId?: true
    batchId?: true
    expiryDate?: true
    quantity?: true
    purchasePrice?: true
    sellingPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineInstance to aggregate.
     */
    where?: MedicineInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineInstances to fetch.
     */
    orderBy?: MedicineInstanceOrderByWithRelationInput | MedicineInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineInstances
    **/
    _count?: true | MedicineInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineInstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineInstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineInstanceMaxAggregateInputType
  }

  export type GetMedicineInstanceAggregateType<T extends MedicineInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineInstance[P]>
      : GetScalarType<T[P], AggregateMedicineInstance[P]>
  }




  export type MedicineInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineInstanceWhereInput
    orderBy?: MedicineInstanceOrderByWithAggregationInput | MedicineInstanceOrderByWithAggregationInput[]
    by: MedicineInstanceScalarFieldEnum[] | MedicineInstanceScalarFieldEnum
    having?: MedicineInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineInstanceCountAggregateInputType | true
    _avg?: MedicineInstanceAvgAggregateInputType
    _sum?: MedicineInstanceSumAggregateInputType
    _min?: MedicineInstanceMinAggregateInputType
    _max?: MedicineInstanceMaxAggregateInputType
  }

  export type MedicineInstanceGroupByOutputType = {
    id: number
    variationId: number
    batchId: number
    expiryDate: Date
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt: Date
    updatedAt: Date
    _count: MedicineInstanceCountAggregateOutputType | null
    _avg: MedicineInstanceAvgAggregateOutputType | null
    _sum: MedicineInstanceSumAggregateOutputType | null
    _min: MedicineInstanceMinAggregateOutputType | null
    _max: MedicineInstanceMaxAggregateOutputType | null
  }

  type GetMedicineInstanceGroupByPayload<T extends MedicineInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineInstanceGroupByOutputType[P]>
        }
      >
    >


  export type MedicineInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variationId?: boolean
    batchId?: boolean
    expiryDate?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    locations?: boolean | MedicineInstance$locationsArgs<ExtArgs>
    subunits?: boolean | MedicineInstance$subunitsArgs<ExtArgs>
    stockTransactions?: boolean | MedicineInstance$stockTransactionsArgs<ExtArgs>
    _count?: boolean | MedicineInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineInstance"]>

  export type MedicineInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variationId?: boolean
    batchId?: boolean
    expiryDate?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineInstance"]>

  export type MedicineInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variationId?: boolean
    batchId?: boolean
    expiryDate?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineInstance"]>

  export type MedicineInstanceSelectScalar = {
    id?: boolean
    variationId?: boolean
    batchId?: boolean
    expiryDate?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variationId" | "batchId" | "expiryDate" | "quantity" | "purchasePrice" | "sellingPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineInstance"]>
  export type MedicineInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    locations?: boolean | MedicineInstance$locationsArgs<ExtArgs>
    subunits?: boolean | MedicineInstance$subunitsArgs<ExtArgs>
    stockTransactions?: boolean | MedicineInstance$stockTransactionsArgs<ExtArgs>
    _count?: boolean | MedicineInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type MedicineInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }

  export type $MedicineInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineInstance"
    objects: {
      variation: Prisma.$VariationPayload<ExtArgs>
      batch: Prisma.$BatchPayload<ExtArgs>
      locations: Prisma.$MedicineLocationPayload<ExtArgs>[]
      subunits: Prisma.$SubUnitPayload<ExtArgs>[]
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      variationId: number
      batchId: number
      expiryDate: Date
      quantity: number
      purchasePrice: number
      sellingPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineInstance"]>
    composites: {}
  }

  type MedicineInstanceGetPayload<S extends boolean | null | undefined | MedicineInstanceDefaultArgs> = $Result.GetResult<Prisma.$MedicineInstancePayload, S>

  type MedicineInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineInstanceCountAggregateInputType | true
    }

  export interface MedicineInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineInstance'], meta: { name: 'MedicineInstance' } }
    /**
     * Find zero or one MedicineInstance that matches the filter.
     * @param {MedicineInstanceFindUniqueArgs} args - Arguments to find a MedicineInstance
     * @example
     * // Get one MedicineInstance
     * const medicineInstance = await prisma.medicineInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineInstanceFindUniqueArgs>(args: SelectSubset<T, MedicineInstanceFindUniqueArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineInstanceFindUniqueOrThrowArgs} args - Arguments to find a MedicineInstance
     * @example
     * // Get one MedicineInstance
     * const medicineInstance = await prisma.medicineInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceFindFirstArgs} args - Arguments to find a MedicineInstance
     * @example
     * // Get one MedicineInstance
     * const medicineInstance = await prisma.medicineInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineInstanceFindFirstArgs>(args?: SelectSubset<T, MedicineInstanceFindFirstArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceFindFirstOrThrowArgs} args - Arguments to find a MedicineInstance
     * @example
     * // Get one MedicineInstance
     * const medicineInstance = await prisma.medicineInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineInstances
     * const medicineInstances = await prisma.medicineInstance.findMany()
     * 
     * // Get first 10 MedicineInstances
     * const medicineInstances = await prisma.medicineInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineInstanceWithIdOnly = await prisma.medicineInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineInstanceFindManyArgs>(args?: SelectSubset<T, MedicineInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineInstance.
     * @param {MedicineInstanceCreateArgs} args - Arguments to create a MedicineInstance.
     * @example
     * // Create one MedicineInstance
     * const MedicineInstance = await prisma.medicineInstance.create({
     *   data: {
     *     // ... data to create a MedicineInstance
     *   }
     * })
     * 
     */
    create<T extends MedicineInstanceCreateArgs>(args: SelectSubset<T, MedicineInstanceCreateArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineInstances.
     * @param {MedicineInstanceCreateManyArgs} args - Arguments to create many MedicineInstances.
     * @example
     * // Create many MedicineInstances
     * const medicineInstance = await prisma.medicineInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineInstanceCreateManyArgs>(args?: SelectSubset<T, MedicineInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineInstances and returns the data saved in the database.
     * @param {MedicineInstanceCreateManyAndReturnArgs} args - Arguments to create many MedicineInstances.
     * @example
     * // Create many MedicineInstances
     * const medicineInstance = await prisma.medicineInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineInstances and only return the `id`
     * const medicineInstanceWithIdOnly = await prisma.medicineInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicineInstance.
     * @param {MedicineInstanceDeleteArgs} args - Arguments to delete one MedicineInstance.
     * @example
     * // Delete one MedicineInstance
     * const MedicineInstance = await prisma.medicineInstance.delete({
     *   where: {
     *     // ... filter to delete one MedicineInstance
     *   }
     * })
     * 
     */
    delete<T extends MedicineInstanceDeleteArgs>(args: SelectSubset<T, MedicineInstanceDeleteArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineInstance.
     * @param {MedicineInstanceUpdateArgs} args - Arguments to update one MedicineInstance.
     * @example
     * // Update one MedicineInstance
     * const medicineInstance = await prisma.medicineInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineInstanceUpdateArgs>(args: SelectSubset<T, MedicineInstanceUpdateArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineInstances.
     * @param {MedicineInstanceDeleteManyArgs} args - Arguments to filter MedicineInstances to delete.
     * @example
     * // Delete a few MedicineInstances
     * const { count } = await prisma.medicineInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineInstanceDeleteManyArgs>(args?: SelectSubset<T, MedicineInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineInstances
     * const medicineInstance = await prisma.medicineInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineInstanceUpdateManyArgs>(args: SelectSubset<T, MedicineInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineInstances and returns the data updated in the database.
     * @param {MedicineInstanceUpdateManyAndReturnArgs} args - Arguments to update many MedicineInstances.
     * @example
     * // Update many MedicineInstances
     * const medicineInstance = await prisma.medicineInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineInstances and only return the `id`
     * const medicineInstanceWithIdOnly = await prisma.medicineInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicineInstance.
     * @param {MedicineInstanceUpsertArgs} args - Arguments to update or create a MedicineInstance.
     * @example
     * // Update or create a MedicineInstance
     * const medicineInstance = await prisma.medicineInstance.upsert({
     *   create: {
     *     // ... data to create a MedicineInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineInstance we want to update
     *   }
     * })
     */
    upsert<T extends MedicineInstanceUpsertArgs>(args: SelectSubset<T, MedicineInstanceUpsertArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceCountArgs} args - Arguments to filter MedicineInstances to count.
     * @example
     * // Count the number of MedicineInstances
     * const count = await prisma.medicineInstance.count({
     *   where: {
     *     // ... the filter for the MedicineInstances we want to count
     *   }
     * })
    **/
    count<T extends MedicineInstanceCountArgs>(
      args?: Subset<T, MedicineInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineInstanceAggregateArgs>(args: Subset<T, MedicineInstanceAggregateArgs>): Prisma.PrismaPromise<GetMedicineInstanceAggregateType<T>>

    /**
     * Group by MedicineInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineInstanceGroupByArgs['orderBy'] }
        : { orderBy?: MedicineInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineInstance model
   */
  readonly fields: MedicineInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends VariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariationDefaultArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    locations<T extends MedicineInstance$locationsArgs<ExtArgs> = {}>(args?: Subset<T, MedicineInstance$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subunits<T extends MedicineInstance$subunitsArgs<ExtArgs> = {}>(args?: Subset<T, MedicineInstance$subunitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransactions<T extends MedicineInstance$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, MedicineInstance$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineInstance model
   */
  interface MedicineInstanceFieldRefs {
    readonly id: FieldRef<"MedicineInstance", 'Int'>
    readonly variationId: FieldRef<"MedicineInstance", 'Int'>
    readonly batchId: FieldRef<"MedicineInstance", 'Int'>
    readonly expiryDate: FieldRef<"MedicineInstance", 'DateTime'>
    readonly quantity: FieldRef<"MedicineInstance", 'Int'>
    readonly purchasePrice: FieldRef<"MedicineInstance", 'Float'>
    readonly sellingPrice: FieldRef<"MedicineInstance", 'Float'>
    readonly createdAt: FieldRef<"MedicineInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineInstance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineInstance findUnique
   */
  export type MedicineInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * Filter, which MedicineInstance to fetch.
     */
    where: MedicineInstanceWhereUniqueInput
  }

  /**
   * MedicineInstance findUniqueOrThrow
   */
  export type MedicineInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * Filter, which MedicineInstance to fetch.
     */
    where: MedicineInstanceWhereUniqueInput
  }

  /**
   * MedicineInstance findFirst
   */
  export type MedicineInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * Filter, which MedicineInstance to fetch.
     */
    where?: MedicineInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineInstances to fetch.
     */
    orderBy?: MedicineInstanceOrderByWithRelationInput | MedicineInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineInstances.
     */
    cursor?: MedicineInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineInstances.
     */
    distinct?: MedicineInstanceScalarFieldEnum | MedicineInstanceScalarFieldEnum[]
  }

  /**
   * MedicineInstance findFirstOrThrow
   */
  export type MedicineInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * Filter, which MedicineInstance to fetch.
     */
    where?: MedicineInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineInstances to fetch.
     */
    orderBy?: MedicineInstanceOrderByWithRelationInput | MedicineInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineInstances.
     */
    cursor?: MedicineInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineInstances.
     */
    distinct?: MedicineInstanceScalarFieldEnum | MedicineInstanceScalarFieldEnum[]
  }

  /**
   * MedicineInstance findMany
   */
  export type MedicineInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * Filter, which MedicineInstances to fetch.
     */
    where?: MedicineInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineInstances to fetch.
     */
    orderBy?: MedicineInstanceOrderByWithRelationInput | MedicineInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineInstances.
     */
    cursor?: MedicineInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineInstances.
     */
    skip?: number
    distinct?: MedicineInstanceScalarFieldEnum | MedicineInstanceScalarFieldEnum[]
  }

  /**
   * MedicineInstance create
   */
  export type MedicineInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineInstance.
     */
    data: XOR<MedicineInstanceCreateInput, MedicineInstanceUncheckedCreateInput>
  }

  /**
   * MedicineInstance createMany
   */
  export type MedicineInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineInstances.
     */
    data: MedicineInstanceCreateManyInput | MedicineInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineInstance createManyAndReturn
   */
  export type MedicineInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineInstances.
     */
    data: MedicineInstanceCreateManyInput | MedicineInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineInstance update
   */
  export type MedicineInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineInstance.
     */
    data: XOR<MedicineInstanceUpdateInput, MedicineInstanceUncheckedUpdateInput>
    /**
     * Choose, which MedicineInstance to update.
     */
    where: MedicineInstanceWhereUniqueInput
  }

  /**
   * MedicineInstance updateMany
   */
  export type MedicineInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineInstances.
     */
    data: XOR<MedicineInstanceUpdateManyMutationInput, MedicineInstanceUncheckedUpdateManyInput>
    /**
     * Filter which MedicineInstances to update
     */
    where?: MedicineInstanceWhereInput
    /**
     * Limit how many MedicineInstances to update.
     */
    limit?: number
  }

  /**
   * MedicineInstance updateManyAndReturn
   */
  export type MedicineInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * The data used to update MedicineInstances.
     */
    data: XOR<MedicineInstanceUpdateManyMutationInput, MedicineInstanceUncheckedUpdateManyInput>
    /**
     * Filter which MedicineInstances to update
     */
    where?: MedicineInstanceWhereInput
    /**
     * Limit how many MedicineInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineInstance upsert
   */
  export type MedicineInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineInstance to update in case it exists.
     */
    where: MedicineInstanceWhereUniqueInput
    /**
     * In case the MedicineInstance found by the `where` argument doesn't exist, create a new MedicineInstance with this data.
     */
    create: XOR<MedicineInstanceCreateInput, MedicineInstanceUncheckedCreateInput>
    /**
     * In case the MedicineInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineInstanceUpdateInput, MedicineInstanceUncheckedUpdateInput>
  }

  /**
   * MedicineInstance delete
   */
  export type MedicineInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
    /**
     * Filter which MedicineInstance to delete.
     */
    where: MedicineInstanceWhereUniqueInput
  }

  /**
   * MedicineInstance deleteMany
   */
  export type MedicineInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineInstances to delete
     */
    where?: MedicineInstanceWhereInput
    /**
     * Limit how many MedicineInstances to delete.
     */
    limit?: number
  }

  /**
   * MedicineInstance.locations
   */
  export type MedicineInstance$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    where?: MedicineLocationWhereInput
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    cursor?: MedicineLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineLocationScalarFieldEnum | MedicineLocationScalarFieldEnum[]
  }

  /**
   * MedicineInstance.subunits
   */
  export type MedicineInstance$subunitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    where?: SubUnitWhereInput
    orderBy?: SubUnitOrderByWithRelationInput | SubUnitOrderByWithRelationInput[]
    cursor?: SubUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubUnitScalarFieldEnum | SubUnitScalarFieldEnum[]
  }

  /**
   * MedicineInstance.stockTransactions
   */
  export type MedicineInstance$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * MedicineInstance without action
   */
  export type MedicineInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineInstance
     */
    select?: MedicineInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineInstance
     */
    omit?: MedicineInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInstanceInclude<ExtArgs> | null
  }


  /**
   * Model SubUnit
   */

  export type AggregateSubUnit = {
    _count: SubUnitCountAggregateOutputType | null
    _avg: SubUnitAvgAggregateOutputType | null
    _sum: SubUnitSumAggregateOutputType | null
    _min: SubUnitMinAggregateOutputType | null
    _max: SubUnitMaxAggregateOutputType | null
  }

  export type SubUnitAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
    subUnitCount: number | null
    subUnitPrice: number | null
  }

  export type SubUnitSumAggregateOutputType = {
    id: number | null
    unitId: number | null
    subUnitCount: number | null
    subUnitPrice: number | null
  }

  export type SubUnitMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    description: string | null
    unitType: string | null
    subUnitCount: number | null
    subUnitPrice: number | null
    isSold: boolean | null
    isReturnedByCustomer: boolean | null
    isReturnedToSupplier: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubUnitMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    description: string | null
    unitType: string | null
    subUnitCount: number | null
    subUnitPrice: number | null
    isSold: boolean | null
    isReturnedByCustomer: boolean | null
    isReturnedToSupplier: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubUnitCountAggregateOutputType = {
    id: number
    unitId: number
    name: number
    description: number
    unitType: number
    subUnitCount: number
    subUnitPrice: number
    isSold: number
    isReturnedByCustomer: number
    isReturnedToSupplier: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubUnitAvgAggregateInputType = {
    id?: true
    unitId?: true
    subUnitCount?: true
    subUnitPrice?: true
  }

  export type SubUnitSumAggregateInputType = {
    id?: true
    unitId?: true
    subUnitCount?: true
    subUnitPrice?: true
  }

  export type SubUnitMinAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    description?: true
    unitType?: true
    subUnitCount?: true
    subUnitPrice?: true
    isSold?: true
    isReturnedByCustomer?: true
    isReturnedToSupplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubUnitMaxAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    description?: true
    unitType?: true
    subUnitCount?: true
    subUnitPrice?: true
    isSold?: true
    isReturnedByCustomer?: true
    isReturnedToSupplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubUnitCountAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    description?: true
    unitType?: true
    subUnitCount?: true
    subUnitPrice?: true
    isSold?: true
    isReturnedByCustomer?: true
    isReturnedToSupplier?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubUnit to aggregate.
     */
    where?: SubUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubUnits to fetch.
     */
    orderBy?: SubUnitOrderByWithRelationInput | SubUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubUnits
    **/
    _count?: true | SubUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubUnitMaxAggregateInputType
  }

  export type GetSubUnitAggregateType<T extends SubUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateSubUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubUnit[P]>
      : GetScalarType<T[P], AggregateSubUnit[P]>
  }




  export type SubUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubUnitWhereInput
    orderBy?: SubUnitOrderByWithAggregationInput | SubUnitOrderByWithAggregationInput[]
    by: SubUnitScalarFieldEnum[] | SubUnitScalarFieldEnum
    having?: SubUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubUnitCountAggregateInputType | true
    _avg?: SubUnitAvgAggregateInputType
    _sum?: SubUnitSumAggregateInputType
    _min?: SubUnitMinAggregateInputType
    _max?: SubUnitMaxAggregateInputType
  }

  export type SubUnitGroupByOutputType = {
    id: number
    unitId: number
    name: string
    description: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold: boolean
    isReturnedByCustomer: boolean
    isReturnedToSupplier: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubUnitCountAggregateOutputType | null
    _avg: SubUnitAvgAggregateOutputType | null
    _sum: SubUnitSumAggregateOutputType | null
    _min: SubUnitMinAggregateOutputType | null
    _max: SubUnitMaxAggregateOutputType | null
  }

  type GetSubUnitGroupByPayload<T extends SubUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubUnitGroupByOutputType[P]>
            : GetScalarType<T[P], SubUnitGroupByOutputType[P]>
        }
      >
    >


  export type SubUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    description?: boolean
    unitType?: boolean
    subUnitCount?: boolean
    subUnitPrice?: boolean
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    soldItems?: boolean | SubUnit$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | SubUnit$returnedItemsArgs<ExtArgs>
    _count?: boolean | SubUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subUnit"]>

  export type SubUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    description?: boolean
    unitType?: boolean
    subUnitCount?: boolean
    subUnitPrice?: boolean
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subUnit"]>

  export type SubUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    description?: boolean
    unitType?: boolean
    subUnitCount?: boolean
    subUnitPrice?: boolean
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subUnit"]>

  export type SubUnitSelectScalar = {
    id?: boolean
    unitId?: boolean
    name?: boolean
    description?: boolean
    unitType?: boolean
    subUnitCount?: boolean
    subUnitPrice?: boolean
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "name" | "description" | "unitType" | "subUnitCount" | "subUnitPrice" | "isSold" | "isReturnedByCustomer" | "isReturnedToSupplier" | "createdAt" | "updatedAt", ExtArgs["result"]["subUnit"]>
  export type SubUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    soldItems?: boolean | SubUnit$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | SubUnit$returnedItemsArgs<ExtArgs>
    _count?: boolean | SubUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }
  export type SubUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }

  export type $SubUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubUnit"
    objects: {
      instance: Prisma.$MedicineInstancePayload<ExtArgs>
      soldItems: Prisma.$SoldItemsPayload<ExtArgs>[]
      returnedItems: Prisma.$ReturnedItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      name: string
      description: string | null
      unitType: string
      subUnitCount: number
      subUnitPrice: number
      isSold: boolean
      isReturnedByCustomer: boolean
      isReturnedToSupplier: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subUnit"]>
    composites: {}
  }

  type SubUnitGetPayload<S extends boolean | null | undefined | SubUnitDefaultArgs> = $Result.GetResult<Prisma.$SubUnitPayload, S>

  type SubUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubUnitCountAggregateInputType | true
    }

  export interface SubUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubUnit'], meta: { name: 'SubUnit' } }
    /**
     * Find zero or one SubUnit that matches the filter.
     * @param {SubUnitFindUniqueArgs} args - Arguments to find a SubUnit
     * @example
     * // Get one SubUnit
     * const subUnit = await prisma.subUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubUnitFindUniqueArgs>(args: SelectSubset<T, SubUnitFindUniqueArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubUnitFindUniqueOrThrowArgs} args - Arguments to find a SubUnit
     * @example
     * // Get one SubUnit
     * const subUnit = await prisma.subUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, SubUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitFindFirstArgs} args - Arguments to find a SubUnit
     * @example
     * // Get one SubUnit
     * const subUnit = await prisma.subUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubUnitFindFirstArgs>(args?: SelectSubset<T, SubUnitFindFirstArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitFindFirstOrThrowArgs} args - Arguments to find a SubUnit
     * @example
     * // Get one SubUnit
     * const subUnit = await prisma.subUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, SubUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubUnits
     * const subUnits = await prisma.subUnit.findMany()
     * 
     * // Get first 10 SubUnits
     * const subUnits = await prisma.subUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subUnitWithIdOnly = await prisma.subUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubUnitFindManyArgs>(args?: SelectSubset<T, SubUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubUnit.
     * @param {SubUnitCreateArgs} args - Arguments to create a SubUnit.
     * @example
     * // Create one SubUnit
     * const SubUnit = await prisma.subUnit.create({
     *   data: {
     *     // ... data to create a SubUnit
     *   }
     * })
     * 
     */
    create<T extends SubUnitCreateArgs>(args: SelectSubset<T, SubUnitCreateArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubUnits.
     * @param {SubUnitCreateManyArgs} args - Arguments to create many SubUnits.
     * @example
     * // Create many SubUnits
     * const subUnit = await prisma.subUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubUnitCreateManyArgs>(args?: SelectSubset<T, SubUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubUnits and returns the data saved in the database.
     * @param {SubUnitCreateManyAndReturnArgs} args - Arguments to create many SubUnits.
     * @example
     * // Create many SubUnits
     * const subUnit = await prisma.subUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubUnits and only return the `id`
     * const subUnitWithIdOnly = await prisma.subUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, SubUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubUnit.
     * @param {SubUnitDeleteArgs} args - Arguments to delete one SubUnit.
     * @example
     * // Delete one SubUnit
     * const SubUnit = await prisma.subUnit.delete({
     *   where: {
     *     // ... filter to delete one SubUnit
     *   }
     * })
     * 
     */
    delete<T extends SubUnitDeleteArgs>(args: SelectSubset<T, SubUnitDeleteArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubUnit.
     * @param {SubUnitUpdateArgs} args - Arguments to update one SubUnit.
     * @example
     * // Update one SubUnit
     * const subUnit = await prisma.subUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubUnitUpdateArgs>(args: SelectSubset<T, SubUnitUpdateArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubUnits.
     * @param {SubUnitDeleteManyArgs} args - Arguments to filter SubUnits to delete.
     * @example
     * // Delete a few SubUnits
     * const { count } = await prisma.subUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubUnitDeleteManyArgs>(args?: SelectSubset<T, SubUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubUnits
     * const subUnit = await prisma.subUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubUnitUpdateManyArgs>(args: SelectSubset<T, SubUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubUnits and returns the data updated in the database.
     * @param {SubUnitUpdateManyAndReturnArgs} args - Arguments to update many SubUnits.
     * @example
     * // Update many SubUnits
     * const subUnit = await prisma.subUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubUnits and only return the `id`
     * const subUnitWithIdOnly = await prisma.subUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, SubUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubUnit.
     * @param {SubUnitUpsertArgs} args - Arguments to update or create a SubUnit.
     * @example
     * // Update or create a SubUnit
     * const subUnit = await prisma.subUnit.upsert({
     *   create: {
     *     // ... data to create a SubUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubUnit we want to update
     *   }
     * })
     */
    upsert<T extends SubUnitUpsertArgs>(args: SelectSubset<T, SubUnitUpsertArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitCountArgs} args - Arguments to filter SubUnits to count.
     * @example
     * // Count the number of SubUnits
     * const count = await prisma.subUnit.count({
     *   where: {
     *     // ... the filter for the SubUnits we want to count
     *   }
     * })
    **/
    count<T extends SubUnitCountArgs>(
      args?: Subset<T, SubUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubUnitAggregateArgs>(args: Subset<T, SubUnitAggregateArgs>): Prisma.PrismaPromise<GetSubUnitAggregateType<T>>

    /**
     * Group by SubUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubUnitGroupByArgs['orderBy'] }
        : { orderBy?: SubUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubUnit model
   */
  readonly fields: SubUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends MedicineInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineInstanceDefaultArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    soldItems<T extends SubUnit$soldItemsArgs<ExtArgs> = {}>(args?: Subset<T, SubUnit$soldItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnedItems<T extends SubUnit$returnedItemsArgs<ExtArgs> = {}>(args?: Subset<T, SubUnit$returnedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubUnit model
   */
  interface SubUnitFieldRefs {
    readonly id: FieldRef<"SubUnit", 'Int'>
    readonly unitId: FieldRef<"SubUnit", 'Int'>
    readonly name: FieldRef<"SubUnit", 'String'>
    readonly description: FieldRef<"SubUnit", 'String'>
    readonly unitType: FieldRef<"SubUnit", 'String'>
    readonly subUnitCount: FieldRef<"SubUnit", 'Int'>
    readonly subUnitPrice: FieldRef<"SubUnit", 'Float'>
    readonly isSold: FieldRef<"SubUnit", 'Boolean'>
    readonly isReturnedByCustomer: FieldRef<"SubUnit", 'Boolean'>
    readonly isReturnedToSupplier: FieldRef<"SubUnit", 'Boolean'>
    readonly createdAt: FieldRef<"SubUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"SubUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubUnit findUnique
   */
  export type SubUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * Filter, which SubUnit to fetch.
     */
    where: SubUnitWhereUniqueInput
  }

  /**
   * SubUnit findUniqueOrThrow
   */
  export type SubUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * Filter, which SubUnit to fetch.
     */
    where: SubUnitWhereUniqueInput
  }

  /**
   * SubUnit findFirst
   */
  export type SubUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * Filter, which SubUnit to fetch.
     */
    where?: SubUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubUnits to fetch.
     */
    orderBy?: SubUnitOrderByWithRelationInput | SubUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubUnits.
     */
    cursor?: SubUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubUnits.
     */
    distinct?: SubUnitScalarFieldEnum | SubUnitScalarFieldEnum[]
  }

  /**
   * SubUnit findFirstOrThrow
   */
  export type SubUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * Filter, which SubUnit to fetch.
     */
    where?: SubUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubUnits to fetch.
     */
    orderBy?: SubUnitOrderByWithRelationInput | SubUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubUnits.
     */
    cursor?: SubUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubUnits.
     */
    distinct?: SubUnitScalarFieldEnum | SubUnitScalarFieldEnum[]
  }

  /**
   * SubUnit findMany
   */
  export type SubUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * Filter, which SubUnits to fetch.
     */
    where?: SubUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubUnits to fetch.
     */
    orderBy?: SubUnitOrderByWithRelationInput | SubUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubUnits.
     */
    cursor?: SubUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubUnits.
     */
    skip?: number
    distinct?: SubUnitScalarFieldEnum | SubUnitScalarFieldEnum[]
  }

  /**
   * SubUnit create
   */
  export type SubUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a SubUnit.
     */
    data: XOR<SubUnitCreateInput, SubUnitUncheckedCreateInput>
  }

  /**
   * SubUnit createMany
   */
  export type SubUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubUnits.
     */
    data: SubUnitCreateManyInput | SubUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubUnit createManyAndReturn
   */
  export type SubUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * The data used to create many SubUnits.
     */
    data: SubUnitCreateManyInput | SubUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubUnit update
   */
  export type SubUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a SubUnit.
     */
    data: XOR<SubUnitUpdateInput, SubUnitUncheckedUpdateInput>
    /**
     * Choose, which SubUnit to update.
     */
    where: SubUnitWhereUniqueInput
  }

  /**
   * SubUnit updateMany
   */
  export type SubUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubUnits.
     */
    data: XOR<SubUnitUpdateManyMutationInput, SubUnitUncheckedUpdateManyInput>
    /**
     * Filter which SubUnits to update
     */
    where?: SubUnitWhereInput
    /**
     * Limit how many SubUnits to update.
     */
    limit?: number
  }

  /**
   * SubUnit updateManyAndReturn
   */
  export type SubUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * The data used to update SubUnits.
     */
    data: XOR<SubUnitUpdateManyMutationInput, SubUnitUncheckedUpdateManyInput>
    /**
     * Filter which SubUnits to update
     */
    where?: SubUnitWhereInput
    /**
     * Limit how many SubUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubUnit upsert
   */
  export type SubUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the SubUnit to update in case it exists.
     */
    where: SubUnitWhereUniqueInput
    /**
     * In case the SubUnit found by the `where` argument doesn't exist, create a new SubUnit with this data.
     */
    create: XOR<SubUnitCreateInput, SubUnitUncheckedCreateInput>
    /**
     * In case the SubUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubUnitUpdateInput, SubUnitUncheckedUpdateInput>
  }

  /**
   * SubUnit delete
   */
  export type SubUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    /**
     * Filter which SubUnit to delete.
     */
    where: SubUnitWhereUniqueInput
  }

  /**
   * SubUnit deleteMany
   */
  export type SubUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubUnits to delete
     */
    where?: SubUnitWhereInput
    /**
     * Limit how many SubUnits to delete.
     */
    limit?: number
  }

  /**
   * SubUnit.soldItems
   */
  export type SubUnit$soldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    where?: SoldItemsWhereInput
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    cursor?: SoldItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * SubUnit.returnedItems
   */
  export type SubUnit$returnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    where?: ReturnedItemsWhereInput
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    cursor?: ReturnedItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * SubUnit without action
   */
  export type SubUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
  }


  /**
   * Model MedicineLocation
   */

  export type AggregateMedicineLocation = {
    _count: MedicineLocationCountAggregateOutputType | null
    _avg: MedicineLocationAvgAggregateOutputType | null
    _sum: MedicineLocationSumAggregateOutputType | null
    _min: MedicineLocationMinAggregateOutputType | null
    _max: MedicineLocationMaxAggregateOutputType | null
  }

  export type MedicineLocationAvgAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    medicineInstanceId: number | null
    quantity: number | null
  }

  export type MedicineLocationSumAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    medicineInstanceId: number | null
    quantity: number | null
  }

  export type MedicineLocationMinAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    medicineInstanceId: number | null
    location: string | null
    rank: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineLocationMaxAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    medicineInstanceId: number | null
    location: string | null
    rank: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineLocationCountAggregateOutputType = {
    id: number
    medicalStoreId: number
    medicineId: number
    medicineInstanceId: number
    location: number
    rank: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineLocationAvgAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    medicineInstanceId?: true
    quantity?: true
  }

  export type MedicineLocationSumAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    medicineInstanceId?: true
    quantity?: true
  }

  export type MedicineLocationMinAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    medicineInstanceId?: true
    location?: true
    rank?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineLocationMaxAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    medicineInstanceId?: true
    location?: true
    rank?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineLocationCountAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    medicineInstanceId?: true
    location?: true
    rank?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineLocation to aggregate.
     */
    where?: MedicineLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineLocations to fetch.
     */
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineLocations
    **/
    _count?: true | MedicineLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineLocationMaxAggregateInputType
  }

  export type GetMedicineLocationAggregateType<T extends MedicineLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineLocation[P]>
      : GetScalarType<T[P], AggregateMedicineLocation[P]>
  }




  export type MedicineLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineLocationWhereInput
    orderBy?: MedicineLocationOrderByWithAggregationInput | MedicineLocationOrderByWithAggregationInput[]
    by: MedicineLocationScalarFieldEnum[] | MedicineLocationScalarFieldEnum
    having?: MedicineLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineLocationCountAggregateInputType | true
    _avg?: MedicineLocationAvgAggregateInputType
    _sum?: MedicineLocationSumAggregateInputType
    _min?: MedicineLocationMinAggregateInputType
    _max?: MedicineLocationMaxAggregateInputType
  }

  export type MedicineLocationGroupByOutputType = {
    id: number
    medicalStoreId: number
    medicineId: number
    medicineInstanceId: number
    location: string
    rank: string | null
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: MedicineLocationCountAggregateOutputType | null
    _avg: MedicineLocationAvgAggregateOutputType | null
    _sum: MedicineLocationSumAggregateOutputType | null
    _min: MedicineLocationMinAggregateOutputType | null
    _max: MedicineLocationMaxAggregateOutputType | null
  }

  type GetMedicineLocationGroupByPayload<T extends MedicineLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineLocationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineLocationGroupByOutputType[P]>
        }
      >
    >


  export type MedicineLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    medicineInstanceId?: boolean
    location?: boolean
    rank?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineLocation"]>

  export type MedicineLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    medicineInstanceId?: boolean
    location?: boolean
    rank?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineLocation"]>

  export type MedicineLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    medicineInstanceId?: boolean
    location?: boolean
    rank?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineLocation"]>

  export type MedicineLocationSelectScalar = {
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    medicineInstanceId?: boolean
    location?: boolean
    rank?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalStoreId" | "medicineId" | "medicineInstanceId" | "location" | "rank" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineLocation"]>
  export type MedicineLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }
  export type MedicineLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }
  export type MedicineLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    instance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
  }

  export type $MedicineLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineLocation"
    objects: {
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs>
      medicine: Prisma.$MedicinePayload<ExtArgs>
      instance: Prisma.$MedicineInstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicalStoreId: number
      medicineId: number
      medicineInstanceId: number
      location: string
      rank: string | null
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineLocation"]>
    composites: {}
  }

  type MedicineLocationGetPayload<S extends boolean | null | undefined | MedicineLocationDefaultArgs> = $Result.GetResult<Prisma.$MedicineLocationPayload, S>

  type MedicineLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineLocationCountAggregateInputType | true
    }

  export interface MedicineLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineLocation'], meta: { name: 'MedicineLocation' } }
    /**
     * Find zero or one MedicineLocation that matches the filter.
     * @param {MedicineLocationFindUniqueArgs} args - Arguments to find a MedicineLocation
     * @example
     * // Get one MedicineLocation
     * const medicineLocation = await prisma.medicineLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineLocationFindUniqueArgs>(args: SelectSubset<T, MedicineLocationFindUniqueArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineLocationFindUniqueOrThrowArgs} args - Arguments to find a MedicineLocation
     * @example
     * // Get one MedicineLocation
     * const medicineLocation = await prisma.medicineLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationFindFirstArgs} args - Arguments to find a MedicineLocation
     * @example
     * // Get one MedicineLocation
     * const medicineLocation = await prisma.medicineLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineLocationFindFirstArgs>(args?: SelectSubset<T, MedicineLocationFindFirstArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationFindFirstOrThrowArgs} args - Arguments to find a MedicineLocation
     * @example
     * // Get one MedicineLocation
     * const medicineLocation = await prisma.medicineLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineLocations
     * const medicineLocations = await prisma.medicineLocation.findMany()
     * 
     * // Get first 10 MedicineLocations
     * const medicineLocations = await prisma.medicineLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineLocationWithIdOnly = await prisma.medicineLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineLocationFindManyArgs>(args?: SelectSubset<T, MedicineLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineLocation.
     * @param {MedicineLocationCreateArgs} args - Arguments to create a MedicineLocation.
     * @example
     * // Create one MedicineLocation
     * const MedicineLocation = await prisma.medicineLocation.create({
     *   data: {
     *     // ... data to create a MedicineLocation
     *   }
     * })
     * 
     */
    create<T extends MedicineLocationCreateArgs>(args: SelectSubset<T, MedicineLocationCreateArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineLocations.
     * @param {MedicineLocationCreateManyArgs} args - Arguments to create many MedicineLocations.
     * @example
     * // Create many MedicineLocations
     * const medicineLocation = await prisma.medicineLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineLocationCreateManyArgs>(args?: SelectSubset<T, MedicineLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineLocations and returns the data saved in the database.
     * @param {MedicineLocationCreateManyAndReturnArgs} args - Arguments to create many MedicineLocations.
     * @example
     * // Create many MedicineLocations
     * const medicineLocation = await prisma.medicineLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineLocations and only return the `id`
     * const medicineLocationWithIdOnly = await prisma.medicineLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicineLocation.
     * @param {MedicineLocationDeleteArgs} args - Arguments to delete one MedicineLocation.
     * @example
     * // Delete one MedicineLocation
     * const MedicineLocation = await prisma.medicineLocation.delete({
     *   where: {
     *     // ... filter to delete one MedicineLocation
     *   }
     * })
     * 
     */
    delete<T extends MedicineLocationDeleteArgs>(args: SelectSubset<T, MedicineLocationDeleteArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineLocation.
     * @param {MedicineLocationUpdateArgs} args - Arguments to update one MedicineLocation.
     * @example
     * // Update one MedicineLocation
     * const medicineLocation = await prisma.medicineLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineLocationUpdateArgs>(args: SelectSubset<T, MedicineLocationUpdateArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineLocations.
     * @param {MedicineLocationDeleteManyArgs} args - Arguments to filter MedicineLocations to delete.
     * @example
     * // Delete a few MedicineLocations
     * const { count } = await prisma.medicineLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineLocationDeleteManyArgs>(args?: SelectSubset<T, MedicineLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineLocations
     * const medicineLocation = await prisma.medicineLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineLocationUpdateManyArgs>(args: SelectSubset<T, MedicineLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineLocations and returns the data updated in the database.
     * @param {MedicineLocationUpdateManyAndReturnArgs} args - Arguments to update many MedicineLocations.
     * @example
     * // Update many MedicineLocations
     * const medicineLocation = await prisma.medicineLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineLocations and only return the `id`
     * const medicineLocationWithIdOnly = await prisma.medicineLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicineLocation.
     * @param {MedicineLocationUpsertArgs} args - Arguments to update or create a MedicineLocation.
     * @example
     * // Update or create a MedicineLocation
     * const medicineLocation = await prisma.medicineLocation.upsert({
     *   create: {
     *     // ... data to create a MedicineLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineLocation we want to update
     *   }
     * })
     */
    upsert<T extends MedicineLocationUpsertArgs>(args: SelectSubset<T, MedicineLocationUpsertArgs<ExtArgs>>): Prisma__MedicineLocationClient<$Result.GetResult<Prisma.$MedicineLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationCountArgs} args - Arguments to filter MedicineLocations to count.
     * @example
     * // Count the number of MedicineLocations
     * const count = await prisma.medicineLocation.count({
     *   where: {
     *     // ... the filter for the MedicineLocations we want to count
     *   }
     * })
    **/
    count<T extends MedicineLocationCountArgs>(
      args?: Subset<T, MedicineLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineLocationAggregateArgs>(args: Subset<T, MedicineLocationAggregateArgs>): Prisma.PrismaPromise<GetMedicineLocationAggregateType<T>>

    /**
     * Group by MedicineLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineLocationGroupByArgs['orderBy'] }
        : { orderBy?: MedicineLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineLocation model
   */
  readonly fields: MedicineLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalStore<T extends MedicalStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStoreDefaultArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instance<T extends MedicineInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineInstanceDefaultArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineLocation model
   */
  interface MedicineLocationFieldRefs {
    readonly id: FieldRef<"MedicineLocation", 'Int'>
    readonly medicalStoreId: FieldRef<"MedicineLocation", 'Int'>
    readonly medicineId: FieldRef<"MedicineLocation", 'Int'>
    readonly medicineInstanceId: FieldRef<"MedicineLocation", 'Int'>
    readonly location: FieldRef<"MedicineLocation", 'String'>
    readonly rank: FieldRef<"MedicineLocation", 'String'>
    readonly quantity: FieldRef<"MedicineLocation", 'Int'>
    readonly createdAt: FieldRef<"MedicineLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineLocation findUnique
   */
  export type MedicineLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * Filter, which MedicineLocation to fetch.
     */
    where: MedicineLocationWhereUniqueInput
  }

  /**
   * MedicineLocation findUniqueOrThrow
   */
  export type MedicineLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * Filter, which MedicineLocation to fetch.
     */
    where: MedicineLocationWhereUniqueInput
  }

  /**
   * MedicineLocation findFirst
   */
  export type MedicineLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * Filter, which MedicineLocation to fetch.
     */
    where?: MedicineLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineLocations to fetch.
     */
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineLocations.
     */
    cursor?: MedicineLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineLocations.
     */
    distinct?: MedicineLocationScalarFieldEnum | MedicineLocationScalarFieldEnum[]
  }

  /**
   * MedicineLocation findFirstOrThrow
   */
  export type MedicineLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * Filter, which MedicineLocation to fetch.
     */
    where?: MedicineLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineLocations to fetch.
     */
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineLocations.
     */
    cursor?: MedicineLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineLocations.
     */
    distinct?: MedicineLocationScalarFieldEnum | MedicineLocationScalarFieldEnum[]
  }

  /**
   * MedicineLocation findMany
   */
  export type MedicineLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * Filter, which MedicineLocations to fetch.
     */
    where?: MedicineLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineLocations to fetch.
     */
    orderBy?: MedicineLocationOrderByWithRelationInput | MedicineLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineLocations.
     */
    cursor?: MedicineLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineLocations.
     */
    skip?: number
    distinct?: MedicineLocationScalarFieldEnum | MedicineLocationScalarFieldEnum[]
  }

  /**
   * MedicineLocation create
   */
  export type MedicineLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineLocation.
     */
    data: XOR<MedicineLocationCreateInput, MedicineLocationUncheckedCreateInput>
  }

  /**
   * MedicineLocation createMany
   */
  export type MedicineLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineLocations.
     */
    data: MedicineLocationCreateManyInput | MedicineLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineLocation createManyAndReturn
   */
  export type MedicineLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineLocations.
     */
    data: MedicineLocationCreateManyInput | MedicineLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineLocation update
   */
  export type MedicineLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineLocation.
     */
    data: XOR<MedicineLocationUpdateInput, MedicineLocationUncheckedUpdateInput>
    /**
     * Choose, which MedicineLocation to update.
     */
    where: MedicineLocationWhereUniqueInput
  }

  /**
   * MedicineLocation updateMany
   */
  export type MedicineLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineLocations.
     */
    data: XOR<MedicineLocationUpdateManyMutationInput, MedicineLocationUncheckedUpdateManyInput>
    /**
     * Filter which MedicineLocations to update
     */
    where?: MedicineLocationWhereInput
    /**
     * Limit how many MedicineLocations to update.
     */
    limit?: number
  }

  /**
   * MedicineLocation updateManyAndReturn
   */
  export type MedicineLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * The data used to update MedicineLocations.
     */
    data: XOR<MedicineLocationUpdateManyMutationInput, MedicineLocationUncheckedUpdateManyInput>
    /**
     * Filter which MedicineLocations to update
     */
    where?: MedicineLocationWhereInput
    /**
     * Limit how many MedicineLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineLocation upsert
   */
  export type MedicineLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineLocation to update in case it exists.
     */
    where: MedicineLocationWhereUniqueInput
    /**
     * In case the MedicineLocation found by the `where` argument doesn't exist, create a new MedicineLocation with this data.
     */
    create: XOR<MedicineLocationCreateInput, MedicineLocationUncheckedCreateInput>
    /**
     * In case the MedicineLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineLocationUpdateInput, MedicineLocationUncheckedUpdateInput>
  }

  /**
   * MedicineLocation delete
   */
  export type MedicineLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
    /**
     * Filter which MedicineLocation to delete.
     */
    where: MedicineLocationWhereUniqueInput
  }

  /**
   * MedicineLocation deleteMany
   */
  export type MedicineLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineLocations to delete
     */
    where?: MedicineLocationWhereInput
    /**
     * Limit how many MedicineLocations to delete.
     */
    limit?: number
  }

  /**
   * MedicineLocation without action
   */
  export type MedicineLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineLocation
     */
    select?: MedicineLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineLocation
     */
    omit?: MedicineLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineLocationInclude<ExtArgs> | null
  }


  /**
   * Model MedicalStoreMedicine
   */

  export type AggregateMedicalStoreMedicine = {
    _count: MedicalStoreMedicineCountAggregateOutputType | null
    _avg: MedicalStoreMedicineAvgAggregateOutputType | null
    _sum: MedicalStoreMedicineSumAggregateOutputType | null
    _min: MedicalStoreMedicineMinAggregateOutputType | null
    _max: MedicalStoreMedicineMaxAggregateOutputType | null
  }

  export type MedicalStoreMedicineAvgAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    quantity: number | null
  }

  export type MedicalStoreMedicineSumAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    quantity: number | null
  }

  export type MedicalStoreMedicineMinAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalStoreMedicineMaxAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalStoreMedicineCountAggregateOutputType = {
    id: number
    medicalStoreId: number
    medicineId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalStoreMedicineAvgAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    quantity?: true
  }

  export type MedicalStoreMedicineSumAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    quantity?: true
  }

  export type MedicalStoreMedicineMinAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalStoreMedicineMaxAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalStoreMedicineCountAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalStoreMedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalStoreMedicine to aggregate.
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStoreMedicines to fetch.
     */
    orderBy?: MedicalStoreMedicineOrderByWithRelationInput | MedicalStoreMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalStoreMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStoreMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStoreMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalStoreMedicines
    **/
    _count?: true | MedicalStoreMedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalStoreMedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalStoreMedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalStoreMedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalStoreMedicineMaxAggregateInputType
  }

  export type GetMedicalStoreMedicineAggregateType<T extends MedicalStoreMedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalStoreMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalStoreMedicine[P]>
      : GetScalarType<T[P], AggregateMedicalStoreMedicine[P]>
  }




  export type MedicalStoreMedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalStoreMedicineWhereInput
    orderBy?: MedicalStoreMedicineOrderByWithAggregationInput | MedicalStoreMedicineOrderByWithAggregationInput[]
    by: MedicalStoreMedicineScalarFieldEnum[] | MedicalStoreMedicineScalarFieldEnum
    having?: MedicalStoreMedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalStoreMedicineCountAggregateInputType | true
    _avg?: MedicalStoreMedicineAvgAggregateInputType
    _sum?: MedicalStoreMedicineSumAggregateInputType
    _min?: MedicalStoreMedicineMinAggregateInputType
    _max?: MedicalStoreMedicineMaxAggregateInputType
  }

  export type MedicalStoreMedicineGroupByOutputType = {
    id: number
    medicalStoreId: number
    medicineId: number
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: MedicalStoreMedicineCountAggregateOutputType | null
    _avg: MedicalStoreMedicineAvgAggregateOutputType | null
    _sum: MedicalStoreMedicineSumAggregateOutputType | null
    _min: MedicalStoreMedicineMinAggregateOutputType | null
    _max: MedicalStoreMedicineMaxAggregateOutputType | null
  }

  type GetMedicalStoreMedicineGroupByPayload<T extends MedicalStoreMedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalStoreMedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalStoreMedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalStoreMedicineGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalStoreMedicineGroupByOutputType[P]>
        }
      >
    >


  export type MedicalStoreMedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStoreMedicine"]>

  export type MedicalStoreMedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStoreMedicine"]>

  export type MedicalStoreMedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalStoreMedicine"]>

  export type MedicalStoreMedicineSelectScalar = {
    id?: boolean
    medicalStoreId?: boolean
    medicineId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalStoreMedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalStoreId" | "medicineId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalStoreMedicine"]>
  export type MedicalStoreMedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type MedicalStoreMedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type MedicalStoreMedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $MedicalStoreMedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalStoreMedicine"
    objects: {
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs>
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicalStoreId: number
      medicineId: number
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalStoreMedicine"]>
    composites: {}
  }

  type MedicalStoreMedicineGetPayload<S extends boolean | null | undefined | MedicalStoreMedicineDefaultArgs> = $Result.GetResult<Prisma.$MedicalStoreMedicinePayload, S>

  type MedicalStoreMedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalStoreMedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalStoreMedicineCountAggregateInputType | true
    }

  export interface MedicalStoreMedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalStoreMedicine'], meta: { name: 'MedicalStoreMedicine' } }
    /**
     * Find zero or one MedicalStoreMedicine that matches the filter.
     * @param {MedicalStoreMedicineFindUniqueArgs} args - Arguments to find a MedicalStoreMedicine
     * @example
     * // Get one MedicalStoreMedicine
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalStoreMedicineFindUniqueArgs>(args: SelectSubset<T, MedicalStoreMedicineFindUniqueArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalStoreMedicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalStoreMedicineFindUniqueOrThrowArgs} args - Arguments to find a MedicalStoreMedicine
     * @example
     * // Get one MedicalStoreMedicine
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalStoreMedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalStoreMedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalStoreMedicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineFindFirstArgs} args - Arguments to find a MedicalStoreMedicine
     * @example
     * // Get one MedicalStoreMedicine
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalStoreMedicineFindFirstArgs>(args?: SelectSubset<T, MedicalStoreMedicineFindFirstArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalStoreMedicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineFindFirstOrThrowArgs} args - Arguments to find a MedicalStoreMedicine
     * @example
     * // Get one MedicalStoreMedicine
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalStoreMedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalStoreMedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalStoreMedicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalStoreMedicines
     * const medicalStoreMedicines = await prisma.medicalStoreMedicine.findMany()
     * 
     * // Get first 10 MedicalStoreMedicines
     * const medicalStoreMedicines = await prisma.medicalStoreMedicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalStoreMedicineWithIdOnly = await prisma.medicalStoreMedicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalStoreMedicineFindManyArgs>(args?: SelectSubset<T, MedicalStoreMedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalStoreMedicine.
     * @param {MedicalStoreMedicineCreateArgs} args - Arguments to create a MedicalStoreMedicine.
     * @example
     * // Create one MedicalStoreMedicine
     * const MedicalStoreMedicine = await prisma.medicalStoreMedicine.create({
     *   data: {
     *     // ... data to create a MedicalStoreMedicine
     *   }
     * })
     * 
     */
    create<T extends MedicalStoreMedicineCreateArgs>(args: SelectSubset<T, MedicalStoreMedicineCreateArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalStoreMedicines.
     * @param {MedicalStoreMedicineCreateManyArgs} args - Arguments to create many MedicalStoreMedicines.
     * @example
     * // Create many MedicalStoreMedicines
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalStoreMedicineCreateManyArgs>(args?: SelectSubset<T, MedicalStoreMedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalStoreMedicines and returns the data saved in the database.
     * @param {MedicalStoreMedicineCreateManyAndReturnArgs} args - Arguments to create many MedicalStoreMedicines.
     * @example
     * // Create many MedicalStoreMedicines
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalStoreMedicines and only return the `id`
     * const medicalStoreMedicineWithIdOnly = await prisma.medicalStoreMedicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalStoreMedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalStoreMedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalStoreMedicine.
     * @param {MedicalStoreMedicineDeleteArgs} args - Arguments to delete one MedicalStoreMedicine.
     * @example
     * // Delete one MedicalStoreMedicine
     * const MedicalStoreMedicine = await prisma.medicalStoreMedicine.delete({
     *   where: {
     *     // ... filter to delete one MedicalStoreMedicine
     *   }
     * })
     * 
     */
    delete<T extends MedicalStoreMedicineDeleteArgs>(args: SelectSubset<T, MedicalStoreMedicineDeleteArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalStoreMedicine.
     * @param {MedicalStoreMedicineUpdateArgs} args - Arguments to update one MedicalStoreMedicine.
     * @example
     * // Update one MedicalStoreMedicine
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalStoreMedicineUpdateArgs>(args: SelectSubset<T, MedicalStoreMedicineUpdateArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalStoreMedicines.
     * @param {MedicalStoreMedicineDeleteManyArgs} args - Arguments to filter MedicalStoreMedicines to delete.
     * @example
     * // Delete a few MedicalStoreMedicines
     * const { count } = await prisma.medicalStoreMedicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalStoreMedicineDeleteManyArgs>(args?: SelectSubset<T, MedicalStoreMedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalStoreMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalStoreMedicines
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalStoreMedicineUpdateManyArgs>(args: SelectSubset<T, MedicalStoreMedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalStoreMedicines and returns the data updated in the database.
     * @param {MedicalStoreMedicineUpdateManyAndReturnArgs} args - Arguments to update many MedicalStoreMedicines.
     * @example
     * // Update many MedicalStoreMedicines
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalStoreMedicines and only return the `id`
     * const medicalStoreMedicineWithIdOnly = await prisma.medicalStoreMedicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalStoreMedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalStoreMedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalStoreMedicine.
     * @param {MedicalStoreMedicineUpsertArgs} args - Arguments to update or create a MedicalStoreMedicine.
     * @example
     * // Update or create a MedicalStoreMedicine
     * const medicalStoreMedicine = await prisma.medicalStoreMedicine.upsert({
     *   create: {
     *     // ... data to create a MedicalStoreMedicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalStoreMedicine we want to update
     *   }
     * })
     */
    upsert<T extends MedicalStoreMedicineUpsertArgs>(args: SelectSubset<T, MedicalStoreMedicineUpsertArgs<ExtArgs>>): Prisma__MedicalStoreMedicineClient<$Result.GetResult<Prisma.$MedicalStoreMedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalStoreMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineCountArgs} args - Arguments to filter MedicalStoreMedicines to count.
     * @example
     * // Count the number of MedicalStoreMedicines
     * const count = await prisma.medicalStoreMedicine.count({
     *   where: {
     *     // ... the filter for the MedicalStoreMedicines we want to count
     *   }
     * })
    **/
    count<T extends MedicalStoreMedicineCountArgs>(
      args?: Subset<T, MedicalStoreMedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalStoreMedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalStoreMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalStoreMedicineAggregateArgs>(args: Subset<T, MedicalStoreMedicineAggregateArgs>): Prisma.PrismaPromise<GetMedicalStoreMedicineAggregateType<T>>

    /**
     * Group by MedicalStoreMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalStoreMedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalStoreMedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalStoreMedicineGroupByArgs['orderBy'] }
        : { orderBy?: MedicalStoreMedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalStoreMedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalStoreMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalStoreMedicine model
   */
  readonly fields: MedicalStoreMedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalStoreMedicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalStoreMedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalStore<T extends MedicalStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStoreDefaultArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalStoreMedicine model
   */
  interface MedicalStoreMedicineFieldRefs {
    readonly id: FieldRef<"MedicalStoreMedicine", 'Int'>
    readonly medicalStoreId: FieldRef<"MedicalStoreMedicine", 'Int'>
    readonly medicineId: FieldRef<"MedicalStoreMedicine", 'Int'>
    readonly quantity: FieldRef<"MedicalStoreMedicine", 'Int'>
    readonly createdAt: FieldRef<"MedicalStoreMedicine", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalStoreMedicine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalStoreMedicine findUnique
   */
  export type MedicalStoreMedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStoreMedicine to fetch.
     */
    where: MedicalStoreMedicineWhereUniqueInput
  }

  /**
   * MedicalStoreMedicine findUniqueOrThrow
   */
  export type MedicalStoreMedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStoreMedicine to fetch.
     */
    where: MedicalStoreMedicineWhereUniqueInput
  }

  /**
   * MedicalStoreMedicine findFirst
   */
  export type MedicalStoreMedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStoreMedicine to fetch.
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStoreMedicines to fetch.
     */
    orderBy?: MedicalStoreMedicineOrderByWithRelationInput | MedicalStoreMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalStoreMedicines.
     */
    cursor?: MedicalStoreMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStoreMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStoreMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalStoreMedicines.
     */
    distinct?: MedicalStoreMedicineScalarFieldEnum | MedicalStoreMedicineScalarFieldEnum[]
  }

  /**
   * MedicalStoreMedicine findFirstOrThrow
   */
  export type MedicalStoreMedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStoreMedicine to fetch.
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStoreMedicines to fetch.
     */
    orderBy?: MedicalStoreMedicineOrderByWithRelationInput | MedicalStoreMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalStoreMedicines.
     */
    cursor?: MedicalStoreMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStoreMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStoreMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalStoreMedicines.
     */
    distinct?: MedicalStoreMedicineScalarFieldEnum | MedicalStoreMedicineScalarFieldEnum[]
  }

  /**
   * MedicalStoreMedicine findMany
   */
  export type MedicalStoreMedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * Filter, which MedicalStoreMedicines to fetch.
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalStoreMedicines to fetch.
     */
    orderBy?: MedicalStoreMedicineOrderByWithRelationInput | MedicalStoreMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalStoreMedicines.
     */
    cursor?: MedicalStoreMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalStoreMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalStoreMedicines.
     */
    skip?: number
    distinct?: MedicalStoreMedicineScalarFieldEnum | MedicalStoreMedicineScalarFieldEnum[]
  }

  /**
   * MedicalStoreMedicine create
   */
  export type MedicalStoreMedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalStoreMedicine.
     */
    data: XOR<MedicalStoreMedicineCreateInput, MedicalStoreMedicineUncheckedCreateInput>
  }

  /**
   * MedicalStoreMedicine createMany
   */
  export type MedicalStoreMedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalStoreMedicines.
     */
    data: MedicalStoreMedicineCreateManyInput | MedicalStoreMedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalStoreMedicine createManyAndReturn
   */
  export type MedicalStoreMedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalStoreMedicines.
     */
    data: MedicalStoreMedicineCreateManyInput | MedicalStoreMedicineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalStoreMedicine update
   */
  export type MedicalStoreMedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalStoreMedicine.
     */
    data: XOR<MedicalStoreMedicineUpdateInput, MedicalStoreMedicineUncheckedUpdateInput>
    /**
     * Choose, which MedicalStoreMedicine to update.
     */
    where: MedicalStoreMedicineWhereUniqueInput
  }

  /**
   * MedicalStoreMedicine updateMany
   */
  export type MedicalStoreMedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalStoreMedicines.
     */
    data: XOR<MedicalStoreMedicineUpdateManyMutationInput, MedicalStoreMedicineUncheckedUpdateManyInput>
    /**
     * Filter which MedicalStoreMedicines to update
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * Limit how many MedicalStoreMedicines to update.
     */
    limit?: number
  }

  /**
   * MedicalStoreMedicine updateManyAndReturn
   */
  export type MedicalStoreMedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * The data used to update MedicalStoreMedicines.
     */
    data: XOR<MedicalStoreMedicineUpdateManyMutationInput, MedicalStoreMedicineUncheckedUpdateManyInput>
    /**
     * Filter which MedicalStoreMedicines to update
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * Limit how many MedicalStoreMedicines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalStoreMedicine upsert
   */
  export type MedicalStoreMedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalStoreMedicine to update in case it exists.
     */
    where: MedicalStoreMedicineWhereUniqueInput
    /**
     * In case the MedicalStoreMedicine found by the `where` argument doesn't exist, create a new MedicalStoreMedicine with this data.
     */
    create: XOR<MedicalStoreMedicineCreateInput, MedicalStoreMedicineUncheckedCreateInput>
    /**
     * In case the MedicalStoreMedicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalStoreMedicineUpdateInput, MedicalStoreMedicineUncheckedUpdateInput>
  }

  /**
   * MedicalStoreMedicine delete
   */
  export type MedicalStoreMedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
    /**
     * Filter which MedicalStoreMedicine to delete.
     */
    where: MedicalStoreMedicineWhereUniqueInput
  }

  /**
   * MedicalStoreMedicine deleteMany
   */
  export type MedicalStoreMedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalStoreMedicines to delete
     */
    where?: MedicalStoreMedicineWhereInput
    /**
     * Limit how many MedicalStoreMedicines to delete.
     */
    limit?: number
  }

  /**
   * MedicalStoreMedicine without action
   */
  export type MedicalStoreMedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalStoreMedicine
     */
    select?: MedicalStoreMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalStoreMedicine
     */
    omit?: MedicalStoreMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalStoreMedicineInclude<ExtArgs> | null
  }


  /**
   * Model MedicineExpiry
   */

  export type AggregateMedicineExpiry = {
    _count: MedicineExpiryCountAggregateOutputType | null
    _avg: MedicineExpiryAvgAggregateOutputType | null
    _sum: MedicineExpirySumAggregateOutputType | null
    _min: MedicineExpiryMinAggregateOutputType | null
    _max: MedicineExpiryMaxAggregateOutputType | null
  }

  export type MedicineExpiryAvgAggregateOutputType = {
    id: number | null
    medicineId: number | null
  }

  export type MedicineExpirySumAggregateOutputType = {
    id: number | null
    medicineId: number | null
  }

  export type MedicineExpiryMinAggregateOutputType = {
    id: number | null
    medicineId: number | null
    expiryDate: Date | null
    isNearExpiry: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineExpiryMaxAggregateOutputType = {
    id: number | null
    medicineId: number | null
    expiryDate: Date | null
    isNearExpiry: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineExpiryCountAggregateOutputType = {
    id: number
    medicineId: number
    expiryDate: number
    isNearExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineExpiryAvgAggregateInputType = {
    id?: true
    medicineId?: true
  }

  export type MedicineExpirySumAggregateInputType = {
    id?: true
    medicineId?: true
  }

  export type MedicineExpiryMinAggregateInputType = {
    id?: true
    medicineId?: true
    expiryDate?: true
    isNearExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineExpiryMaxAggregateInputType = {
    id?: true
    medicineId?: true
    expiryDate?: true
    isNearExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineExpiryCountAggregateInputType = {
    id?: true
    medicineId?: true
    expiryDate?: true
    isNearExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineExpiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineExpiry to aggregate.
     */
    where?: MedicineExpiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineExpiries to fetch.
     */
    orderBy?: MedicineExpiryOrderByWithRelationInput | MedicineExpiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineExpiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineExpiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineExpiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineExpiries
    **/
    _count?: true | MedicineExpiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineExpiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineExpirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineExpiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineExpiryMaxAggregateInputType
  }

  export type GetMedicineExpiryAggregateType<T extends MedicineExpiryAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineExpiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineExpiry[P]>
      : GetScalarType<T[P], AggregateMedicineExpiry[P]>
  }




  export type MedicineExpiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineExpiryWhereInput
    orderBy?: MedicineExpiryOrderByWithAggregationInput | MedicineExpiryOrderByWithAggregationInput[]
    by: MedicineExpiryScalarFieldEnum[] | MedicineExpiryScalarFieldEnum
    having?: MedicineExpiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineExpiryCountAggregateInputType | true
    _avg?: MedicineExpiryAvgAggregateInputType
    _sum?: MedicineExpirySumAggregateInputType
    _min?: MedicineExpiryMinAggregateInputType
    _max?: MedicineExpiryMaxAggregateInputType
  }

  export type MedicineExpiryGroupByOutputType = {
    id: number
    medicineId: number
    expiryDate: Date
    isNearExpiry: boolean
    createdAt: Date
    updatedAt: Date
    _count: MedicineExpiryCountAggregateOutputType | null
    _avg: MedicineExpiryAvgAggregateOutputType | null
    _sum: MedicineExpirySumAggregateOutputType | null
    _min: MedicineExpiryMinAggregateOutputType | null
    _max: MedicineExpiryMaxAggregateOutputType | null
  }

  type GetMedicineExpiryGroupByPayload<T extends MedicineExpiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineExpiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineExpiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineExpiryGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineExpiryGroupByOutputType[P]>
        }
      >
    >


  export type MedicineExpirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    expiryDate?: boolean
    isNearExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineExpiry"]>

  export type MedicineExpirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    expiryDate?: boolean
    isNearExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineExpiry"]>

  export type MedicineExpirySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    expiryDate?: boolean
    isNearExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineExpiry"]>

  export type MedicineExpirySelectScalar = {
    id?: boolean
    medicineId?: boolean
    expiryDate?: boolean
    isNearExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineExpiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicineId" | "expiryDate" | "isNearExpiry" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineExpiry"]>
  export type MedicineExpiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type MedicineExpiryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type MedicineExpiryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $MedicineExpiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineExpiry"
    objects: {
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicineId: number
      expiryDate: Date
      isNearExpiry: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineExpiry"]>
    composites: {}
  }

  type MedicineExpiryGetPayload<S extends boolean | null | undefined | MedicineExpiryDefaultArgs> = $Result.GetResult<Prisma.$MedicineExpiryPayload, S>

  type MedicineExpiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineExpiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineExpiryCountAggregateInputType | true
    }

  export interface MedicineExpiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineExpiry'], meta: { name: 'MedicineExpiry' } }
    /**
     * Find zero or one MedicineExpiry that matches the filter.
     * @param {MedicineExpiryFindUniqueArgs} args - Arguments to find a MedicineExpiry
     * @example
     * // Get one MedicineExpiry
     * const medicineExpiry = await prisma.medicineExpiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineExpiryFindUniqueArgs>(args: SelectSubset<T, MedicineExpiryFindUniqueArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineExpiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineExpiryFindUniqueOrThrowArgs} args - Arguments to find a MedicineExpiry
     * @example
     * // Get one MedicineExpiry
     * const medicineExpiry = await prisma.medicineExpiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineExpiryFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineExpiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineExpiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryFindFirstArgs} args - Arguments to find a MedicineExpiry
     * @example
     * // Get one MedicineExpiry
     * const medicineExpiry = await prisma.medicineExpiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineExpiryFindFirstArgs>(args?: SelectSubset<T, MedicineExpiryFindFirstArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineExpiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryFindFirstOrThrowArgs} args - Arguments to find a MedicineExpiry
     * @example
     * // Get one MedicineExpiry
     * const medicineExpiry = await prisma.medicineExpiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineExpiryFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineExpiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineExpiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineExpiries
     * const medicineExpiries = await prisma.medicineExpiry.findMany()
     * 
     * // Get first 10 MedicineExpiries
     * const medicineExpiries = await prisma.medicineExpiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineExpiryWithIdOnly = await prisma.medicineExpiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineExpiryFindManyArgs>(args?: SelectSubset<T, MedicineExpiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineExpiry.
     * @param {MedicineExpiryCreateArgs} args - Arguments to create a MedicineExpiry.
     * @example
     * // Create one MedicineExpiry
     * const MedicineExpiry = await prisma.medicineExpiry.create({
     *   data: {
     *     // ... data to create a MedicineExpiry
     *   }
     * })
     * 
     */
    create<T extends MedicineExpiryCreateArgs>(args: SelectSubset<T, MedicineExpiryCreateArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineExpiries.
     * @param {MedicineExpiryCreateManyArgs} args - Arguments to create many MedicineExpiries.
     * @example
     * // Create many MedicineExpiries
     * const medicineExpiry = await prisma.medicineExpiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineExpiryCreateManyArgs>(args?: SelectSubset<T, MedicineExpiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineExpiries and returns the data saved in the database.
     * @param {MedicineExpiryCreateManyAndReturnArgs} args - Arguments to create many MedicineExpiries.
     * @example
     * // Create many MedicineExpiries
     * const medicineExpiry = await prisma.medicineExpiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineExpiries and only return the `id`
     * const medicineExpiryWithIdOnly = await prisma.medicineExpiry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineExpiryCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineExpiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicineExpiry.
     * @param {MedicineExpiryDeleteArgs} args - Arguments to delete one MedicineExpiry.
     * @example
     * // Delete one MedicineExpiry
     * const MedicineExpiry = await prisma.medicineExpiry.delete({
     *   where: {
     *     // ... filter to delete one MedicineExpiry
     *   }
     * })
     * 
     */
    delete<T extends MedicineExpiryDeleteArgs>(args: SelectSubset<T, MedicineExpiryDeleteArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineExpiry.
     * @param {MedicineExpiryUpdateArgs} args - Arguments to update one MedicineExpiry.
     * @example
     * // Update one MedicineExpiry
     * const medicineExpiry = await prisma.medicineExpiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineExpiryUpdateArgs>(args: SelectSubset<T, MedicineExpiryUpdateArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineExpiries.
     * @param {MedicineExpiryDeleteManyArgs} args - Arguments to filter MedicineExpiries to delete.
     * @example
     * // Delete a few MedicineExpiries
     * const { count } = await prisma.medicineExpiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineExpiryDeleteManyArgs>(args?: SelectSubset<T, MedicineExpiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineExpiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineExpiries
     * const medicineExpiry = await prisma.medicineExpiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineExpiryUpdateManyArgs>(args: SelectSubset<T, MedicineExpiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineExpiries and returns the data updated in the database.
     * @param {MedicineExpiryUpdateManyAndReturnArgs} args - Arguments to update many MedicineExpiries.
     * @example
     * // Update many MedicineExpiries
     * const medicineExpiry = await prisma.medicineExpiry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineExpiries and only return the `id`
     * const medicineExpiryWithIdOnly = await prisma.medicineExpiry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineExpiryUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineExpiryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicineExpiry.
     * @param {MedicineExpiryUpsertArgs} args - Arguments to update or create a MedicineExpiry.
     * @example
     * // Update or create a MedicineExpiry
     * const medicineExpiry = await prisma.medicineExpiry.upsert({
     *   create: {
     *     // ... data to create a MedicineExpiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineExpiry we want to update
     *   }
     * })
     */
    upsert<T extends MedicineExpiryUpsertArgs>(args: SelectSubset<T, MedicineExpiryUpsertArgs<ExtArgs>>): Prisma__MedicineExpiryClient<$Result.GetResult<Prisma.$MedicineExpiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineExpiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryCountArgs} args - Arguments to filter MedicineExpiries to count.
     * @example
     * // Count the number of MedicineExpiries
     * const count = await prisma.medicineExpiry.count({
     *   where: {
     *     // ... the filter for the MedicineExpiries we want to count
     *   }
     * })
    **/
    count<T extends MedicineExpiryCountArgs>(
      args?: Subset<T, MedicineExpiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineExpiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineExpiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineExpiryAggregateArgs>(args: Subset<T, MedicineExpiryAggregateArgs>): Prisma.PrismaPromise<GetMedicineExpiryAggregateType<T>>

    /**
     * Group by MedicineExpiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineExpiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineExpiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineExpiryGroupByArgs['orderBy'] }
        : { orderBy?: MedicineExpiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineExpiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineExpiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineExpiry model
   */
  readonly fields: MedicineExpiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineExpiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineExpiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineExpiry model
   */
  interface MedicineExpiryFieldRefs {
    readonly id: FieldRef<"MedicineExpiry", 'Int'>
    readonly medicineId: FieldRef<"MedicineExpiry", 'Int'>
    readonly expiryDate: FieldRef<"MedicineExpiry", 'DateTime'>
    readonly isNearExpiry: FieldRef<"MedicineExpiry", 'Boolean'>
    readonly createdAt: FieldRef<"MedicineExpiry", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineExpiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineExpiry findUnique
   */
  export type MedicineExpiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * Filter, which MedicineExpiry to fetch.
     */
    where: MedicineExpiryWhereUniqueInput
  }

  /**
   * MedicineExpiry findUniqueOrThrow
   */
  export type MedicineExpiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * Filter, which MedicineExpiry to fetch.
     */
    where: MedicineExpiryWhereUniqueInput
  }

  /**
   * MedicineExpiry findFirst
   */
  export type MedicineExpiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * Filter, which MedicineExpiry to fetch.
     */
    where?: MedicineExpiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineExpiries to fetch.
     */
    orderBy?: MedicineExpiryOrderByWithRelationInput | MedicineExpiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineExpiries.
     */
    cursor?: MedicineExpiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineExpiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineExpiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineExpiries.
     */
    distinct?: MedicineExpiryScalarFieldEnum | MedicineExpiryScalarFieldEnum[]
  }

  /**
   * MedicineExpiry findFirstOrThrow
   */
  export type MedicineExpiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * Filter, which MedicineExpiry to fetch.
     */
    where?: MedicineExpiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineExpiries to fetch.
     */
    orderBy?: MedicineExpiryOrderByWithRelationInput | MedicineExpiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineExpiries.
     */
    cursor?: MedicineExpiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineExpiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineExpiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineExpiries.
     */
    distinct?: MedicineExpiryScalarFieldEnum | MedicineExpiryScalarFieldEnum[]
  }

  /**
   * MedicineExpiry findMany
   */
  export type MedicineExpiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * Filter, which MedicineExpiries to fetch.
     */
    where?: MedicineExpiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineExpiries to fetch.
     */
    orderBy?: MedicineExpiryOrderByWithRelationInput | MedicineExpiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineExpiries.
     */
    cursor?: MedicineExpiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineExpiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineExpiries.
     */
    skip?: number
    distinct?: MedicineExpiryScalarFieldEnum | MedicineExpiryScalarFieldEnum[]
  }

  /**
   * MedicineExpiry create
   */
  export type MedicineExpiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineExpiry.
     */
    data: XOR<MedicineExpiryCreateInput, MedicineExpiryUncheckedCreateInput>
  }

  /**
   * MedicineExpiry createMany
   */
  export type MedicineExpiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineExpiries.
     */
    data: MedicineExpiryCreateManyInput | MedicineExpiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineExpiry createManyAndReturn
   */
  export type MedicineExpiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineExpiries.
     */
    data: MedicineExpiryCreateManyInput | MedicineExpiryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineExpiry update
   */
  export type MedicineExpiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineExpiry.
     */
    data: XOR<MedicineExpiryUpdateInput, MedicineExpiryUncheckedUpdateInput>
    /**
     * Choose, which MedicineExpiry to update.
     */
    where: MedicineExpiryWhereUniqueInput
  }

  /**
   * MedicineExpiry updateMany
   */
  export type MedicineExpiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineExpiries.
     */
    data: XOR<MedicineExpiryUpdateManyMutationInput, MedicineExpiryUncheckedUpdateManyInput>
    /**
     * Filter which MedicineExpiries to update
     */
    where?: MedicineExpiryWhereInput
    /**
     * Limit how many MedicineExpiries to update.
     */
    limit?: number
  }

  /**
   * MedicineExpiry updateManyAndReturn
   */
  export type MedicineExpiryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * The data used to update MedicineExpiries.
     */
    data: XOR<MedicineExpiryUpdateManyMutationInput, MedicineExpiryUncheckedUpdateManyInput>
    /**
     * Filter which MedicineExpiries to update
     */
    where?: MedicineExpiryWhereInput
    /**
     * Limit how many MedicineExpiries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineExpiry upsert
   */
  export type MedicineExpiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineExpiry to update in case it exists.
     */
    where: MedicineExpiryWhereUniqueInput
    /**
     * In case the MedicineExpiry found by the `where` argument doesn't exist, create a new MedicineExpiry with this data.
     */
    create: XOR<MedicineExpiryCreateInput, MedicineExpiryUncheckedCreateInput>
    /**
     * In case the MedicineExpiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineExpiryUpdateInput, MedicineExpiryUncheckedUpdateInput>
  }

  /**
   * MedicineExpiry delete
   */
  export type MedicineExpiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
    /**
     * Filter which MedicineExpiry to delete.
     */
    where: MedicineExpiryWhereUniqueInput
  }

  /**
   * MedicineExpiry deleteMany
   */
  export type MedicineExpiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineExpiries to delete
     */
    where?: MedicineExpiryWhereInput
    /**
     * Limit how many MedicineExpiries to delete.
     */
    limit?: number
  }

  /**
   * MedicineExpiry without action
   */
  export type MedicineExpiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineExpiry
     */
    select?: MedicineExpirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineExpiry
     */
    omit?: MedicineExpiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineExpiryInclude<ExtArgs> | null
  }


  /**
   * Model StockTransaction
   */

  export type AggregateStockTransaction = {
    _count: StockTransactionCountAggregateOutputType | null
    _avg: StockTransactionAvgAggregateOutputType | null
    _sum: StockTransactionSumAggregateOutputType | null
    _min: StockTransactionMinAggregateOutputType | null
    _max: StockTransactionMaxAggregateOutputType | null
  }

  export type StockTransactionAvgAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineInstanceId: number | null
    purchaseOrderId: number | null
    quantity: number | null
  }

  export type StockTransactionSumAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineInstanceId: number | null
    purchaseOrderId: number | null
    quantity: number | null
  }

  export type StockTransactionMinAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineInstanceId: number | null
    purchaseOrderId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransactionMaxAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    medicineInstanceId: number | null
    purchaseOrderId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransactionCountAggregateOutputType = {
    id: number
    medicalStoreId: number
    medicineInstanceId: number
    purchaseOrderId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockTransactionAvgAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineInstanceId?: true
    purchaseOrderId?: true
    quantity?: true
  }

  export type StockTransactionSumAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineInstanceId?: true
    purchaseOrderId?: true
    quantity?: true
  }

  export type StockTransactionMinAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineInstanceId?: true
    purchaseOrderId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransactionMaxAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineInstanceId?: true
    purchaseOrderId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransactionCountAggregateInputType = {
    id?: true
    medicalStoreId?: true
    medicineInstanceId?: true
    purchaseOrderId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransaction to aggregate.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransactions
    **/
    _count?: true | StockTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransactionMaxAggregateInputType
  }

  export type GetStockTransactionAggregateType<T extends StockTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransaction[P]>
      : GetScalarType<T[P], AggregateStockTransaction[P]>
  }




  export type StockTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithAggregationInput | StockTransactionOrderByWithAggregationInput[]
    by: StockTransactionScalarFieldEnum[] | StockTransactionScalarFieldEnum
    having?: StockTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransactionCountAggregateInputType | true
    _avg?: StockTransactionAvgAggregateInputType
    _sum?: StockTransactionSumAggregateInputType
    _min?: StockTransactionMinAggregateInputType
    _max?: StockTransactionMaxAggregateInputType
  }

  export type StockTransactionGroupByOutputType = {
    id: number
    medicalStoreId: number
    medicineInstanceId: number
    purchaseOrderId: number | null
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: StockTransactionCountAggregateOutputType | null
    _avg: StockTransactionAvgAggregateOutputType | null
    _sum: StockTransactionSumAggregateOutputType | null
    _min: StockTransactionMinAggregateOutputType | null
    _max: StockTransactionMaxAggregateOutputType | null
  }

  type GetStockTransactionGroupByPayload<T extends StockTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransactionGroupByOutputType[P]>
        }
      >
    >


  export type StockTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineInstanceId?: boolean
    purchaseOrderId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicineInstance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockTransaction$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineInstanceId?: boolean
    purchaseOrderId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicineInstance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockTransaction$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    medicineInstanceId?: boolean
    purchaseOrderId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicineInstance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockTransaction$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectScalar = {
    id?: boolean
    medicalStoreId?: boolean
    medicineInstanceId?: boolean
    purchaseOrderId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalStoreId" | "medicineInstanceId" | "purchaseOrderId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["stockTransaction"]>
  export type StockTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicineInstance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockTransaction$purchaseOrderArgs<ExtArgs>
  }
  export type StockTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicineInstance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockTransaction$purchaseOrderArgs<ExtArgs>
  }
  export type StockTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    medicineInstance?: boolean | MedicineInstanceDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockTransaction$purchaseOrderArgs<ExtArgs>
  }

  export type $StockTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransaction"
    objects: {
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs>
      medicineInstance: Prisma.$MedicineInstancePayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicalStoreId: number
      medicineInstanceId: number
      purchaseOrderId: number | null
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockTransaction"]>
    composites: {}
  }

  type StockTransactionGetPayload<S extends boolean | null | undefined | StockTransactionDefaultArgs> = $Result.GetResult<Prisma.$StockTransactionPayload, S>

  type StockTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransactionCountAggregateInputType | true
    }

  export interface StockTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransaction'], meta: { name: 'StockTransaction' } }
    /**
     * Find zero or one StockTransaction that matches the filter.
     * @param {StockTransactionFindUniqueArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransactionFindUniqueArgs>(args: SelectSubset<T, StockTransactionFindUniqueArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransactionFindUniqueOrThrowArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindFirstArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransactionFindFirstArgs>(args?: SelectSubset<T, StockTransactionFindFirstArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindFirstOrThrowArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransactions
     * const stockTransactions = await prisma.stockTransaction.findMany()
     * 
     * // Get first 10 StockTransactions
     * const stockTransactions = await prisma.stockTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransactionFindManyArgs>(args?: SelectSubset<T, StockTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransaction.
     * @param {StockTransactionCreateArgs} args - Arguments to create a StockTransaction.
     * @example
     * // Create one StockTransaction
     * const StockTransaction = await prisma.stockTransaction.create({
     *   data: {
     *     // ... data to create a StockTransaction
     *   }
     * })
     * 
     */
    create<T extends StockTransactionCreateArgs>(args: SelectSubset<T, StockTransactionCreateArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransactions.
     * @param {StockTransactionCreateManyArgs} args - Arguments to create many StockTransactions.
     * @example
     * // Create many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransactionCreateManyArgs>(args?: SelectSubset<T, StockTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransactions and returns the data saved in the database.
     * @param {StockTransactionCreateManyAndReturnArgs} args - Arguments to create many StockTransactions.
     * @example
     * // Create many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransactions and only return the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransaction.
     * @param {StockTransactionDeleteArgs} args - Arguments to delete one StockTransaction.
     * @example
     * // Delete one StockTransaction
     * const StockTransaction = await prisma.stockTransaction.delete({
     *   where: {
     *     // ... filter to delete one StockTransaction
     *   }
     * })
     * 
     */
    delete<T extends StockTransactionDeleteArgs>(args: SelectSubset<T, StockTransactionDeleteArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransaction.
     * @param {StockTransactionUpdateArgs} args - Arguments to update one StockTransaction.
     * @example
     * // Update one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransactionUpdateArgs>(args: SelectSubset<T, StockTransactionUpdateArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransactions.
     * @param {StockTransactionDeleteManyArgs} args - Arguments to filter StockTransactions to delete.
     * @example
     * // Delete a few StockTransactions
     * const { count } = await prisma.stockTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransactionDeleteManyArgs>(args?: SelectSubset<T, StockTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransactionUpdateManyArgs>(args: SelectSubset<T, StockTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransactions and returns the data updated in the database.
     * @param {StockTransactionUpdateManyAndReturnArgs} args - Arguments to update many StockTransactions.
     * @example
     * // Update many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransactions and only return the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransaction.
     * @param {StockTransactionUpsertArgs} args - Arguments to update or create a StockTransaction.
     * @example
     * // Update or create a StockTransaction
     * const stockTransaction = await prisma.stockTransaction.upsert({
     *   create: {
     *     // ... data to create a StockTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransaction we want to update
     *   }
     * })
     */
    upsert<T extends StockTransactionUpsertArgs>(args: SelectSubset<T, StockTransactionUpsertArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionCountArgs} args - Arguments to filter StockTransactions to count.
     * @example
     * // Count the number of StockTransactions
     * const count = await prisma.stockTransaction.count({
     *   where: {
     *     // ... the filter for the StockTransactions we want to count
     *   }
     * })
    **/
    count<T extends StockTransactionCountArgs>(
      args?: Subset<T, StockTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransactionAggregateArgs>(args: Subset<T, StockTransactionAggregateArgs>): Prisma.PrismaPromise<GetStockTransactionAggregateType<T>>

    /**
     * Group by StockTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransactionGroupByArgs['orderBy'] }
        : { orderBy?: StockTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransaction model
   */
  readonly fields: StockTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalStore<T extends MedicalStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStoreDefaultArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicineInstance<T extends MedicineInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineInstanceDefaultArgs<ExtArgs>>): Prisma__MedicineInstanceClient<$Result.GetResult<Prisma.$MedicineInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends StockTransaction$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, StockTransaction$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransaction model
   */
  interface StockTransactionFieldRefs {
    readonly id: FieldRef<"StockTransaction", 'Int'>
    readonly medicalStoreId: FieldRef<"StockTransaction", 'Int'>
    readonly medicineInstanceId: FieldRef<"StockTransaction", 'Int'>
    readonly purchaseOrderId: FieldRef<"StockTransaction", 'Int'>
    readonly quantity: FieldRef<"StockTransaction", 'Int'>
    readonly createdAt: FieldRef<"StockTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"StockTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTransaction findUnique
   */
  export type StockTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction findUniqueOrThrow
   */
  export type StockTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction findFirst
   */
  export type StockTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransactions.
     */
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction findFirstOrThrow
   */
  export type StockTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransactions.
     */
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction findMany
   */
  export type StockTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransactions to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction create
   */
  export type StockTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransaction.
     */
    data: XOR<StockTransactionCreateInput, StockTransactionUncheckedCreateInput>
  }

  /**
   * StockTransaction createMany
   */
  export type StockTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransactions.
     */
    data: StockTransactionCreateManyInput | StockTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTransaction createManyAndReturn
   */
  export type StockTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransactions.
     */
    data: StockTransactionCreateManyInput | StockTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransaction update
   */
  export type StockTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransaction.
     */
    data: XOR<StockTransactionUpdateInput, StockTransactionUncheckedUpdateInput>
    /**
     * Choose, which StockTransaction to update.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction updateMany
   */
  export type StockTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransactions.
     */
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StockTransactions to update
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to update.
     */
    limit?: number
  }

  /**
   * StockTransaction updateManyAndReturn
   */
  export type StockTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * The data used to update StockTransactions.
     */
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StockTransactions to update
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransaction upsert
   */
  export type StockTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransaction to update in case it exists.
     */
    where: StockTransactionWhereUniqueInput
    /**
     * In case the StockTransaction found by the `where` argument doesn't exist, create a new StockTransaction with this data.
     */
    create: XOR<StockTransactionCreateInput, StockTransactionUncheckedCreateInput>
    /**
     * In case the StockTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransactionUpdateInput, StockTransactionUncheckedUpdateInput>
  }

  /**
   * StockTransaction delete
   */
  export type StockTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter which StockTransaction to delete.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction deleteMany
   */
  export type StockTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransactions to delete
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to delete.
     */
    limit?: number
  }

  /**
   * StockTransaction.purchaseOrder
   */
  export type StockTransaction$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * StockTransaction without action
   */
  export type StockTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    supplierId: number | null
    userId: number | null
    totalCost: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    supplierId: number | null
    userId: number | null
    totalCost: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    supplierId: number | null
    userId: number | null
    orderDate: Date | null
    status: string | null
    totalCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: number | null
    medicalStoreId: number | null
    supplierId: number | null
    userId: number | null
    orderDate: Date | null
    status: string | null
    totalCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    medicalStoreId: number
    supplierId: number
    userId: number
    orderDate: number
    status: number
    totalCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    id?: true
    medicalStoreId?: true
    supplierId?: true
    userId?: true
    totalCost?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    id?: true
    medicalStoreId?: true
    supplierId?: true
    userId?: true
    totalCost?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    medicalStoreId?: true
    supplierId?: true
    userId?: true
    orderDate?: true
    status?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    medicalStoreId?: true
    supplierId?: true
    userId?: true
    orderDate?: true
    status?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    medicalStoreId?: true
    supplierId?: true
    userId?: true
    orderDate?: true
    status?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: number
    medicalStoreId: number
    supplierId: number | null
    userId: number
    orderDate: Date
    status: string
    totalCost: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    supplierId?: boolean
    userId?: boolean
    orderDate?: boolean
    status?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    batches?: boolean | PurchaseOrder$batchesArgs<ExtArgs>
    stockTransactions?: boolean | PurchaseOrder$stockTransactionsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    supplierId?: boolean
    userId?: boolean
    orderDate?: boolean
    status?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalStoreId?: boolean
    supplierId?: boolean
    userId?: boolean
    orderDate?: boolean
    status?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    medicalStoreId?: boolean
    supplierId?: boolean
    userId?: boolean
    orderDate?: boolean
    status?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalStoreId" | "supplierId" | "userId" | "orderDate" | "status" | "totalCost" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    batches?: boolean | PurchaseOrder$batchesArgs<ExtArgs>
    stockTransactions?: boolean | PurchaseOrder$stockTransactionsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalStore?: boolean | MedicalStoreDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      medicalStore: Prisma.$MedicalStorePayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      batches: Prisma.$BatchPayload<ExtArgs>[]
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicalStoreId: number
      supplierId: number | null
      userId: number
      orderDate: Date
      status: string
      totalCost: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalStore<T extends MedicalStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalStoreDefaultArgs<ExtArgs>>): Prisma__MedicalStoreClient<$Result.GetResult<Prisma.$MedicalStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends PurchaseOrder$supplierArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batches<T extends PurchaseOrder$batchesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransactions<T extends PurchaseOrder$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'Int'>
    readonly medicalStoreId: FieldRef<"PurchaseOrder", 'Int'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'Int'>
    readonly userId: FieldRef<"PurchaseOrder", 'Int'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly totalCost: FieldRef<"PurchaseOrder", 'Float'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.supplier
   */
  export type PurchaseOrder$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * PurchaseOrder.batches
   */
  export type PurchaseOrder$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.stockTransactions
   */
  export type PurchaseOrder$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    customerId: number | null
    changeCash: number | null
    discount: number | null
    itemsCost: number | null
    tax: number | null
    sellingPrice: number | null
    profit: number | null
    bill: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    customerId: number | null
    changeCash: number | null
    discount: number | null
    itemsCost: number | null
    tax: number | null
    sellingPrice: number | null
    profit: number | null
    bill: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    customerId: number | null
    customerName: string | null
    customerLocation: string | null
    customerContact: string | null
    paymentMethod: $Enums.PaymentMethod | null
    changeCash: number | null
    discount: number | null
    discountType: $Enums.DiscountType | null
    itemsCost: number | null
    tax: number | null
    sellingPrice: number | null
    profit: number | null
    bill: number | null
    invoiceDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    customerId: number | null
    customerName: string | null
    customerLocation: string | null
    customerContact: string | null
    paymentMethod: $Enums.PaymentMethod | null
    changeCash: number | null
    discount: number | null
    discountType: $Enums.DiscountType | null
    itemsCost: number | null
    tax: number | null
    sellingPrice: number | null
    profit: number | null
    bill: number | null
    invoiceDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    customerId: number
    customerName: number
    customerLocation: number
    customerContact: number
    paymentMethod: number
    changeCash: number
    discount: number
    discountType: number
    itemsCost: number
    tax: number
    sellingPrice: number
    profit: number
    bill: number
    invoiceDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    changeCash?: true
    discount?: true
    itemsCost?: true
    tax?: true
    sellingPrice?: true
    profit?: true
    bill?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    changeCash?: true
    discount?: true
    itemsCost?: true
    tax?: true
    sellingPrice?: true
    profit?: true
    bill?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    customerName?: true
    customerLocation?: true
    customerContact?: true
    paymentMethod?: true
    changeCash?: true
    discount?: true
    discountType?: true
    itemsCost?: true
    tax?: true
    sellingPrice?: true
    profit?: true
    bill?: true
    invoiceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    customerName?: true
    customerLocation?: true
    customerContact?: true
    paymentMethod?: true
    changeCash?: true
    discount?: true
    discountType?: true
    itemsCost?: true
    tax?: true
    sellingPrice?: true
    profit?: true
    bill?: true
    invoiceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    customerName?: true
    customerLocation?: true
    customerContact?: true
    paymentMethod?: true
    changeCash?: true
    discount?: true
    discountType?: true
    itemsCost?: true
    tax?: true
    sellingPrice?: true
    profit?: true
    bill?: true
    invoiceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    userId: number
    customerId: number | null
    customerName: string | null
    customerLocation: string | null
    customerContact: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash: number | null
    discount: number | null
    discountType: $Enums.DiscountType | null
    itemsCost: number
    tax: number | null
    sellingPrice: number
    profit: number | null
    bill: number
    invoiceDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerLocation?: boolean
    customerContact?: boolean
    paymentMethod?: boolean
    changeCash?: boolean
    discount?: boolean
    discountType?: boolean
    itemsCost?: boolean
    tax?: boolean
    sellingPrice?: boolean
    profit?: boolean
    bill?: boolean
    invoiceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    soldItems?: boolean | Order$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | Order$returnedItemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerLocation?: boolean
    customerContact?: boolean
    paymentMethod?: boolean
    changeCash?: boolean
    discount?: boolean
    discountType?: boolean
    itemsCost?: boolean
    tax?: boolean
    sellingPrice?: boolean
    profit?: boolean
    bill?: boolean
    invoiceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerLocation?: boolean
    customerContact?: boolean
    paymentMethod?: boolean
    changeCash?: boolean
    discount?: boolean
    discountType?: boolean
    itemsCost?: boolean
    tax?: boolean
    sellingPrice?: boolean
    profit?: boolean
    bill?: boolean
    invoiceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerLocation?: boolean
    customerContact?: boolean
    paymentMethod?: boolean
    changeCash?: boolean
    discount?: boolean
    discountType?: boolean
    itemsCost?: boolean
    tax?: boolean
    sellingPrice?: boolean
    profit?: boolean
    bill?: boolean
    invoiceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "customerId" | "customerName" | "customerLocation" | "customerContact" | "paymentMethod" | "changeCash" | "discount" | "discountType" | "itemsCost" | "tax" | "sellingPrice" | "profit" | "bill" | "invoiceDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    soldItems?: boolean | Order$soldItemsArgs<ExtArgs>
    returnedItems?: boolean | Order$returnedItemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      soldItems: Prisma.$SoldItemsPayload<ExtArgs>[]
      returnedItems: Prisma.$ReturnedItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      customerId: number | null
      customerName: string | null
      customerLocation: string | null
      customerContact: string | null
      paymentMethod: $Enums.PaymentMethod
      changeCash: number | null
      discount: number | null
      discountType: $Enums.DiscountType | null
      itemsCost: number
      tax: number | null
      sellingPrice: number
      profit: number | null
      bill: number
      invoiceDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    soldItems<T extends Order$soldItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$soldItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnedItems<T extends Order$returnedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$returnedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly userId: FieldRef<"Order", 'Int'>
    readonly customerId: FieldRef<"Order", 'Int'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerLocation: FieldRef<"Order", 'String'>
    readonly customerContact: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'PaymentMethod'>
    readonly changeCash: FieldRef<"Order", 'Float'>
    readonly discount: FieldRef<"Order", 'Float'>
    readonly discountType: FieldRef<"Order", 'DiscountType'>
    readonly itemsCost: FieldRef<"Order", 'Float'>
    readonly tax: FieldRef<"Order", 'Float'>
    readonly sellingPrice: FieldRef<"Order", 'Float'>
    readonly profit: FieldRef<"Order", 'Float'>
    readonly bill: FieldRef<"Order", 'Float'>
    readonly invoiceDate: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.soldItems
   */
  export type Order$soldItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    where?: SoldItemsWhereInput
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    cursor?: SoldItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * Order.returnedItems
   */
  export type Order$returnedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    where?: ReturnedItemsWhereInput
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    cursor?: ReturnedItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      email: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model SoldItems
   */

  export type AggregateSoldItems = {
    _count: SoldItemsCountAggregateOutputType | null
    _avg: SoldItemsAvgAggregateOutputType | null
    _sum: SoldItemsSumAggregateOutputType | null
    _min: SoldItemsMinAggregateOutputType | null
    _max: SoldItemsMaxAggregateOutputType | null
  }

  export type SoldItemsAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
  }

  export type SoldItemsSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
  }

  export type SoldItemsMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    packing: string | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
    saleDate: Date | null
    updatedAt: Date | null
  }

  export type SoldItemsMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    packing: string | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
    saleDate: Date | null
    updatedAt: Date | null
  }

  export type SoldItemsCountAggregateOutputType = {
    id: number
    orderId: number
    medicineId: number
    batchId: number
    subUnitId: number
    packing: number
    quantity: number
    retailPrice: number
    discountPrice: number
    margin: number
    saleDate: number
    updatedAt: number
    _all: number
  }


  export type SoldItemsAvgAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
  }

  export type SoldItemsSumAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
  }

  export type SoldItemsMinAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    packing?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
    saleDate?: true
    updatedAt?: true
  }

  export type SoldItemsMaxAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    packing?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
    saleDate?: true
    updatedAt?: true
  }

  export type SoldItemsCountAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    packing?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
    saleDate?: true
    updatedAt?: true
    _all?: true
  }

  export type SoldItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoldItems to aggregate.
     */
    where?: SoldItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoldItems to fetch.
     */
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoldItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoldItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoldItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SoldItems
    **/
    _count?: true | SoldItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoldItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoldItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoldItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoldItemsMaxAggregateInputType
  }

  export type GetSoldItemsAggregateType<T extends SoldItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSoldItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoldItems[P]>
      : GetScalarType<T[P], AggregateSoldItems[P]>
  }




  export type SoldItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoldItemsWhereInput
    orderBy?: SoldItemsOrderByWithAggregationInput | SoldItemsOrderByWithAggregationInput[]
    by: SoldItemsScalarFieldEnum[] | SoldItemsScalarFieldEnum
    having?: SoldItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoldItemsCountAggregateInputType | true
    _avg?: SoldItemsAvgAggregateInputType
    _sum?: SoldItemsSumAggregateInputType
    _min?: SoldItemsMinAggregateInputType
    _max?: SoldItemsMaxAggregateInputType
  }

  export type SoldItemsGroupByOutputType = {
    id: number
    orderId: number
    medicineId: number
    batchId: number | null
    subUnitId: number | null
    packing: string | null
    quantity: number
    retailPrice: number
    discountPrice: number | null
    margin: number
    saleDate: Date
    updatedAt: Date
    _count: SoldItemsCountAggregateOutputType | null
    _avg: SoldItemsAvgAggregateOutputType | null
    _sum: SoldItemsSumAggregateOutputType | null
    _min: SoldItemsMinAggregateOutputType | null
    _max: SoldItemsMaxAggregateOutputType | null
  }

  type GetSoldItemsGroupByPayload<T extends SoldItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoldItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoldItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoldItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SoldItemsGroupByOutputType[P]>
        }
      >
    >


  export type SoldItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    saleDate?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | SoldItems$batchArgs<ExtArgs>
    subUnit?: boolean | SoldItems$subUnitArgs<ExtArgs>
  }, ExtArgs["result"]["soldItems"]>

  export type SoldItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    saleDate?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | SoldItems$batchArgs<ExtArgs>
    subUnit?: boolean | SoldItems$subUnitArgs<ExtArgs>
  }, ExtArgs["result"]["soldItems"]>

  export type SoldItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    saleDate?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | SoldItems$batchArgs<ExtArgs>
    subUnit?: boolean | SoldItems$subUnitArgs<ExtArgs>
  }, ExtArgs["result"]["soldItems"]>

  export type SoldItemsSelectScalar = {
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    saleDate?: boolean
    updatedAt?: boolean
  }

  export type SoldItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "medicineId" | "batchId" | "subUnitId" | "packing" | "quantity" | "retailPrice" | "discountPrice" | "margin" | "saleDate" | "updatedAt", ExtArgs["result"]["soldItems"]>
  export type SoldItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | SoldItems$batchArgs<ExtArgs>
    subUnit?: boolean | SoldItems$subUnitArgs<ExtArgs>
  }
  export type SoldItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | SoldItems$batchArgs<ExtArgs>
    subUnit?: boolean | SoldItems$subUnitArgs<ExtArgs>
  }
  export type SoldItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | SoldItems$batchArgs<ExtArgs>
    subUnit?: boolean | SoldItems$subUnitArgs<ExtArgs>
  }

  export type $SoldItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SoldItems"
    objects: {
      medicine: Prisma.$MedicinePayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      batch: Prisma.$BatchPayload<ExtArgs> | null
      subUnit: Prisma.$SubUnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      medicineId: number
      batchId: number | null
      subUnitId: number | null
      packing: string | null
      quantity: number
      retailPrice: number
      discountPrice: number | null
      margin: number
      saleDate: Date
      updatedAt: Date
    }, ExtArgs["result"]["soldItems"]>
    composites: {}
  }

  type SoldItemsGetPayload<S extends boolean | null | undefined | SoldItemsDefaultArgs> = $Result.GetResult<Prisma.$SoldItemsPayload, S>

  type SoldItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SoldItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SoldItemsCountAggregateInputType | true
    }

  export interface SoldItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SoldItems'], meta: { name: 'SoldItems' } }
    /**
     * Find zero or one SoldItems that matches the filter.
     * @param {SoldItemsFindUniqueArgs} args - Arguments to find a SoldItems
     * @example
     * // Get one SoldItems
     * const soldItems = await prisma.soldItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SoldItemsFindUniqueArgs>(args: SelectSubset<T, SoldItemsFindUniqueArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SoldItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SoldItemsFindUniqueOrThrowArgs} args - Arguments to find a SoldItems
     * @example
     * // Get one SoldItems
     * const soldItems = await prisma.soldItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SoldItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, SoldItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SoldItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsFindFirstArgs} args - Arguments to find a SoldItems
     * @example
     * // Get one SoldItems
     * const soldItems = await prisma.soldItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SoldItemsFindFirstArgs>(args?: SelectSubset<T, SoldItemsFindFirstArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SoldItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsFindFirstOrThrowArgs} args - Arguments to find a SoldItems
     * @example
     * // Get one SoldItems
     * const soldItems = await prisma.soldItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SoldItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, SoldItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SoldItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SoldItems
     * const soldItems = await prisma.soldItems.findMany()
     * 
     * // Get first 10 SoldItems
     * const soldItems = await prisma.soldItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soldItemsWithIdOnly = await prisma.soldItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SoldItemsFindManyArgs>(args?: SelectSubset<T, SoldItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SoldItems.
     * @param {SoldItemsCreateArgs} args - Arguments to create a SoldItems.
     * @example
     * // Create one SoldItems
     * const SoldItems = await prisma.soldItems.create({
     *   data: {
     *     // ... data to create a SoldItems
     *   }
     * })
     * 
     */
    create<T extends SoldItemsCreateArgs>(args: SelectSubset<T, SoldItemsCreateArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SoldItems.
     * @param {SoldItemsCreateManyArgs} args - Arguments to create many SoldItems.
     * @example
     * // Create many SoldItems
     * const soldItems = await prisma.soldItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SoldItemsCreateManyArgs>(args?: SelectSubset<T, SoldItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SoldItems and returns the data saved in the database.
     * @param {SoldItemsCreateManyAndReturnArgs} args - Arguments to create many SoldItems.
     * @example
     * // Create many SoldItems
     * const soldItems = await prisma.soldItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SoldItems and only return the `id`
     * const soldItemsWithIdOnly = await prisma.soldItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SoldItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, SoldItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SoldItems.
     * @param {SoldItemsDeleteArgs} args - Arguments to delete one SoldItems.
     * @example
     * // Delete one SoldItems
     * const SoldItems = await prisma.soldItems.delete({
     *   where: {
     *     // ... filter to delete one SoldItems
     *   }
     * })
     * 
     */
    delete<T extends SoldItemsDeleteArgs>(args: SelectSubset<T, SoldItemsDeleteArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SoldItems.
     * @param {SoldItemsUpdateArgs} args - Arguments to update one SoldItems.
     * @example
     * // Update one SoldItems
     * const soldItems = await prisma.soldItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SoldItemsUpdateArgs>(args: SelectSubset<T, SoldItemsUpdateArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SoldItems.
     * @param {SoldItemsDeleteManyArgs} args - Arguments to filter SoldItems to delete.
     * @example
     * // Delete a few SoldItems
     * const { count } = await prisma.soldItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SoldItemsDeleteManyArgs>(args?: SelectSubset<T, SoldItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoldItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SoldItems
     * const soldItems = await prisma.soldItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SoldItemsUpdateManyArgs>(args: SelectSubset<T, SoldItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoldItems and returns the data updated in the database.
     * @param {SoldItemsUpdateManyAndReturnArgs} args - Arguments to update many SoldItems.
     * @example
     * // Update many SoldItems
     * const soldItems = await prisma.soldItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SoldItems and only return the `id`
     * const soldItemsWithIdOnly = await prisma.soldItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SoldItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, SoldItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SoldItems.
     * @param {SoldItemsUpsertArgs} args - Arguments to update or create a SoldItems.
     * @example
     * // Update or create a SoldItems
     * const soldItems = await prisma.soldItems.upsert({
     *   create: {
     *     // ... data to create a SoldItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SoldItems we want to update
     *   }
     * })
     */
    upsert<T extends SoldItemsUpsertArgs>(args: SelectSubset<T, SoldItemsUpsertArgs<ExtArgs>>): Prisma__SoldItemsClient<$Result.GetResult<Prisma.$SoldItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SoldItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsCountArgs} args - Arguments to filter SoldItems to count.
     * @example
     * // Count the number of SoldItems
     * const count = await prisma.soldItems.count({
     *   where: {
     *     // ... the filter for the SoldItems we want to count
     *   }
     * })
    **/
    count<T extends SoldItemsCountArgs>(
      args?: Subset<T, SoldItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoldItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SoldItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoldItemsAggregateArgs>(args: Subset<T, SoldItemsAggregateArgs>): Prisma.PrismaPromise<GetSoldItemsAggregateType<T>>

    /**
     * Group by SoldItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoldItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoldItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoldItemsGroupByArgs['orderBy'] }
        : { orderBy?: SoldItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoldItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoldItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SoldItems model
   */
  readonly fields: SoldItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SoldItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoldItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends SoldItems$batchArgs<ExtArgs> = {}>(args?: Subset<T, SoldItems$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subUnit<T extends SoldItems$subUnitArgs<ExtArgs> = {}>(args?: Subset<T, SoldItems$subUnitArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SoldItems model
   */
  interface SoldItemsFieldRefs {
    readonly id: FieldRef<"SoldItems", 'Int'>
    readonly orderId: FieldRef<"SoldItems", 'Int'>
    readonly medicineId: FieldRef<"SoldItems", 'Int'>
    readonly batchId: FieldRef<"SoldItems", 'Int'>
    readonly subUnitId: FieldRef<"SoldItems", 'Int'>
    readonly packing: FieldRef<"SoldItems", 'String'>
    readonly quantity: FieldRef<"SoldItems", 'Int'>
    readonly retailPrice: FieldRef<"SoldItems", 'Float'>
    readonly discountPrice: FieldRef<"SoldItems", 'Float'>
    readonly margin: FieldRef<"SoldItems", 'Float'>
    readonly saleDate: FieldRef<"SoldItems", 'DateTime'>
    readonly updatedAt: FieldRef<"SoldItems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SoldItems findUnique
   */
  export type SoldItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * Filter, which SoldItems to fetch.
     */
    where: SoldItemsWhereUniqueInput
  }

  /**
   * SoldItems findUniqueOrThrow
   */
  export type SoldItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * Filter, which SoldItems to fetch.
     */
    where: SoldItemsWhereUniqueInput
  }

  /**
   * SoldItems findFirst
   */
  export type SoldItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * Filter, which SoldItems to fetch.
     */
    where?: SoldItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoldItems to fetch.
     */
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoldItems.
     */
    cursor?: SoldItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoldItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoldItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoldItems.
     */
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * SoldItems findFirstOrThrow
   */
  export type SoldItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * Filter, which SoldItems to fetch.
     */
    where?: SoldItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoldItems to fetch.
     */
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoldItems.
     */
    cursor?: SoldItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoldItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoldItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoldItems.
     */
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * SoldItems findMany
   */
  export type SoldItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * Filter, which SoldItems to fetch.
     */
    where?: SoldItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoldItems to fetch.
     */
    orderBy?: SoldItemsOrderByWithRelationInput | SoldItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SoldItems.
     */
    cursor?: SoldItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoldItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoldItems.
     */
    skip?: number
    distinct?: SoldItemsScalarFieldEnum | SoldItemsScalarFieldEnum[]
  }

  /**
   * SoldItems create
   */
  export type SoldItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a SoldItems.
     */
    data: XOR<SoldItemsCreateInput, SoldItemsUncheckedCreateInput>
  }

  /**
   * SoldItems createMany
   */
  export type SoldItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SoldItems.
     */
    data: SoldItemsCreateManyInput | SoldItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SoldItems createManyAndReturn
   */
  export type SoldItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * The data used to create many SoldItems.
     */
    data: SoldItemsCreateManyInput | SoldItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SoldItems update
   */
  export type SoldItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a SoldItems.
     */
    data: XOR<SoldItemsUpdateInput, SoldItemsUncheckedUpdateInput>
    /**
     * Choose, which SoldItems to update.
     */
    where: SoldItemsWhereUniqueInput
  }

  /**
   * SoldItems updateMany
   */
  export type SoldItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SoldItems.
     */
    data: XOR<SoldItemsUpdateManyMutationInput, SoldItemsUncheckedUpdateManyInput>
    /**
     * Filter which SoldItems to update
     */
    where?: SoldItemsWhereInput
    /**
     * Limit how many SoldItems to update.
     */
    limit?: number
  }

  /**
   * SoldItems updateManyAndReturn
   */
  export type SoldItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * The data used to update SoldItems.
     */
    data: XOR<SoldItemsUpdateManyMutationInput, SoldItemsUncheckedUpdateManyInput>
    /**
     * Filter which SoldItems to update
     */
    where?: SoldItemsWhereInput
    /**
     * Limit how many SoldItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SoldItems upsert
   */
  export type SoldItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the SoldItems to update in case it exists.
     */
    where: SoldItemsWhereUniqueInput
    /**
     * In case the SoldItems found by the `where` argument doesn't exist, create a new SoldItems with this data.
     */
    create: XOR<SoldItemsCreateInput, SoldItemsUncheckedCreateInput>
    /**
     * In case the SoldItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoldItemsUpdateInput, SoldItemsUncheckedUpdateInput>
  }

  /**
   * SoldItems delete
   */
  export type SoldItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
    /**
     * Filter which SoldItems to delete.
     */
    where: SoldItemsWhereUniqueInput
  }

  /**
   * SoldItems deleteMany
   */
  export type SoldItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoldItems to delete
     */
    where?: SoldItemsWhereInput
    /**
     * Limit how many SoldItems to delete.
     */
    limit?: number
  }

  /**
   * SoldItems.batch
   */
  export type SoldItems$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * SoldItems.subUnit
   */
  export type SoldItems$subUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    where?: SubUnitWhereInput
  }

  /**
   * SoldItems without action
   */
  export type SoldItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoldItems
     */
    select?: SoldItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoldItems
     */
    omit?: SoldItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoldItemsInclude<ExtArgs> | null
  }


  /**
   * Model ReturnedItems
   */

  export type AggregateReturnedItems = {
    _count: ReturnedItemsCountAggregateOutputType | null
    _avg: ReturnedItemsAvgAggregateOutputType | null
    _sum: ReturnedItemsSumAggregateOutputType | null
    _min: ReturnedItemsMinAggregateOutputType | null
    _max: ReturnedItemsMaxAggregateOutputType | null
  }

  export type ReturnedItemsAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
  }

  export type ReturnedItemsSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
  }

  export type ReturnedItemsMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    packing: string | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
    returnType: $Enums.ReturnType | null
    returnedDate: Date | null
    updatedAt: Date | null
  }

  export type ReturnedItemsMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    batchId: number | null
    subUnitId: number | null
    packing: string | null
    quantity: number | null
    retailPrice: number | null
    discountPrice: number | null
    margin: number | null
    returnType: $Enums.ReturnType | null
    returnedDate: Date | null
    updatedAt: Date | null
  }

  export type ReturnedItemsCountAggregateOutputType = {
    id: number
    orderId: number
    medicineId: number
    batchId: number
    subUnitId: number
    packing: number
    quantity: number
    retailPrice: number
    discountPrice: number
    margin: number
    returnType: number
    returnedDate: number
    updatedAt: number
    _all: number
  }


  export type ReturnedItemsAvgAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
  }

  export type ReturnedItemsSumAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
  }

  export type ReturnedItemsMinAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    packing?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
    returnType?: true
    returnedDate?: true
    updatedAt?: true
  }

  export type ReturnedItemsMaxAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    packing?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
    returnType?: true
    returnedDate?: true
    updatedAt?: true
  }

  export type ReturnedItemsCountAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    batchId?: true
    subUnitId?: true
    packing?: true
    quantity?: true
    retailPrice?: true
    discountPrice?: true
    margin?: true
    returnType?: true
    returnedDate?: true
    updatedAt?: true
    _all?: true
  }

  export type ReturnedItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnedItems to aggregate.
     */
    where?: ReturnedItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedItems to fetch.
     */
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnedItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnedItems
    **/
    _count?: true | ReturnedItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnedItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnedItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnedItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnedItemsMaxAggregateInputType
  }

  export type GetReturnedItemsAggregateType<T extends ReturnedItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnedItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnedItems[P]>
      : GetScalarType<T[P], AggregateReturnedItems[P]>
  }




  export type ReturnedItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnedItemsWhereInput
    orderBy?: ReturnedItemsOrderByWithAggregationInput | ReturnedItemsOrderByWithAggregationInput[]
    by: ReturnedItemsScalarFieldEnum[] | ReturnedItemsScalarFieldEnum
    having?: ReturnedItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnedItemsCountAggregateInputType | true
    _avg?: ReturnedItemsAvgAggregateInputType
    _sum?: ReturnedItemsSumAggregateInputType
    _min?: ReturnedItemsMinAggregateInputType
    _max?: ReturnedItemsMaxAggregateInputType
  }

  export type ReturnedItemsGroupByOutputType = {
    id: number
    orderId: number
    medicineId: number
    batchId: number | null
    subUnitId: number | null
    packing: string | null
    quantity: number
    retailPrice: number
    discountPrice: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate: Date
    updatedAt: Date
    _count: ReturnedItemsCountAggregateOutputType | null
    _avg: ReturnedItemsAvgAggregateOutputType | null
    _sum: ReturnedItemsSumAggregateOutputType | null
    _min: ReturnedItemsMinAggregateOutputType | null
    _max: ReturnedItemsMaxAggregateOutputType | null
  }

  type GetReturnedItemsGroupByPayload<T extends ReturnedItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnedItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnedItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnedItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnedItemsGroupByOutputType[P]>
        }
      >
    >


  export type ReturnedItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    returnType?: boolean
    returnedDate?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | ReturnedItems$batchArgs<ExtArgs>
    subUnit?: boolean | ReturnedItems$subUnitArgs<ExtArgs>
  }, ExtArgs["result"]["returnedItems"]>

  export type ReturnedItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    returnType?: boolean
    returnedDate?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | ReturnedItems$batchArgs<ExtArgs>
    subUnit?: boolean | ReturnedItems$subUnitArgs<ExtArgs>
  }, ExtArgs["result"]["returnedItems"]>

  export type ReturnedItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    returnType?: boolean
    returnedDate?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | ReturnedItems$batchArgs<ExtArgs>
    subUnit?: boolean | ReturnedItems$subUnitArgs<ExtArgs>
  }, ExtArgs["result"]["returnedItems"]>

  export type ReturnedItemsSelectScalar = {
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    batchId?: boolean
    subUnitId?: boolean
    packing?: boolean
    quantity?: boolean
    retailPrice?: boolean
    discountPrice?: boolean
    margin?: boolean
    returnType?: boolean
    returnedDate?: boolean
    updatedAt?: boolean
  }

  export type ReturnedItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "medicineId" | "batchId" | "subUnitId" | "packing" | "quantity" | "retailPrice" | "discountPrice" | "margin" | "returnType" | "returnedDate" | "updatedAt", ExtArgs["result"]["returnedItems"]>
  export type ReturnedItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | ReturnedItems$batchArgs<ExtArgs>
    subUnit?: boolean | ReturnedItems$subUnitArgs<ExtArgs>
  }
  export type ReturnedItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | ReturnedItems$batchArgs<ExtArgs>
    subUnit?: boolean | ReturnedItems$subUnitArgs<ExtArgs>
  }
  export type ReturnedItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    batch?: boolean | ReturnedItems$batchArgs<ExtArgs>
    subUnit?: boolean | ReturnedItems$subUnitArgs<ExtArgs>
  }

  export type $ReturnedItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnedItems"
    objects: {
      medicine: Prisma.$MedicinePayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      batch: Prisma.$BatchPayload<ExtArgs> | null
      subUnit: Prisma.$SubUnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      medicineId: number
      batchId: number | null
      subUnitId: number | null
      packing: string | null
      quantity: number
      retailPrice: number
      discountPrice: number | null
      margin: number
      returnType: $Enums.ReturnType
      returnedDate: Date
      updatedAt: Date
    }, ExtArgs["result"]["returnedItems"]>
    composites: {}
  }

  type ReturnedItemsGetPayload<S extends boolean | null | undefined | ReturnedItemsDefaultArgs> = $Result.GetResult<Prisma.$ReturnedItemsPayload, S>

  type ReturnedItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnedItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnedItemsCountAggregateInputType | true
    }

  export interface ReturnedItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnedItems'], meta: { name: 'ReturnedItems' } }
    /**
     * Find zero or one ReturnedItems that matches the filter.
     * @param {ReturnedItemsFindUniqueArgs} args - Arguments to find a ReturnedItems
     * @example
     * // Get one ReturnedItems
     * const returnedItems = await prisma.returnedItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnedItemsFindUniqueArgs>(args: SelectSubset<T, ReturnedItemsFindUniqueArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnedItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnedItemsFindUniqueOrThrowArgs} args - Arguments to find a ReturnedItems
     * @example
     * // Get one ReturnedItems
     * const returnedItems = await prisma.returnedItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnedItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnedItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsFindFirstArgs} args - Arguments to find a ReturnedItems
     * @example
     * // Get one ReturnedItems
     * const returnedItems = await prisma.returnedItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnedItemsFindFirstArgs>(args?: SelectSubset<T, ReturnedItemsFindFirstArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnedItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsFindFirstOrThrowArgs} args - Arguments to find a ReturnedItems
     * @example
     * // Get one ReturnedItems
     * const returnedItems = await prisma.returnedItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnedItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnedItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnedItems
     * const returnedItems = await prisma.returnedItems.findMany()
     * 
     * // Get first 10 ReturnedItems
     * const returnedItems = await prisma.returnedItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnedItemsWithIdOnly = await prisma.returnedItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnedItemsFindManyArgs>(args?: SelectSubset<T, ReturnedItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnedItems.
     * @param {ReturnedItemsCreateArgs} args - Arguments to create a ReturnedItems.
     * @example
     * // Create one ReturnedItems
     * const ReturnedItems = await prisma.returnedItems.create({
     *   data: {
     *     // ... data to create a ReturnedItems
     *   }
     * })
     * 
     */
    create<T extends ReturnedItemsCreateArgs>(args: SelectSubset<T, ReturnedItemsCreateArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnedItems.
     * @param {ReturnedItemsCreateManyArgs} args - Arguments to create many ReturnedItems.
     * @example
     * // Create many ReturnedItems
     * const returnedItems = await prisma.returnedItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnedItemsCreateManyArgs>(args?: SelectSubset<T, ReturnedItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReturnedItems and returns the data saved in the database.
     * @param {ReturnedItemsCreateManyAndReturnArgs} args - Arguments to create many ReturnedItems.
     * @example
     * // Create many ReturnedItems
     * const returnedItems = await prisma.returnedItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReturnedItems and only return the `id`
     * const returnedItemsWithIdOnly = await prisma.returnedItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnedItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnedItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReturnedItems.
     * @param {ReturnedItemsDeleteArgs} args - Arguments to delete one ReturnedItems.
     * @example
     * // Delete one ReturnedItems
     * const ReturnedItems = await prisma.returnedItems.delete({
     *   where: {
     *     // ... filter to delete one ReturnedItems
     *   }
     * })
     * 
     */
    delete<T extends ReturnedItemsDeleteArgs>(args: SelectSubset<T, ReturnedItemsDeleteArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnedItems.
     * @param {ReturnedItemsUpdateArgs} args - Arguments to update one ReturnedItems.
     * @example
     * // Update one ReturnedItems
     * const returnedItems = await prisma.returnedItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnedItemsUpdateArgs>(args: SelectSubset<T, ReturnedItemsUpdateArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnedItems.
     * @param {ReturnedItemsDeleteManyArgs} args - Arguments to filter ReturnedItems to delete.
     * @example
     * // Delete a few ReturnedItems
     * const { count } = await prisma.returnedItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnedItemsDeleteManyArgs>(args?: SelectSubset<T, ReturnedItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnedItems
     * const returnedItems = await prisma.returnedItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnedItemsUpdateManyArgs>(args: SelectSubset<T, ReturnedItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnedItems and returns the data updated in the database.
     * @param {ReturnedItemsUpdateManyAndReturnArgs} args - Arguments to update many ReturnedItems.
     * @example
     * // Update many ReturnedItems
     * const returnedItems = await prisma.returnedItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReturnedItems and only return the `id`
     * const returnedItemsWithIdOnly = await prisma.returnedItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReturnedItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, ReturnedItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReturnedItems.
     * @param {ReturnedItemsUpsertArgs} args - Arguments to update or create a ReturnedItems.
     * @example
     * // Update or create a ReturnedItems
     * const returnedItems = await prisma.returnedItems.upsert({
     *   create: {
     *     // ... data to create a ReturnedItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnedItems we want to update
     *   }
     * })
     */
    upsert<T extends ReturnedItemsUpsertArgs>(args: SelectSubset<T, ReturnedItemsUpsertArgs<ExtArgs>>): Prisma__ReturnedItemsClient<$Result.GetResult<Prisma.$ReturnedItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsCountArgs} args - Arguments to filter ReturnedItems to count.
     * @example
     * // Count the number of ReturnedItems
     * const count = await prisma.returnedItems.count({
     *   where: {
     *     // ... the filter for the ReturnedItems we want to count
     *   }
     * })
    **/
    count<T extends ReturnedItemsCountArgs>(
      args?: Subset<T, ReturnedItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnedItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnedItemsAggregateArgs>(args: Subset<T, ReturnedItemsAggregateArgs>): Prisma.PrismaPromise<GetReturnedItemsAggregateType<T>>

    /**
     * Group by ReturnedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnedItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnedItemsGroupByArgs['orderBy'] }
        : { orderBy?: ReturnedItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnedItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnedItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnedItems model
   */
  readonly fields: ReturnedItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnedItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnedItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ReturnedItems$batchArgs<ExtArgs> = {}>(args?: Subset<T, ReturnedItems$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subUnit<T extends ReturnedItems$subUnitArgs<ExtArgs> = {}>(args?: Subset<T, ReturnedItems$subUnitArgs<ExtArgs>>): Prisma__SubUnitClient<$Result.GetResult<Prisma.$SubUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnedItems model
   */
  interface ReturnedItemsFieldRefs {
    readonly id: FieldRef<"ReturnedItems", 'Int'>
    readonly orderId: FieldRef<"ReturnedItems", 'Int'>
    readonly medicineId: FieldRef<"ReturnedItems", 'Int'>
    readonly batchId: FieldRef<"ReturnedItems", 'Int'>
    readonly subUnitId: FieldRef<"ReturnedItems", 'Int'>
    readonly packing: FieldRef<"ReturnedItems", 'String'>
    readonly quantity: FieldRef<"ReturnedItems", 'Int'>
    readonly retailPrice: FieldRef<"ReturnedItems", 'Float'>
    readonly discountPrice: FieldRef<"ReturnedItems", 'Float'>
    readonly margin: FieldRef<"ReturnedItems", 'Float'>
    readonly returnType: FieldRef<"ReturnedItems", 'ReturnType'>
    readonly returnedDate: FieldRef<"ReturnedItems", 'DateTime'>
    readonly updatedAt: FieldRef<"ReturnedItems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnedItems findUnique
   */
  export type ReturnedItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedItems to fetch.
     */
    where: ReturnedItemsWhereUniqueInput
  }

  /**
   * ReturnedItems findUniqueOrThrow
   */
  export type ReturnedItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedItems to fetch.
     */
    where: ReturnedItemsWhereUniqueInput
  }

  /**
   * ReturnedItems findFirst
   */
  export type ReturnedItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedItems to fetch.
     */
    where?: ReturnedItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedItems to fetch.
     */
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnedItems.
     */
    cursor?: ReturnedItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnedItems.
     */
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * ReturnedItems findFirstOrThrow
   */
  export type ReturnedItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedItems to fetch.
     */
    where?: ReturnedItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedItems to fetch.
     */
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnedItems.
     */
    cursor?: ReturnedItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnedItems.
     */
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * ReturnedItems findMany
   */
  export type ReturnedItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedItems to fetch.
     */
    where?: ReturnedItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedItems to fetch.
     */
    orderBy?: ReturnedItemsOrderByWithRelationInput | ReturnedItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnedItems.
     */
    cursor?: ReturnedItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedItems.
     */
    skip?: number
    distinct?: ReturnedItemsScalarFieldEnum | ReturnedItemsScalarFieldEnum[]
  }

  /**
   * ReturnedItems create
   */
  export type ReturnedItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnedItems.
     */
    data: XOR<ReturnedItemsCreateInput, ReturnedItemsUncheckedCreateInput>
  }

  /**
   * ReturnedItems createMany
   */
  export type ReturnedItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnedItems.
     */
    data: ReturnedItemsCreateManyInput | ReturnedItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReturnedItems createManyAndReturn
   */
  export type ReturnedItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * The data used to create many ReturnedItems.
     */
    data: ReturnedItemsCreateManyInput | ReturnedItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnedItems update
   */
  export type ReturnedItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnedItems.
     */
    data: XOR<ReturnedItemsUpdateInput, ReturnedItemsUncheckedUpdateInput>
    /**
     * Choose, which ReturnedItems to update.
     */
    where: ReturnedItemsWhereUniqueInput
  }

  /**
   * ReturnedItems updateMany
   */
  export type ReturnedItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnedItems.
     */
    data: XOR<ReturnedItemsUpdateManyMutationInput, ReturnedItemsUncheckedUpdateManyInput>
    /**
     * Filter which ReturnedItems to update
     */
    where?: ReturnedItemsWhereInput
    /**
     * Limit how many ReturnedItems to update.
     */
    limit?: number
  }

  /**
   * ReturnedItems updateManyAndReturn
   */
  export type ReturnedItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * The data used to update ReturnedItems.
     */
    data: XOR<ReturnedItemsUpdateManyMutationInput, ReturnedItemsUncheckedUpdateManyInput>
    /**
     * Filter which ReturnedItems to update
     */
    where?: ReturnedItemsWhereInput
    /**
     * Limit how many ReturnedItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnedItems upsert
   */
  export type ReturnedItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnedItems to update in case it exists.
     */
    where: ReturnedItemsWhereUniqueInput
    /**
     * In case the ReturnedItems found by the `where` argument doesn't exist, create a new ReturnedItems with this data.
     */
    create: XOR<ReturnedItemsCreateInput, ReturnedItemsUncheckedCreateInput>
    /**
     * In case the ReturnedItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnedItemsUpdateInput, ReturnedItemsUncheckedUpdateInput>
  }

  /**
   * ReturnedItems delete
   */
  export type ReturnedItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
    /**
     * Filter which ReturnedItems to delete.
     */
    where: ReturnedItemsWhereUniqueInput
  }

  /**
   * ReturnedItems deleteMany
   */
  export type ReturnedItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnedItems to delete
     */
    where?: ReturnedItemsWhereInput
    /**
     * Limit how many ReturnedItems to delete.
     */
    limit?: number
  }

  /**
   * ReturnedItems.batch
   */
  export type ReturnedItems$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * ReturnedItems.subUnit
   */
  export type ReturnedItems$subUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubUnit
     */
    select?: SubUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubUnit
     */
    omit?: SubUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubUnitInclude<ExtArgs> | null
    where?: SubUnitWhereInput
  }

  /**
   * ReturnedItems without action
   */
  export type ReturnedItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedItems
     */
    select?: ReturnedItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnedItems
     */
    omit?: ReturnedItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnedItemsInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entity: string | null
    entityId: number | null
    description: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entity: string | null
    entityId: number | null
    description: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    description: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    description?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    description?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number
    action: string
    entity: string
    entityId: number
    description: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "description" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      entity: string
      entityId: number
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    phoneNumber: 'phoneNumber',
    email: 'email',
    employeeId: 'employeeId',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    parentId: 'parentId',
    medicalStoreId: 'medicalStoreId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MedicalStoreScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    name: 'name',
    address: 'address',
    licenseNumber: 'licenseNumber',
    phoneNumber: 'phoneNumber',
    ntnNumber: 'ntnNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalStoreScalarFieldEnum = (typeof MedicalStoreScalarFieldEnum)[keyof typeof MedicalStoreScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    companyCode: 'companyCode',
    name: 'name',
    address: 'address',
    phone: 'phone',
    mobile: 'mobile',
    distributorCode: 'distributorCode',
    ntnNumber: 'ntnNumber',
    registrationDate: 'registrationDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    medicalStoreId: 'medicalStoreId'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    supplierCode: 'supplierCode',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    distributorCode: 'distributorCode',
    ntnNumber: 'ntnNumber',
    isActive: 'isActive',
    companyId: 'companyId',
    medicalStoreId: 'medicalStoreId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const MedicineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    formula: 'formula',
    description: 'description',
    minquantity: 'minquantity',
    companyId: 'companyId',
    supplierId: 'supplierId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineScalarFieldEnum = (typeof MedicineScalarFieldEnum)[keyof typeof MedicineScalarFieldEnum]


  export const VariationScalarFieldEnum: {
    id: 'id',
    medicineId: 'medicineId',
    potency: 'potency',
    packaging: 'packaging',
    unitType: 'unitType',
    unitsPerPack: 'unitsPerPack',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariationScalarFieldEnum = (typeof VariationScalarFieldEnum)[keyof typeof VariationScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    batchNo: 'batchNo',
    mfgDate: 'mfgDate',
    expiryDate: 'expiryDate',
    quantity: 'quantity',
    price: 'price',
    variationId: 'variationId',
    purchaseOrderId: 'purchaseOrderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const MedicineInstanceScalarFieldEnum: {
    id: 'id',
    variationId: 'variationId',
    batchId: 'batchId',
    expiryDate: 'expiryDate',
    quantity: 'quantity',
    purchasePrice: 'purchasePrice',
    sellingPrice: 'sellingPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineInstanceScalarFieldEnum = (typeof MedicineInstanceScalarFieldEnum)[keyof typeof MedicineInstanceScalarFieldEnum]


  export const SubUnitScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    name: 'name',
    description: 'description',
    unitType: 'unitType',
    subUnitCount: 'subUnitCount',
    subUnitPrice: 'subUnitPrice',
    isSold: 'isSold',
    isReturnedByCustomer: 'isReturnedByCustomer',
    isReturnedToSupplier: 'isReturnedToSupplier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubUnitScalarFieldEnum = (typeof SubUnitScalarFieldEnum)[keyof typeof SubUnitScalarFieldEnum]


  export const MedicineLocationScalarFieldEnum: {
    id: 'id',
    medicalStoreId: 'medicalStoreId',
    medicineId: 'medicineId',
    medicineInstanceId: 'medicineInstanceId',
    location: 'location',
    rank: 'rank',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineLocationScalarFieldEnum = (typeof MedicineLocationScalarFieldEnum)[keyof typeof MedicineLocationScalarFieldEnum]


  export const MedicalStoreMedicineScalarFieldEnum: {
    id: 'id',
    medicalStoreId: 'medicalStoreId',
    medicineId: 'medicineId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalStoreMedicineScalarFieldEnum = (typeof MedicalStoreMedicineScalarFieldEnum)[keyof typeof MedicalStoreMedicineScalarFieldEnum]


  export const MedicineExpiryScalarFieldEnum: {
    id: 'id',
    medicineId: 'medicineId',
    expiryDate: 'expiryDate',
    isNearExpiry: 'isNearExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineExpiryScalarFieldEnum = (typeof MedicineExpiryScalarFieldEnum)[keyof typeof MedicineExpiryScalarFieldEnum]


  export const StockTransactionScalarFieldEnum: {
    id: 'id',
    medicalStoreId: 'medicalStoreId',
    medicineInstanceId: 'medicineInstanceId',
    purchaseOrderId: 'purchaseOrderId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockTransactionScalarFieldEnum = (typeof StockTransactionScalarFieldEnum)[keyof typeof StockTransactionScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    medicalStoreId: 'medicalStoreId',
    supplierId: 'supplierId',
    userId: 'userId',
    orderDate: 'orderDate',
    status: 'status',
    totalCost: 'totalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    customerId: 'customerId',
    customerName: 'customerName',
    customerLocation: 'customerLocation',
    customerContact: 'customerContact',
    paymentMethod: 'paymentMethod',
    changeCash: 'changeCash',
    discount: 'discount',
    discountType: 'discountType',
    itemsCost: 'itemsCost',
    tax: 'tax',
    sellingPrice: 'sellingPrice',
    profit: 'profit',
    bill: 'bill',
    invoiceDate: 'invoiceDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SoldItemsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    medicineId: 'medicineId',
    batchId: 'batchId',
    subUnitId: 'subUnitId',
    packing: 'packing',
    quantity: 'quantity',
    retailPrice: 'retailPrice',
    discountPrice: 'discountPrice',
    margin: 'margin',
    saleDate: 'saleDate',
    updatedAt: 'updatedAt'
  };

  export type SoldItemsScalarFieldEnum = (typeof SoldItemsScalarFieldEnum)[keyof typeof SoldItemsScalarFieldEnum]


  export const ReturnedItemsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    medicineId: 'medicineId',
    batchId: 'batchId',
    subUnitId: 'subUnitId',
    packing: 'packing',
    quantity: 'quantity',
    retailPrice: 'retailPrice',
    discountPrice: 'discountPrice',
    margin: 'margin',
    returnType: 'returnType',
    returnedDate: 'returnedDate',
    updatedAt: 'updatedAt'
  };

  export type ReturnedItemsScalarFieldEnum = (typeof ReturnedItemsScalarFieldEnum)[keyof typeof ReturnedItemsScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'ReturnType'
   */
  export type EnumReturnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnType'>
    


  /**
   * Reference to a field of type 'ReturnType[]'
   */
  export type ListEnumReturnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    city?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    employeeId?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    parentId?: IntNullableFilter<"User"> | number | null
    medicalStoreId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    parent?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    children?: UserListRelationFilter
    medicalStore?: XOR<MedicalStoreNullableScalarRelationFilter, MedicalStoreWhereInput> | null
    orders?: OrderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    employeeId?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrderInput | SortOrder
    medicalStoreId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: UserOrderByWithRelationInput
    children?: UserOrderByRelationAggregateInput
    medicalStore?: MedicalStoreOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    employeeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    city?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    parentId?: IntNullableFilter<"User"> | number | null
    medicalStoreId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    parent?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    children?: UserListRelationFilter
    medicalStore?: XOR<MedicalStoreNullableScalarRelationFilter, MedicalStoreWhereInput> | null
    orders?: OrderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id" | "email" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    employeeId?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrderInput | SortOrder
    medicalStoreId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    address?: StringWithAggregatesFilter<"User"> | string
    city?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    employeeId?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    parentId?: IntNullableWithAggregatesFilter<"User"> | number | null
    medicalStoreId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MedicalStoreWhereInput = {
    AND?: MedicalStoreWhereInput | MedicalStoreWhereInput[]
    OR?: MedicalStoreWhereInput[]
    NOT?: MedicalStoreWhereInput | MedicalStoreWhereInput[]
    id?: IntFilter<"MedicalStore"> | number
    ownerId?: IntFilter<"MedicalStore"> | number
    name?: StringFilter<"MedicalStore"> | string
    address?: StringFilter<"MedicalStore"> | string
    licenseNumber?: StringFilter<"MedicalStore"> | string
    phoneNumber?: StringFilter<"MedicalStore"> | string
    ntnNumber?: StringFilter<"MedicalStore"> | string
    createdAt?: DateTimeFilter<"MedicalStore"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStore"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    medicines?: MedicalStoreMedicineListRelationFilter
    locations?: MedicineLocationListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
    companies?: CompanyListRelationFilter
    suppliers?: SupplierListRelationFilter
  }

  export type MedicalStoreOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    licenseNumber?: SortOrder
    phoneNumber?: SortOrder
    ntnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    medicines?: MedicalStoreMedicineOrderByRelationAggregateInput
    locations?: MedicineLocationOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
    companies?: CompanyOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
  }

  export type MedicalStoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ownerId?: number
    AND?: MedicalStoreWhereInput | MedicalStoreWhereInput[]
    OR?: MedicalStoreWhereInput[]
    NOT?: MedicalStoreWhereInput | MedicalStoreWhereInput[]
    name?: StringFilter<"MedicalStore"> | string
    address?: StringFilter<"MedicalStore"> | string
    licenseNumber?: StringFilter<"MedicalStore"> | string
    phoneNumber?: StringFilter<"MedicalStore"> | string
    ntnNumber?: StringFilter<"MedicalStore"> | string
    createdAt?: DateTimeFilter<"MedicalStore"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStore"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    medicines?: MedicalStoreMedicineListRelationFilter
    locations?: MedicineLocationListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
    companies?: CompanyListRelationFilter
    suppliers?: SupplierListRelationFilter
  }, "id" | "ownerId">

  export type MedicalStoreOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    licenseNumber?: SortOrder
    phoneNumber?: SortOrder
    ntnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalStoreCountOrderByAggregateInput
    _avg?: MedicalStoreAvgOrderByAggregateInput
    _max?: MedicalStoreMaxOrderByAggregateInput
    _min?: MedicalStoreMinOrderByAggregateInput
    _sum?: MedicalStoreSumOrderByAggregateInput
  }

  export type MedicalStoreScalarWhereWithAggregatesInput = {
    AND?: MedicalStoreScalarWhereWithAggregatesInput | MedicalStoreScalarWhereWithAggregatesInput[]
    OR?: MedicalStoreScalarWhereWithAggregatesInput[]
    NOT?: MedicalStoreScalarWhereWithAggregatesInput | MedicalStoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicalStore"> | number
    ownerId?: IntWithAggregatesFilter<"MedicalStore"> | number
    name?: StringWithAggregatesFilter<"MedicalStore"> | string
    address?: StringWithAggregatesFilter<"MedicalStore"> | string
    licenseNumber?: StringWithAggregatesFilter<"MedicalStore"> | string
    phoneNumber?: StringWithAggregatesFilter<"MedicalStore"> | string
    ntnNumber?: StringWithAggregatesFilter<"MedicalStore"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalStore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalStore"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    companyCode?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    mobile?: StringNullableFilter<"Company"> | string | null
    distributorCode?: StringNullableFilter<"Company"> | string | null
    ntnNumber?: StringNullableFilter<"Company"> | string | null
    registrationDate?: DateTimeFilter<"Company"> | Date | string
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    medicalStoreId?: IntFilter<"Company"> | number
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    suppliers?: SupplierListRelationFilter
    medicines?: MedicineListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    companyCode?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    distributorCode?: SortOrderInput | SortOrder
    ntnNumber?: SortOrderInput | SortOrder
    registrationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStoreId?: SortOrder
    medicalStore?: MedicalStoreOrderByWithRelationInput
    suppliers?: SupplierOrderByRelationAggregateInput
    medicines?: MedicineOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyCode_medicalStoreId?: CompanyCompanyCodeMedicalStoreIdCompoundUniqueInput
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    companyCode?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    mobile?: StringNullableFilter<"Company"> | string | null
    distributorCode?: StringNullableFilter<"Company"> | string | null
    ntnNumber?: StringNullableFilter<"Company"> | string | null
    registrationDate?: DateTimeFilter<"Company"> | Date | string
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    medicalStoreId?: IntFilter<"Company"> | number
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    suppliers?: SupplierListRelationFilter
    medicines?: MedicineListRelationFilter
  }, "id" | "companyCode_medicalStoreId">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    companyCode?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    distributorCode?: SortOrderInput | SortOrder
    ntnNumber?: SortOrderInput | SortOrder
    registrationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStoreId?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    companyCode?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Company"> | string | null
    distributorCode?: StringNullableWithAggregatesFilter<"Company"> | string | null
    ntnNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    registrationDate?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    medicalStoreId?: IntWithAggregatesFilter<"Company"> | number
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    supplierCode?: StringNullableFilter<"Supplier"> | string | null
    name?: StringFilter<"Supplier"> | string
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringFilter<"Supplier"> | string
    distributorCode?: StringFilter<"Supplier"> | string
    ntnNumber?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    companyId?: IntFilter<"Supplier"> | number
    medicalStoreId?: IntFilter<"Supplier"> | number
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    medicines?: MedicineListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    supplierCode?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStore?: MedicalStoreOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    medicines?: MedicineOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supplierCode?: string
    supplierCode_medicalStoreId?: SupplierSupplierCodeMedicalStoreIdCompoundUniqueInput
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringFilter<"Supplier"> | string
    distributorCode?: StringFilter<"Supplier"> | string
    ntnNumber?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    companyId?: IntFilter<"Supplier"> | number
    medicalStoreId?: IntFilter<"Supplier"> | number
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    medicines?: MedicineListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id" | "supplierCode" | "supplierCode_medicalStoreId">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    supplierCode?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    supplierCode?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    name?: StringWithAggregatesFilter<"Supplier"> | string
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringWithAggregatesFilter<"Supplier"> | string
    distributorCode?: StringWithAggregatesFilter<"Supplier"> | string
    ntnNumber?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    companyId?: IntWithAggregatesFilter<"Supplier"> | number
    medicalStoreId?: IntWithAggregatesFilter<"Supplier"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type MedicineWhereInput = {
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    id?: IntFilter<"Medicine"> | number
    name?: StringFilter<"Medicine"> | string
    formula?: StringNullableFilter<"Medicine"> | string | null
    description?: StringNullableFilter<"Medicine"> | string | null
    minquantity?: IntFilter<"Medicine"> | number
    companyId?: IntFilter<"Medicine"> | number
    supplierId?: IntFilter<"Medicine"> | number
    isActive?: BoolFilter<"Medicine"> | boolean
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeFilter<"Medicine"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    variations?: VariationListRelationFilter
    locations?: MedicineLocationListRelationFilter
    medicalStoreMedicines?: MedicalStoreMedicineListRelationFilter
    expiryRecords?: MedicineExpiryListRelationFilter
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }

  export type MedicineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    formula?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    variations?: VariationOrderByRelationAggregateInput
    locations?: MedicineLocationOrderByRelationAggregateInput
    medicalStoreMedicines?: MedicalStoreMedicineOrderByRelationAggregateInput
    expiryRecords?: MedicineExpiryOrderByRelationAggregateInput
    soldItems?: SoldItemsOrderByRelationAggregateInput
    returnedItems?: ReturnedItemsOrderByRelationAggregateInput
  }

  export type MedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    name?: StringFilter<"Medicine"> | string
    formula?: StringNullableFilter<"Medicine"> | string | null
    description?: StringNullableFilter<"Medicine"> | string | null
    minquantity?: IntFilter<"Medicine"> | number
    companyId?: IntFilter<"Medicine"> | number
    supplierId?: IntFilter<"Medicine"> | number
    isActive?: BoolFilter<"Medicine"> | boolean
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeFilter<"Medicine"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    variations?: VariationListRelationFilter
    locations?: MedicineLocationListRelationFilter
    medicalStoreMedicines?: MedicalStoreMedicineListRelationFilter
    expiryRecords?: MedicineExpiryListRelationFilter
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }, "id">

  export type MedicineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    formula?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineCountOrderByAggregateInput
    _avg?: MedicineAvgOrderByAggregateInput
    _max?: MedicineMaxOrderByAggregateInput
    _min?: MedicineMinOrderByAggregateInput
    _sum?: MedicineSumOrderByAggregateInput
  }

  export type MedicineScalarWhereWithAggregatesInput = {
    AND?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    OR?: MedicineScalarWhereWithAggregatesInput[]
    NOT?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Medicine"> | number
    name?: StringWithAggregatesFilter<"Medicine"> | string
    formula?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    description?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    minquantity?: IntWithAggregatesFilter<"Medicine"> | number
    companyId?: IntWithAggregatesFilter<"Medicine"> | number
    supplierId?: IntWithAggregatesFilter<"Medicine"> | number
    isActive?: BoolWithAggregatesFilter<"Medicine"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medicine"> | Date | string
  }

  export type VariationWhereInput = {
    AND?: VariationWhereInput | VariationWhereInput[]
    OR?: VariationWhereInput[]
    NOT?: VariationWhereInput | VariationWhereInput[]
    id?: IntFilter<"Variation"> | number
    medicineId?: IntFilter<"Variation"> | number
    potency?: StringFilter<"Variation"> | string
    packaging?: StringFilter<"Variation"> | string
    unitType?: StringFilter<"Variation"> | string
    unitsPerPack?: IntFilter<"Variation"> | number
    createdAt?: DateTimeFilter<"Variation"> | Date | string
    updatedAt?: DateTimeFilter<"Variation"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    batches?: BatchListRelationFilter
    instances?: MedicineInstanceListRelationFilter
  }

  export type VariationOrderByWithRelationInput = {
    id?: SortOrder
    medicineId?: SortOrder
    potency?: SortOrder
    packaging?: SortOrder
    unitType?: SortOrder
    unitsPerPack?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicine?: MedicineOrderByWithRelationInput
    batches?: BatchOrderByRelationAggregateInput
    instances?: MedicineInstanceOrderByRelationAggregateInput
  }

  export type VariationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VariationWhereInput | VariationWhereInput[]
    OR?: VariationWhereInput[]
    NOT?: VariationWhereInput | VariationWhereInput[]
    medicineId?: IntFilter<"Variation"> | number
    potency?: StringFilter<"Variation"> | string
    packaging?: StringFilter<"Variation"> | string
    unitType?: StringFilter<"Variation"> | string
    unitsPerPack?: IntFilter<"Variation"> | number
    createdAt?: DateTimeFilter<"Variation"> | Date | string
    updatedAt?: DateTimeFilter<"Variation"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    batches?: BatchListRelationFilter
    instances?: MedicineInstanceListRelationFilter
  }, "id">

  export type VariationOrderByWithAggregationInput = {
    id?: SortOrder
    medicineId?: SortOrder
    potency?: SortOrder
    packaging?: SortOrder
    unitType?: SortOrder
    unitsPerPack?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariationCountOrderByAggregateInput
    _avg?: VariationAvgOrderByAggregateInput
    _max?: VariationMaxOrderByAggregateInput
    _min?: VariationMinOrderByAggregateInput
    _sum?: VariationSumOrderByAggregateInput
  }

  export type VariationScalarWhereWithAggregatesInput = {
    AND?: VariationScalarWhereWithAggregatesInput | VariationScalarWhereWithAggregatesInput[]
    OR?: VariationScalarWhereWithAggregatesInput[]
    NOT?: VariationScalarWhereWithAggregatesInput | VariationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Variation"> | number
    medicineId?: IntWithAggregatesFilter<"Variation"> | number
    potency?: StringWithAggregatesFilter<"Variation"> | string
    packaging?: StringWithAggregatesFilter<"Variation"> | string
    unitType?: StringWithAggregatesFilter<"Variation"> | string
    unitsPerPack?: IntWithAggregatesFilter<"Variation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Variation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Variation"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: IntFilter<"Batch"> | number
    batchNo?: StringFilter<"Batch"> | string
    mfgDate?: DateTimeFilter<"Batch"> | Date | string
    expiryDate?: DateTimeFilter<"Batch"> | Date | string
    quantity?: IntFilter<"Batch"> | number
    price?: FloatFilter<"Batch"> | number
    variationId?: IntFilter<"Batch"> | number
    purchaseOrderId?: IntNullableFilter<"Batch"> | number | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    instances?: MedicineInstanceListRelationFilter
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    batchNo?: SortOrder
    mfgDate?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variation?: VariationOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    instances?: MedicineInstanceOrderByRelationAggregateInput
    soldItems?: SoldItemsOrderByRelationAggregateInput
    returnedItems?: ReturnedItemsOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    batchNo?: StringFilter<"Batch"> | string
    mfgDate?: DateTimeFilter<"Batch"> | Date | string
    expiryDate?: DateTimeFilter<"Batch"> | Date | string
    quantity?: IntFilter<"Batch"> | number
    price?: FloatFilter<"Batch"> | number
    variationId?: IntFilter<"Batch"> | number
    purchaseOrderId?: IntNullableFilter<"Batch"> | number | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    instances?: MedicineInstanceListRelationFilter
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }, "id">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    batchNo?: SortOrder
    mfgDate?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _avg?: BatchAvgOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
    _sum?: BatchSumOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Batch"> | number
    batchNo?: StringWithAggregatesFilter<"Batch"> | string
    mfgDate?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    quantity?: IntWithAggregatesFilter<"Batch"> | number
    price?: FloatWithAggregatesFilter<"Batch"> | number
    variationId?: IntWithAggregatesFilter<"Batch"> | number
    purchaseOrderId?: IntNullableWithAggregatesFilter<"Batch"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
  }

  export type MedicineInstanceWhereInput = {
    AND?: MedicineInstanceWhereInput | MedicineInstanceWhereInput[]
    OR?: MedicineInstanceWhereInput[]
    NOT?: MedicineInstanceWhereInput | MedicineInstanceWhereInput[]
    id?: IntFilter<"MedicineInstance"> | number
    variationId?: IntFilter<"MedicineInstance"> | number
    batchId?: IntFilter<"MedicineInstance"> | number
    expiryDate?: DateTimeFilter<"MedicineInstance"> | Date | string
    quantity?: IntFilter<"MedicineInstance"> | number
    purchasePrice?: FloatFilter<"MedicineInstance"> | number
    sellingPrice?: FloatFilter<"MedicineInstance"> | number
    createdAt?: DateTimeFilter<"MedicineInstance"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineInstance"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    locations?: MedicineLocationListRelationFilter
    subunits?: SubUnitListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
  }

  export type MedicineInstanceOrderByWithRelationInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variation?: VariationOrderByWithRelationInput
    batch?: BatchOrderByWithRelationInput
    locations?: MedicineLocationOrderByRelationAggregateInput
    subunits?: SubUnitOrderByRelationAggregateInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
  }

  export type MedicineInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicineInstanceWhereInput | MedicineInstanceWhereInput[]
    OR?: MedicineInstanceWhereInput[]
    NOT?: MedicineInstanceWhereInput | MedicineInstanceWhereInput[]
    variationId?: IntFilter<"MedicineInstance"> | number
    batchId?: IntFilter<"MedicineInstance"> | number
    expiryDate?: DateTimeFilter<"MedicineInstance"> | Date | string
    quantity?: IntFilter<"MedicineInstance"> | number
    purchasePrice?: FloatFilter<"MedicineInstance"> | number
    sellingPrice?: FloatFilter<"MedicineInstance"> | number
    createdAt?: DateTimeFilter<"MedicineInstance"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineInstance"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    locations?: MedicineLocationListRelationFilter
    subunits?: SubUnitListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
  }, "id">

  export type MedicineInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineInstanceCountOrderByAggregateInput
    _avg?: MedicineInstanceAvgOrderByAggregateInput
    _max?: MedicineInstanceMaxOrderByAggregateInput
    _min?: MedicineInstanceMinOrderByAggregateInput
    _sum?: MedicineInstanceSumOrderByAggregateInput
  }

  export type MedicineInstanceScalarWhereWithAggregatesInput = {
    AND?: MedicineInstanceScalarWhereWithAggregatesInput | MedicineInstanceScalarWhereWithAggregatesInput[]
    OR?: MedicineInstanceScalarWhereWithAggregatesInput[]
    NOT?: MedicineInstanceScalarWhereWithAggregatesInput | MedicineInstanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicineInstance"> | number
    variationId?: IntWithAggregatesFilter<"MedicineInstance"> | number
    batchId?: IntWithAggregatesFilter<"MedicineInstance"> | number
    expiryDate?: DateTimeWithAggregatesFilter<"MedicineInstance"> | Date | string
    quantity?: IntWithAggregatesFilter<"MedicineInstance"> | number
    purchasePrice?: FloatWithAggregatesFilter<"MedicineInstance"> | number
    sellingPrice?: FloatWithAggregatesFilter<"MedicineInstance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MedicineInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineInstance"> | Date | string
  }

  export type SubUnitWhereInput = {
    AND?: SubUnitWhereInput | SubUnitWhereInput[]
    OR?: SubUnitWhereInput[]
    NOT?: SubUnitWhereInput | SubUnitWhereInput[]
    id?: IntFilter<"SubUnit"> | number
    unitId?: IntFilter<"SubUnit"> | number
    name?: StringFilter<"SubUnit"> | string
    description?: StringNullableFilter<"SubUnit"> | string | null
    unitType?: StringFilter<"SubUnit"> | string
    subUnitCount?: IntFilter<"SubUnit"> | number
    subUnitPrice?: FloatFilter<"SubUnit"> | number
    isSold?: BoolFilter<"SubUnit"> | boolean
    isReturnedByCustomer?: BoolFilter<"SubUnit"> | boolean
    isReturnedToSupplier?: BoolFilter<"SubUnit"> | boolean
    createdAt?: DateTimeFilter<"SubUnit"> | Date | string
    updatedAt?: DateTimeFilter<"SubUnit"> | Date | string
    instance?: XOR<MedicineInstanceScalarRelationFilter, MedicineInstanceWhereInput>
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }

  export type SubUnitOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unitType?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
    isSold?: SortOrder
    isReturnedByCustomer?: SortOrder
    isReturnedToSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: MedicineInstanceOrderByWithRelationInput
    soldItems?: SoldItemsOrderByRelationAggregateInput
    returnedItems?: ReturnedItemsOrderByRelationAggregateInput
  }

  export type SubUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubUnitWhereInput | SubUnitWhereInput[]
    OR?: SubUnitWhereInput[]
    NOT?: SubUnitWhereInput | SubUnitWhereInput[]
    unitId?: IntFilter<"SubUnit"> | number
    name?: StringFilter<"SubUnit"> | string
    description?: StringNullableFilter<"SubUnit"> | string | null
    unitType?: StringFilter<"SubUnit"> | string
    subUnitCount?: IntFilter<"SubUnit"> | number
    subUnitPrice?: FloatFilter<"SubUnit"> | number
    isSold?: BoolFilter<"SubUnit"> | boolean
    isReturnedByCustomer?: BoolFilter<"SubUnit"> | boolean
    isReturnedToSupplier?: BoolFilter<"SubUnit"> | boolean
    createdAt?: DateTimeFilter<"SubUnit"> | Date | string
    updatedAt?: DateTimeFilter<"SubUnit"> | Date | string
    instance?: XOR<MedicineInstanceScalarRelationFilter, MedicineInstanceWhereInput>
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }, "id">

  export type SubUnitOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unitType?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
    isSold?: SortOrder
    isReturnedByCustomer?: SortOrder
    isReturnedToSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubUnitCountOrderByAggregateInput
    _avg?: SubUnitAvgOrderByAggregateInput
    _max?: SubUnitMaxOrderByAggregateInput
    _min?: SubUnitMinOrderByAggregateInput
    _sum?: SubUnitSumOrderByAggregateInput
  }

  export type SubUnitScalarWhereWithAggregatesInput = {
    AND?: SubUnitScalarWhereWithAggregatesInput | SubUnitScalarWhereWithAggregatesInput[]
    OR?: SubUnitScalarWhereWithAggregatesInput[]
    NOT?: SubUnitScalarWhereWithAggregatesInput | SubUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubUnit"> | number
    unitId?: IntWithAggregatesFilter<"SubUnit"> | number
    name?: StringWithAggregatesFilter<"SubUnit"> | string
    description?: StringNullableWithAggregatesFilter<"SubUnit"> | string | null
    unitType?: StringWithAggregatesFilter<"SubUnit"> | string
    subUnitCount?: IntWithAggregatesFilter<"SubUnit"> | number
    subUnitPrice?: FloatWithAggregatesFilter<"SubUnit"> | number
    isSold?: BoolWithAggregatesFilter<"SubUnit"> | boolean
    isReturnedByCustomer?: BoolWithAggregatesFilter<"SubUnit"> | boolean
    isReturnedToSupplier?: BoolWithAggregatesFilter<"SubUnit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubUnit"> | Date | string
  }

  export type MedicineLocationWhereInput = {
    AND?: MedicineLocationWhereInput | MedicineLocationWhereInput[]
    OR?: MedicineLocationWhereInput[]
    NOT?: MedicineLocationWhereInput | MedicineLocationWhereInput[]
    id?: IntFilter<"MedicineLocation"> | number
    medicalStoreId?: IntFilter<"MedicineLocation"> | number
    medicineId?: IntFilter<"MedicineLocation"> | number
    medicineInstanceId?: IntFilter<"MedicineLocation"> | number
    location?: StringFilter<"MedicineLocation"> | string
    rank?: StringNullableFilter<"MedicineLocation"> | string | null
    quantity?: IntFilter<"MedicineLocation"> | number
    createdAt?: DateTimeFilter<"MedicineLocation"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineLocation"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    instance?: XOR<MedicineInstanceScalarRelationFilter, MedicineInstanceWhereInput>
  }

  export type MedicineLocationOrderByWithRelationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    location?: SortOrder
    rank?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStore?: MedicalStoreOrderByWithRelationInput
    medicine?: MedicineOrderByWithRelationInput
    instance?: MedicineInstanceOrderByWithRelationInput
  }

  export type MedicineLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicineLocationWhereInput | MedicineLocationWhereInput[]
    OR?: MedicineLocationWhereInput[]
    NOT?: MedicineLocationWhereInput | MedicineLocationWhereInput[]
    medicalStoreId?: IntFilter<"MedicineLocation"> | number
    medicineId?: IntFilter<"MedicineLocation"> | number
    medicineInstanceId?: IntFilter<"MedicineLocation"> | number
    location?: StringFilter<"MedicineLocation"> | string
    rank?: StringNullableFilter<"MedicineLocation"> | string | null
    quantity?: IntFilter<"MedicineLocation"> | number
    createdAt?: DateTimeFilter<"MedicineLocation"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineLocation"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    instance?: XOR<MedicineInstanceScalarRelationFilter, MedicineInstanceWhereInput>
  }, "id">

  export type MedicineLocationOrderByWithAggregationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    location?: SortOrder
    rank?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineLocationCountOrderByAggregateInput
    _avg?: MedicineLocationAvgOrderByAggregateInput
    _max?: MedicineLocationMaxOrderByAggregateInput
    _min?: MedicineLocationMinOrderByAggregateInput
    _sum?: MedicineLocationSumOrderByAggregateInput
  }

  export type MedicineLocationScalarWhereWithAggregatesInput = {
    AND?: MedicineLocationScalarWhereWithAggregatesInput | MedicineLocationScalarWhereWithAggregatesInput[]
    OR?: MedicineLocationScalarWhereWithAggregatesInput[]
    NOT?: MedicineLocationScalarWhereWithAggregatesInput | MedicineLocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicineLocation"> | number
    medicalStoreId?: IntWithAggregatesFilter<"MedicineLocation"> | number
    medicineId?: IntWithAggregatesFilter<"MedicineLocation"> | number
    medicineInstanceId?: IntWithAggregatesFilter<"MedicineLocation"> | number
    location?: StringWithAggregatesFilter<"MedicineLocation"> | string
    rank?: StringNullableWithAggregatesFilter<"MedicineLocation"> | string | null
    quantity?: IntWithAggregatesFilter<"MedicineLocation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MedicineLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineLocation"> | Date | string
  }

  export type MedicalStoreMedicineWhereInput = {
    AND?: MedicalStoreMedicineWhereInput | MedicalStoreMedicineWhereInput[]
    OR?: MedicalStoreMedicineWhereInput[]
    NOT?: MedicalStoreMedicineWhereInput | MedicalStoreMedicineWhereInput[]
    id?: IntFilter<"MedicalStoreMedicine"> | number
    medicalStoreId?: IntFilter<"MedicalStoreMedicine"> | number
    medicineId?: IntFilter<"MedicalStoreMedicine"> | number
    quantity?: IntFilter<"MedicalStoreMedicine"> | number
    createdAt?: DateTimeFilter<"MedicalStoreMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStoreMedicine"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }

  export type MedicalStoreMedicineOrderByWithRelationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStore?: MedicalStoreOrderByWithRelationInput
    medicine?: MedicineOrderByWithRelationInput
  }

  export type MedicalStoreMedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    medicalStoreId_medicineId?: MedicalStoreMedicineMedicalStoreIdMedicineIdCompoundUniqueInput
    AND?: MedicalStoreMedicineWhereInput | MedicalStoreMedicineWhereInput[]
    OR?: MedicalStoreMedicineWhereInput[]
    NOT?: MedicalStoreMedicineWhereInput | MedicalStoreMedicineWhereInput[]
    medicalStoreId?: IntFilter<"MedicalStoreMedicine"> | number
    medicineId?: IntFilter<"MedicalStoreMedicine"> | number
    quantity?: IntFilter<"MedicalStoreMedicine"> | number
    createdAt?: DateTimeFilter<"MedicalStoreMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStoreMedicine"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }, "id" | "medicalStoreId_medicineId">

  export type MedicalStoreMedicineOrderByWithAggregationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalStoreMedicineCountOrderByAggregateInput
    _avg?: MedicalStoreMedicineAvgOrderByAggregateInput
    _max?: MedicalStoreMedicineMaxOrderByAggregateInput
    _min?: MedicalStoreMedicineMinOrderByAggregateInput
    _sum?: MedicalStoreMedicineSumOrderByAggregateInput
  }

  export type MedicalStoreMedicineScalarWhereWithAggregatesInput = {
    AND?: MedicalStoreMedicineScalarWhereWithAggregatesInput | MedicalStoreMedicineScalarWhereWithAggregatesInput[]
    OR?: MedicalStoreMedicineScalarWhereWithAggregatesInput[]
    NOT?: MedicalStoreMedicineScalarWhereWithAggregatesInput | MedicalStoreMedicineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicalStoreMedicine"> | number
    medicalStoreId?: IntWithAggregatesFilter<"MedicalStoreMedicine"> | number
    medicineId?: IntWithAggregatesFilter<"MedicalStoreMedicine"> | number
    quantity?: IntWithAggregatesFilter<"MedicalStoreMedicine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MedicalStoreMedicine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalStoreMedicine"> | Date | string
  }

  export type MedicineExpiryWhereInput = {
    AND?: MedicineExpiryWhereInput | MedicineExpiryWhereInput[]
    OR?: MedicineExpiryWhereInput[]
    NOT?: MedicineExpiryWhereInput | MedicineExpiryWhereInput[]
    id?: IntFilter<"MedicineExpiry"> | number
    medicineId?: IntFilter<"MedicineExpiry"> | number
    expiryDate?: DateTimeFilter<"MedicineExpiry"> | Date | string
    isNearExpiry?: BoolFilter<"MedicineExpiry"> | boolean
    createdAt?: DateTimeFilter<"MedicineExpiry"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineExpiry"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }

  export type MedicineExpiryOrderByWithRelationInput = {
    id?: SortOrder
    medicineId?: SortOrder
    expiryDate?: SortOrder
    isNearExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicine?: MedicineOrderByWithRelationInput
  }

  export type MedicineExpiryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    medicineId_expiryDate?: MedicineExpiryMedicineIdExpiryDateCompoundUniqueInput
    AND?: MedicineExpiryWhereInput | MedicineExpiryWhereInput[]
    OR?: MedicineExpiryWhereInput[]
    NOT?: MedicineExpiryWhereInput | MedicineExpiryWhereInput[]
    medicineId?: IntFilter<"MedicineExpiry"> | number
    expiryDate?: DateTimeFilter<"MedicineExpiry"> | Date | string
    isNearExpiry?: BoolFilter<"MedicineExpiry"> | boolean
    createdAt?: DateTimeFilter<"MedicineExpiry"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineExpiry"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }, "id" | "medicineId_expiryDate">

  export type MedicineExpiryOrderByWithAggregationInput = {
    id?: SortOrder
    medicineId?: SortOrder
    expiryDate?: SortOrder
    isNearExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineExpiryCountOrderByAggregateInput
    _avg?: MedicineExpiryAvgOrderByAggregateInput
    _max?: MedicineExpiryMaxOrderByAggregateInput
    _min?: MedicineExpiryMinOrderByAggregateInput
    _sum?: MedicineExpirySumOrderByAggregateInput
  }

  export type MedicineExpiryScalarWhereWithAggregatesInput = {
    AND?: MedicineExpiryScalarWhereWithAggregatesInput | MedicineExpiryScalarWhereWithAggregatesInput[]
    OR?: MedicineExpiryScalarWhereWithAggregatesInput[]
    NOT?: MedicineExpiryScalarWhereWithAggregatesInput | MedicineExpiryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicineExpiry"> | number
    medicineId?: IntWithAggregatesFilter<"MedicineExpiry"> | number
    expiryDate?: DateTimeWithAggregatesFilter<"MedicineExpiry"> | Date | string
    isNearExpiry?: BoolWithAggregatesFilter<"MedicineExpiry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MedicineExpiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineExpiry"> | Date | string
  }

  export type StockTransactionWhereInput = {
    AND?: StockTransactionWhereInput | StockTransactionWhereInput[]
    OR?: StockTransactionWhereInput[]
    NOT?: StockTransactionWhereInput | StockTransactionWhereInput[]
    id?: IntFilter<"StockTransaction"> | number
    medicalStoreId?: IntFilter<"StockTransaction"> | number
    medicineInstanceId?: IntFilter<"StockTransaction"> | number
    purchaseOrderId?: IntNullableFilter<"StockTransaction"> | number | null
    quantity?: IntFilter<"StockTransaction"> | number
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransaction"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    medicineInstance?: XOR<MedicineInstanceScalarRelationFilter, MedicineInstanceWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
  }

  export type StockTransactionOrderByWithRelationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStore?: MedicalStoreOrderByWithRelationInput
    medicineInstance?: MedicineInstanceOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type StockTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockTransactionWhereInput | StockTransactionWhereInput[]
    OR?: StockTransactionWhereInput[]
    NOT?: StockTransactionWhereInput | StockTransactionWhereInput[]
    medicalStoreId?: IntFilter<"StockTransaction"> | number
    medicineInstanceId?: IntFilter<"StockTransaction"> | number
    purchaseOrderId?: IntNullableFilter<"StockTransaction"> | number | null
    quantity?: IntFilter<"StockTransaction"> | number
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransaction"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    medicineInstance?: XOR<MedicineInstanceScalarRelationFilter, MedicineInstanceWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
  }, "id">

  export type StockTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockTransactionCountOrderByAggregateInput
    _avg?: StockTransactionAvgOrderByAggregateInput
    _max?: StockTransactionMaxOrderByAggregateInput
    _min?: StockTransactionMinOrderByAggregateInput
    _sum?: StockTransactionSumOrderByAggregateInput
  }

  export type StockTransactionScalarWhereWithAggregatesInput = {
    AND?: StockTransactionScalarWhereWithAggregatesInput | StockTransactionScalarWhereWithAggregatesInput[]
    OR?: StockTransactionScalarWhereWithAggregatesInput[]
    NOT?: StockTransactionScalarWhereWithAggregatesInput | StockTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockTransaction"> | number
    medicalStoreId?: IntWithAggregatesFilter<"StockTransaction"> | number
    medicineInstanceId?: IntWithAggregatesFilter<"StockTransaction"> | number
    purchaseOrderId?: IntNullableWithAggregatesFilter<"StockTransaction"> | number | null
    quantity?: IntWithAggregatesFilter<"StockTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockTransaction"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: IntFilter<"PurchaseOrder"> | number
    medicalStoreId?: IntFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableFilter<"PurchaseOrder"> | number | null
    userId?: IntFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: StringFilter<"PurchaseOrder"> | string
    totalCost?: FloatFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    batches?: BatchListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStore?: MedicalStoreOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    batches?: BatchOrderByRelationAggregateInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    medicalStoreId?: IntFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableFilter<"PurchaseOrder"> | number | null
    userId?: IntFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: StringFilter<"PurchaseOrder"> | string
    totalCost?: FloatFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    medicalStore?: XOR<MedicalStoreScalarRelationFilter, MedicalStoreWhereInput>
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    batches?: BatchListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
  }, "id">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    medicalStoreId?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableWithAggregatesFilter<"PurchaseOrder"> | number | null
    userId?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    totalCost?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    userId?: IntFilter<"Order"> | number
    customerId?: IntNullableFilter<"Order"> | number | null
    customerName?: StringNullableFilter<"Order"> | string | null
    customerLocation?: StringNullableFilter<"Order"> | string | null
    customerContact?: StringNullableFilter<"Order"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    changeCash?: FloatNullableFilter<"Order"> | number | null
    discount?: FloatNullableFilter<"Order"> | number | null
    discountType?: EnumDiscountTypeNullableFilter<"Order"> | $Enums.DiscountType | null
    itemsCost?: FloatFilter<"Order"> | number
    tax?: FloatNullableFilter<"Order"> | number | null
    sellingPrice?: FloatFilter<"Order"> | number
    profit?: FloatNullableFilter<"Order"> | number | null
    bill?: FloatFilter<"Order"> | number
    invoiceDate?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    customerLocation?: SortOrderInput | SortOrder
    customerContact?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    changeCash?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    itemsCost?: SortOrder
    tax?: SortOrderInput | SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrderInput | SortOrder
    bill?: SortOrder
    invoiceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    soldItems?: SoldItemsOrderByRelationAggregateInput
    returnedItems?: ReturnedItemsOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: IntFilter<"Order"> | number
    customerId?: IntNullableFilter<"Order"> | number | null
    customerName?: StringNullableFilter<"Order"> | string | null
    customerLocation?: StringNullableFilter<"Order"> | string | null
    customerContact?: StringNullableFilter<"Order"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    changeCash?: FloatNullableFilter<"Order"> | number | null
    discount?: FloatNullableFilter<"Order"> | number | null
    discountType?: EnumDiscountTypeNullableFilter<"Order"> | $Enums.DiscountType | null
    itemsCost?: FloatFilter<"Order"> | number
    tax?: FloatNullableFilter<"Order"> | number | null
    sellingPrice?: FloatFilter<"Order"> | number
    profit?: FloatNullableFilter<"Order"> | number | null
    bill?: FloatFilter<"Order"> | number
    invoiceDate?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    soldItems?: SoldItemsListRelationFilter
    returnedItems?: ReturnedItemsListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    customerLocation?: SortOrderInput | SortOrder
    customerContact?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    changeCash?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    itemsCost?: SortOrder
    tax?: SortOrderInput | SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrderInput | SortOrder
    bill?: SortOrder
    invoiceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    userId?: IntWithAggregatesFilter<"Order"> | number
    customerId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    customerName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerLocation?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerContact?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Order"> | $Enums.PaymentMethod
    changeCash?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    discount?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    discountType?: EnumDiscountTypeNullableWithAggregatesFilter<"Order"> | $Enums.DiscountType | null
    itemsCost?: FloatWithAggregatesFilter<"Order"> | number
    tax?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    sellingPrice?: FloatWithAggregatesFilter<"Order"> | number
    profit?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    bill?: FloatWithAggregatesFilter<"Order"> | number
    invoiceDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    status?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    orders?: OrderListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SoldItemsWhereInput = {
    AND?: SoldItemsWhereInput | SoldItemsWhereInput[]
    OR?: SoldItemsWhereInput[]
    NOT?: SoldItemsWhereInput | SoldItemsWhereInput[]
    id?: IntFilter<"SoldItems"> | number
    orderId?: IntFilter<"SoldItems"> | number
    medicineId?: IntFilter<"SoldItems"> | number
    batchId?: IntNullableFilter<"SoldItems"> | number | null
    subUnitId?: IntNullableFilter<"SoldItems"> | number | null
    packing?: StringNullableFilter<"SoldItems"> | string | null
    quantity?: IntFilter<"SoldItems"> | number
    retailPrice?: FloatFilter<"SoldItems"> | number
    discountPrice?: FloatNullableFilter<"SoldItems"> | number | null
    margin?: FloatFilter<"SoldItems"> | number
    saleDate?: DateTimeFilter<"SoldItems"> | Date | string
    updatedAt?: DateTimeFilter<"SoldItems"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    subUnit?: XOR<SubUnitNullableScalarRelationFilter, SubUnitWhereInput> | null
  }

  export type SoldItemsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    subUnitId?: SortOrderInput | SortOrder
    packing?: SortOrderInput | SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrderInput | SortOrder
    margin?: SortOrder
    saleDate?: SortOrder
    updatedAt?: SortOrder
    medicine?: MedicineOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    batch?: BatchOrderByWithRelationInput
    subUnit?: SubUnitOrderByWithRelationInput
  }

  export type SoldItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SoldItemsWhereInput | SoldItemsWhereInput[]
    OR?: SoldItemsWhereInput[]
    NOT?: SoldItemsWhereInput | SoldItemsWhereInput[]
    orderId?: IntFilter<"SoldItems"> | number
    medicineId?: IntFilter<"SoldItems"> | number
    batchId?: IntNullableFilter<"SoldItems"> | number | null
    subUnitId?: IntNullableFilter<"SoldItems"> | number | null
    packing?: StringNullableFilter<"SoldItems"> | string | null
    quantity?: IntFilter<"SoldItems"> | number
    retailPrice?: FloatFilter<"SoldItems"> | number
    discountPrice?: FloatNullableFilter<"SoldItems"> | number | null
    margin?: FloatFilter<"SoldItems"> | number
    saleDate?: DateTimeFilter<"SoldItems"> | Date | string
    updatedAt?: DateTimeFilter<"SoldItems"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    subUnit?: XOR<SubUnitNullableScalarRelationFilter, SubUnitWhereInput> | null
  }, "id">

  export type SoldItemsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    subUnitId?: SortOrderInput | SortOrder
    packing?: SortOrderInput | SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrderInput | SortOrder
    margin?: SortOrder
    saleDate?: SortOrder
    updatedAt?: SortOrder
    _count?: SoldItemsCountOrderByAggregateInput
    _avg?: SoldItemsAvgOrderByAggregateInput
    _max?: SoldItemsMaxOrderByAggregateInput
    _min?: SoldItemsMinOrderByAggregateInput
    _sum?: SoldItemsSumOrderByAggregateInput
  }

  export type SoldItemsScalarWhereWithAggregatesInput = {
    AND?: SoldItemsScalarWhereWithAggregatesInput | SoldItemsScalarWhereWithAggregatesInput[]
    OR?: SoldItemsScalarWhereWithAggregatesInput[]
    NOT?: SoldItemsScalarWhereWithAggregatesInput | SoldItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SoldItems"> | number
    orderId?: IntWithAggregatesFilter<"SoldItems"> | number
    medicineId?: IntWithAggregatesFilter<"SoldItems"> | number
    batchId?: IntNullableWithAggregatesFilter<"SoldItems"> | number | null
    subUnitId?: IntNullableWithAggregatesFilter<"SoldItems"> | number | null
    packing?: StringNullableWithAggregatesFilter<"SoldItems"> | string | null
    quantity?: IntWithAggregatesFilter<"SoldItems"> | number
    retailPrice?: FloatWithAggregatesFilter<"SoldItems"> | number
    discountPrice?: FloatNullableWithAggregatesFilter<"SoldItems"> | number | null
    margin?: FloatWithAggregatesFilter<"SoldItems"> | number
    saleDate?: DateTimeWithAggregatesFilter<"SoldItems"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SoldItems"> | Date | string
  }

  export type ReturnedItemsWhereInput = {
    AND?: ReturnedItemsWhereInput | ReturnedItemsWhereInput[]
    OR?: ReturnedItemsWhereInput[]
    NOT?: ReturnedItemsWhereInput | ReturnedItemsWhereInput[]
    id?: IntFilter<"ReturnedItems"> | number
    orderId?: IntFilter<"ReturnedItems"> | number
    medicineId?: IntFilter<"ReturnedItems"> | number
    batchId?: IntNullableFilter<"ReturnedItems"> | number | null
    subUnitId?: IntNullableFilter<"ReturnedItems"> | number | null
    packing?: StringNullableFilter<"ReturnedItems"> | string | null
    quantity?: IntFilter<"ReturnedItems"> | number
    retailPrice?: FloatFilter<"ReturnedItems"> | number
    discountPrice?: FloatNullableFilter<"ReturnedItems"> | number | null
    margin?: FloatFilter<"ReturnedItems"> | number
    returnType?: EnumReturnTypeFilter<"ReturnedItems"> | $Enums.ReturnType
    returnedDate?: DateTimeFilter<"ReturnedItems"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnedItems"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    subUnit?: XOR<SubUnitNullableScalarRelationFilter, SubUnitWhereInput> | null
  }

  export type ReturnedItemsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    subUnitId?: SortOrderInput | SortOrder
    packing?: SortOrderInput | SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrderInput | SortOrder
    margin?: SortOrder
    returnType?: SortOrder
    returnedDate?: SortOrder
    updatedAt?: SortOrder
    medicine?: MedicineOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    batch?: BatchOrderByWithRelationInput
    subUnit?: SubUnitOrderByWithRelationInput
  }

  export type ReturnedItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReturnedItemsWhereInput | ReturnedItemsWhereInput[]
    OR?: ReturnedItemsWhereInput[]
    NOT?: ReturnedItemsWhereInput | ReturnedItemsWhereInput[]
    orderId?: IntFilter<"ReturnedItems"> | number
    medicineId?: IntFilter<"ReturnedItems"> | number
    batchId?: IntNullableFilter<"ReturnedItems"> | number | null
    subUnitId?: IntNullableFilter<"ReturnedItems"> | number | null
    packing?: StringNullableFilter<"ReturnedItems"> | string | null
    quantity?: IntFilter<"ReturnedItems"> | number
    retailPrice?: FloatFilter<"ReturnedItems"> | number
    discountPrice?: FloatNullableFilter<"ReturnedItems"> | number | null
    margin?: FloatFilter<"ReturnedItems"> | number
    returnType?: EnumReturnTypeFilter<"ReturnedItems"> | $Enums.ReturnType
    returnedDate?: DateTimeFilter<"ReturnedItems"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnedItems"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    subUnit?: XOR<SubUnitNullableScalarRelationFilter, SubUnitWhereInput> | null
  }, "id">

  export type ReturnedItemsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    subUnitId?: SortOrderInput | SortOrder
    packing?: SortOrderInput | SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrderInput | SortOrder
    margin?: SortOrder
    returnType?: SortOrder
    returnedDate?: SortOrder
    updatedAt?: SortOrder
    _count?: ReturnedItemsCountOrderByAggregateInput
    _avg?: ReturnedItemsAvgOrderByAggregateInput
    _max?: ReturnedItemsMaxOrderByAggregateInput
    _min?: ReturnedItemsMinOrderByAggregateInput
    _sum?: ReturnedItemsSumOrderByAggregateInput
  }

  export type ReturnedItemsScalarWhereWithAggregatesInput = {
    AND?: ReturnedItemsScalarWhereWithAggregatesInput | ReturnedItemsScalarWhereWithAggregatesInput[]
    OR?: ReturnedItemsScalarWhereWithAggregatesInput[]
    NOT?: ReturnedItemsScalarWhereWithAggregatesInput | ReturnedItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReturnedItems"> | number
    orderId?: IntWithAggregatesFilter<"ReturnedItems"> | number
    medicineId?: IntWithAggregatesFilter<"ReturnedItems"> | number
    batchId?: IntNullableWithAggregatesFilter<"ReturnedItems"> | number | null
    subUnitId?: IntNullableWithAggregatesFilter<"ReturnedItems"> | number | null
    packing?: StringNullableWithAggregatesFilter<"ReturnedItems"> | string | null
    quantity?: IntWithAggregatesFilter<"ReturnedItems"> | number
    retailPrice?: FloatWithAggregatesFilter<"ReturnedItems"> | number
    discountPrice?: FloatNullableWithAggregatesFilter<"ReturnedItems"> | number | null
    margin?: FloatWithAggregatesFilter<"ReturnedItems"> | number
    returnType?: EnumReturnTypeWithAggregatesFilter<"ReturnedItems"> | $Enums.ReturnType
    returnedDate?: DateTimeWithAggregatesFilter<"ReturnedItems"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReturnedItems"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: IntWithAggregatesFilter<"AuditLog"> | number
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: UserCreateNestedOneWithoutChildrenInput
    children?: UserCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreCreateNestedOneWithoutOwnerInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserUncheckedCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneWithoutChildrenNestedInput
    children?: UserUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUpdateOneWithoutOwnerNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUncheckedUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreCreateInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreCreateManyInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutCompaniesInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    medicines?: MedicineCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStoreId: number
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    medicines?: MedicineUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutCompaniesNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    medicines?: MedicineUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    medicines?: MedicineUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStoreId: number
  }

  export type CompanyUpdateManyMutationInput = {
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStoreId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierCreateInput = {
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutSuppliersInput
    company: CompanyCreateNestedOneWithoutSuppliersInput
    medicines?: MedicineCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    companyId: number
    medicalStoreId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicineUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutSuppliersNestedInput
    company?: CompanyUpdateOneRequiredWithoutSuppliersNestedInput
    medicines?: MedicineUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicineUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    companyId: number
    medicalStoreId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineCreateInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineCreateManyInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationCreateInput = {
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutVariationsInput
    batches?: BatchCreateNestedManyWithoutVariationInput
    instances?: MedicineInstanceCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateInput = {
    id?: number
    medicineId: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutVariationInput
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationUpdateInput = {
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutVariationsNestedInput
    batches?: BatchUpdateManyWithoutVariationNestedInput
    instances?: MedicineInstanceUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutVariationNestedInput
    instances?: MedicineInstanceUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationCreateManyInput = {
    id?: number
    medicineId: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationUpdateManyMutationInput = {
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutBatchesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutBatchesInput
    instances?: MedicineInstanceCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutBatchesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutBatchesNestedInput
    instances?: MedicineInstanceUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: MedicineInstanceUncheckedUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateManyMutationInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineInstanceCreateInput = {
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutInstancesInput
    batch: BatchCreateNestedOneWithoutInstancesInput
    locations?: MedicineLocationCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceUncheckedCreateInput = {
    id?: number
    variationId: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitUncheckedCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceUpdateInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutInstancesNestedInput
    batch?: BatchUpdateOneRequiredWithoutInstancesNestedInput
    locations?: MedicineLocationUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUncheckedUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceCreateManyInput = {
    id?: number
    variationId: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineInstanceUpdateManyMutationInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineInstanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubUnitCreateInput = {
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: MedicineInstanceCreateNestedOneWithoutSubunitsInput
    soldItems?: SoldItemsCreateNestedManyWithoutSubUnitInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitUncheckedCreateInput = {
    id?: number
    unitId: number
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutSubUnitInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: MedicineInstanceUpdateOneRequiredWithoutSubunitsNestedInput
    soldItems?: SoldItemsUpdateManyWithoutSubUnitNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutSubUnitNestedInput
  }

  export type SubUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutSubUnitNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutSubUnitNestedInput
  }

  export type SubUnitCreateManyInput = {
    id?: number
    unitId: number
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubUnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationCreateInput = {
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutLocationsInput
    medicine: MedicineCreateNestedOneWithoutLocationsInput
    instance: MedicineInstanceCreateNestedOneWithoutLocationsInput
  }

  export type MedicineLocationUncheckedCreateInput = {
    id?: number
    medicalStoreId: number
    medicineId: number
    medicineInstanceId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationUpdateInput = {
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutLocationsNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutLocationsNestedInput
    instance?: MedicineInstanceUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type MedicineLocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationCreateManyInput = {
    id?: number
    medicalStoreId: number
    medicineId: number
    medicineInstanceId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationUpdateManyMutationInput = {
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineCreateInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutMedicinesInput
    medicine: MedicineCreateNestedOneWithoutMedicalStoreMedicinesInput
  }

  export type MedicalStoreMedicineUncheckedCreateInput = {
    id?: number
    medicalStoreId: number
    medicineId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreMedicineUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutMedicinesNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutMedicalStoreMedicinesNestedInput
  }

  export type MedicalStoreMedicineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineCreateManyInput = {
    id?: number
    medicalStoreId: number
    medicineId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreMedicineUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineExpiryCreateInput = {
    expiryDate: Date | string
    isNearExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutExpiryRecordsInput
  }

  export type MedicineExpiryUncheckedCreateInput = {
    id?: number
    medicineId: number
    expiryDate: Date | string
    isNearExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineExpiryUpdateInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutExpiryRecordsNestedInput
  }

  export type MedicineExpiryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineExpiryCreateManyInput = {
    id?: number
    medicineId: number
    expiryDate: Date | string
    isNearExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineExpiryUpdateManyMutationInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineExpiryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionCreateInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutStockTransactionsInput
    medicineInstance: MedicineInstanceCreateNestedOneWithoutStockTransactionsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateInput = {
    id?: number
    medicalStoreId: number
    medicineInstanceId: number
    purchaseOrderId?: number | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutStockTransactionsNestedInput
    medicineInstance?: MedicineInstanceUpdateOneRequiredWithoutStockTransactionsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionCreateManyInput = {
    id?: number
    medicalStoreId: number
    medicineInstanceId: number
    purchaseOrderId?: number | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    user: UserCreateNestedOneWithoutPurchaseOrdersInput
    batches?: BatchCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: number
    medicalStoreId: number
    supplierId?: number | null
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    batches?: BatchUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: number
    medicalStoreId: number
    supplierId?: number | null
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    soldItems?: SoldItemsCreateNestedManyWithoutOrderInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    userId: number
    customerId?: number | null
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutOrderInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    soldItems?: SoldItemsUpdateManyWithoutOrderNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutOrderNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    userId: number
    customerId?: number | null
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsCreateInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutSoldItemsInput
    order: OrderCreateNestedOneWithoutSoldItemsInput
    batch?: BatchCreateNestedOneWithoutSoldItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutSoldItemsInput
  }

  export type SoldItemsUncheckedCreateInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsUpdateInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutSoldItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutSoldItemsNestedInput
    batch?: BatchUpdateOneWithoutSoldItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutSoldItemsNestedInput
  }

  export type SoldItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsCreateManyInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsUpdateManyMutationInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsCreateInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutReturnedItemsInput
    order: OrderCreateNestedOneWithoutReturnedItemsInput
    batch?: BatchCreateNestedOneWithoutReturnedItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutReturnedItemsInput
  }

  export type ReturnedItemsUncheckedCreateInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsUpdateInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutReturnedItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutReturnedItemsNestedInput
    batch?: BatchUpdateOneWithoutReturnedItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutReturnedItemsNestedInput
  }

  export type ReturnedItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsCreateManyInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsUpdateManyMutationInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    action: string
    entity: string
    entityId: number
    description?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    entity: string
    entityId: number
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId: number
    action: string
    entity: string
    entityId: number
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type MedicalStoreNullableScalarRelationFilter = {
    is?: MedicalStoreWhereInput | null
    isNot?: MedicalStoreWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    employeeId?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    employeeId?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    employeeId?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MedicalStoreMedicineListRelationFilter = {
    every?: MedicalStoreMedicineWhereInput
    some?: MedicalStoreMedicineWhereInput
    none?: MedicalStoreMedicineWhereInput
  }

  export type MedicineLocationListRelationFilter = {
    every?: MedicineLocationWhereInput
    some?: MedicineLocationWhereInput
    none?: MedicineLocationWhereInput
  }

  export type StockTransactionListRelationFilter = {
    every?: StockTransactionWhereInput
    some?: StockTransactionWhereInput
    none?: StockTransactionWhereInput
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type MedicalStoreMedicineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalStoreCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    licenseNumber?: SortOrder
    phoneNumber?: SortOrder
    ntnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalStoreAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type MedicalStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    licenseNumber?: SortOrder
    phoneNumber?: SortOrder
    ntnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalStoreMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    licenseNumber?: SortOrder
    phoneNumber?: SortOrder
    ntnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalStoreSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type MedicalStoreScalarRelationFilter = {
    is?: MedicalStoreWhereInput
    isNot?: MedicalStoreWhereInput
  }

  export type MedicineListRelationFilter = {
    every?: MedicineWhereInput
    some?: MedicineWhereInput
    none?: MedicineWhereInput
  }

  export type MedicineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCompanyCodeMedicalStoreIdCompoundUniqueInput = {
    companyCode: string
    medicalStoreId: number
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    companyCode?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrder
    registrationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyCode?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrder
    registrationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    companyCode?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrder
    registrationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type SupplierSupplierCodeMedicalStoreIdCompoundUniqueInput = {
    supplierCode: string
    medicalStoreId: number
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    supplierCode?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierCode?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    supplierCode?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    distributorCode?: SortOrder
    ntnNumber?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    medicalStoreId?: SortOrder
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type VariationListRelationFilter = {
    every?: VariationWhereInput
    some?: VariationWhereInput
    none?: VariationWhereInput
  }

  export type MedicineExpiryListRelationFilter = {
    every?: MedicineExpiryWhereInput
    some?: MedicineExpiryWhereInput
    none?: MedicineExpiryWhereInput
  }

  export type SoldItemsListRelationFilter = {
    every?: SoldItemsWhereInput
    some?: SoldItemsWhereInput
    none?: SoldItemsWhereInput
  }

  export type ReturnedItemsListRelationFilter = {
    every?: ReturnedItemsWhereInput
    some?: ReturnedItemsWhereInput
    none?: ReturnedItemsWhereInput
  }

  export type VariationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineExpiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SoldItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnedItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    formula?: SortOrder
    description?: SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineAvgOrderByAggregateInput = {
    id?: SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
  }

  export type MedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    formula?: SortOrder
    description?: SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    formula?: SortOrder
    description?: SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineSumOrderByAggregateInput = {
    id?: SortOrder
    minquantity?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
  }

  export type MedicineScalarRelationFilter = {
    is?: MedicineWhereInput
    isNot?: MedicineWhereInput
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type MedicineInstanceListRelationFilter = {
    every?: MedicineInstanceWhereInput
    some?: MedicineInstanceWhereInput
    none?: MedicineInstanceWhereInput
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariationCountOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    potency?: SortOrder
    packaging?: SortOrder
    unitType?: SortOrder
    unitsPerPack?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationAvgOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    unitsPerPack?: SortOrder
  }

  export type VariationMaxOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    potency?: SortOrder
    packaging?: SortOrder
    unitType?: SortOrder
    unitsPerPack?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationMinOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    potency?: SortOrder
    packaging?: SortOrder
    unitType?: SortOrder
    unitsPerPack?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationSumOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    unitsPerPack?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type VariationScalarRelationFilter = {
    is?: VariationWhereInput
    isNot?: VariationWhereInput
  }

  export type PurchaseOrderNullableScalarRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    batchNo?: SortOrder
    mfgDate?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    batchNo?: SortOrder
    mfgDate?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    batchNo?: SortOrder
    mfgDate?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    variationId?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BatchScalarRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type SubUnitListRelationFilter = {
    every?: SubUnitWhereInput
    some?: SubUnitWhereInput
    none?: SubUnitWhereInput
  }

  export type SubUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineInstanceAvgOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
  }

  export type MedicineInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineInstanceSumOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
  }

  export type MedicineInstanceScalarRelationFilter = {
    is?: MedicineInstanceWhereInput
    isNot?: MedicineInstanceWhereInput
  }

  export type SubUnitCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unitType?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
    isSold?: SortOrder
    isReturnedByCustomer?: SortOrder
    isReturnedToSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubUnitAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
  }

  export type SubUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unitType?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
    isSold?: SortOrder
    isReturnedByCustomer?: SortOrder
    isReturnedToSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubUnitMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unitType?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
    isSold?: SortOrder
    isReturnedByCustomer?: SortOrder
    isReturnedToSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubUnitSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    subUnitCount?: SortOrder
    subUnitPrice?: SortOrder
  }

  export type MedicineLocationCountOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    location?: SortOrder
    rank?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineLocationAvgOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    quantity?: SortOrder
  }

  export type MedicineLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    location?: SortOrder
    rank?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineLocationMinOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    location?: SortOrder
    rank?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineLocationSumOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    medicineInstanceId?: SortOrder
    quantity?: SortOrder
  }

  export type MedicalStoreMedicineMedicalStoreIdMedicineIdCompoundUniqueInput = {
    medicalStoreId: number
    medicineId: number
  }

  export type MedicalStoreMedicineCountOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalStoreMedicineAvgOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
  }

  export type MedicalStoreMedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalStoreMedicineMinOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalStoreMedicineSumOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
  }

  export type MedicineExpiryMedicineIdExpiryDateCompoundUniqueInput = {
    medicineId: number
    expiryDate: Date | string
  }

  export type MedicineExpiryCountOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    expiryDate?: SortOrder
    isNearExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineExpiryAvgOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
  }

  export type MedicineExpiryMaxOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    expiryDate?: SortOrder
    isNearExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineExpiryMinOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    expiryDate?: SortOrder
    isNearExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineExpirySumOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
  }

  export type StockTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
  }

  export type StockTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    medicineInstanceId?: SortOrder
    purchaseOrderId?: SortOrder
    quantity?: SortOrder
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    totalCost?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    id?: SortOrder
    medicalStoreId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    totalCost?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDiscountTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableFilter<$PrismaModel> | $Enums.DiscountType | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerLocation?: SortOrder
    customerContact?: SortOrder
    paymentMethod?: SortOrder
    changeCash?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    itemsCost?: SortOrder
    tax?: SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrder
    bill?: SortOrder
    invoiceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    changeCash?: SortOrder
    discount?: SortOrder
    itemsCost?: SortOrder
    tax?: SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrder
    bill?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerLocation?: SortOrder
    customerContact?: SortOrder
    paymentMethod?: SortOrder
    changeCash?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    itemsCost?: SortOrder
    tax?: SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrder
    bill?: SortOrder
    invoiceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerLocation?: SortOrder
    customerContact?: SortOrder
    paymentMethod?: SortOrder
    changeCash?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    itemsCost?: SortOrder
    tax?: SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrder
    bill?: SortOrder
    invoiceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    changeCash?: SortOrder
    discount?: SortOrder
    itemsCost?: SortOrder
    tax?: SortOrder
    sellingPrice?: SortOrder
    profit?: SortOrder
    bill?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type SubUnitNullableScalarRelationFilter = {
    is?: SubUnitWhereInput | null
    isNot?: SubUnitWhereInput | null
  }

  export type SoldItemsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    packing?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
    saleDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoldItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
  }

  export type SoldItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    packing?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
    saleDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoldItemsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    packing?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
    saleDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoldItemsSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
  }

  export type EnumReturnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnType | EnumReturnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnTypeFilter<$PrismaModel> | $Enums.ReturnType
  }

  export type ReturnedItemsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    packing?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
    returnType?: SortOrder
    returnedDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnedItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
  }

  export type ReturnedItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    packing?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
    returnType?: SortOrder
    returnedDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnedItemsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    packing?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
    returnType?: SortOrder
    returnedDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnedItemsSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    batchId?: SortOrder
    subUnitId?: SortOrder
    quantity?: SortOrder
    retailPrice?: SortOrder
    discountPrice?: SortOrder
    margin?: SortOrder
  }

  export type EnumReturnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnType | EnumReturnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReturnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnTypeFilter<$PrismaModel>
    _max?: NestedEnumReturnTypeFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type UserCreateNestedOneWithoutChildrenInput = {
    create?: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: UserCreateOrConnectWithoutChildrenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput> | UserCreateWithoutParentInput[] | UserUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParentInput | UserCreateOrConnectWithoutParentInput[]
    createMany?: UserCreateManyParentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MedicalStoreCreateNestedOneWithoutOwnerInput = {
    create?: XOR<MedicalStoreCreateWithoutOwnerInput, MedicalStoreUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutOwnerInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput> | PurchaseOrderCreateWithoutUserInput[] | PurchaseOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUserInput | PurchaseOrderCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput> | UserCreateWithoutParentInput[] | UserUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParentInput | UserCreateOrConnectWithoutParentInput[]
    createMany?: UserCreateManyParentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<MedicalStoreCreateWithoutOwnerInput, MedicalStoreUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutOwnerInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput> | PurchaseOrderCreateWithoutUserInput[] | PurchaseOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUserInput | PurchaseOrderCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: UserCreateOrConnectWithoutChildrenInput
    upsert?: UserUpsertWithoutChildrenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChildrenInput, UserUpdateWithoutChildrenInput>, UserUncheckedUpdateWithoutChildrenInput>
  }

  export type UserUpdateManyWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput> | UserCreateWithoutParentInput[] | UserUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParentInput | UserCreateOrConnectWithoutParentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutParentInput | UserUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: UserCreateManyParentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutParentInput | UserUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutParentInput | UserUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MedicalStoreUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutOwnerInput, MedicalStoreUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutOwnerInput
    upsert?: MedicalStoreUpsertWithoutOwnerInput
    disconnect?: MedicalStoreWhereInput | boolean
    delete?: MedicalStoreWhereInput | boolean
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutOwnerInput, MedicalStoreUpdateWithoutOwnerInput>, MedicalStoreUncheckedUpdateWithoutOwnerInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput> | PurchaseOrderCreateWithoutUserInput[] | PurchaseOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUserInput | PurchaseOrderCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutUserInput | PurchaseOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutUserInput | PurchaseOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutUserInput | PurchaseOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput> | UserCreateWithoutParentInput[] | UserUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParentInput | UserCreateOrConnectWithoutParentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutParentInput | UserUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: UserCreateManyParentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutParentInput | UserUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutParentInput | UserUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutOwnerInput, MedicalStoreUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutOwnerInput
    upsert?: MedicalStoreUpsertWithoutOwnerInput
    disconnect?: MedicalStoreWhereInput | boolean
    delete?: MedicalStoreWhereInput | boolean
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutOwnerInput, MedicalStoreUpdateWithoutOwnerInput>, MedicalStoreUncheckedUpdateWithoutOwnerInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput> | PurchaseOrderCreateWithoutUserInput[] | PurchaseOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUserInput | PurchaseOrderCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutUserInput | PurchaseOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutUserInput | PurchaseOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutUserInput | PurchaseOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMedicalStoreInput = {
    create?: XOR<UserCreateWithoutMedicalStoreInput, UserUncheckedCreateWithoutMedicalStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicalStoreInput
    connect?: UserWhereUniqueInput
  }

  export type MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput> | MedicalStoreMedicineCreateWithoutMedicalStoreInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput | MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicalStoreInputEnvelope
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
  }

  export type MedicineLocationCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicalStoreInput, MedicineLocationUncheckedCreateWithoutMedicalStoreInput> | MedicineLocationCreateWithoutMedicalStoreInput[] | MedicineLocationUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicalStoreInput | MedicineLocationCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: MedicineLocationCreateManyMedicalStoreInputEnvelope
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<PurchaseOrderCreateWithoutMedicalStoreInput, PurchaseOrderUncheckedCreateWithoutMedicalStoreInput> | PurchaseOrderCreateWithoutMedicalStoreInput[] | PurchaseOrderUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutMedicalStoreInput | PurchaseOrderCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: PurchaseOrderCreateManyMedicalStoreInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type StockTransactionCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<StockTransactionCreateWithoutMedicalStoreInput, StockTransactionUncheckedCreateWithoutMedicalStoreInput> | StockTransactionCreateWithoutMedicalStoreInput[] | StockTransactionUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicalStoreInput | StockTransactionCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: StockTransactionCreateManyMedicalStoreInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type CompanyCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<CompanyCreateWithoutMedicalStoreInput, CompanyUncheckedCreateWithoutMedicalStoreInput> | CompanyCreateWithoutMedicalStoreInput[] | CompanyUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutMedicalStoreInput | CompanyCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: CompanyCreateManyMedicalStoreInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<SupplierCreateWithoutMedicalStoreInput, SupplierUncheckedCreateWithoutMedicalStoreInput> | SupplierCreateWithoutMedicalStoreInput[] | SupplierUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutMedicalStoreInput | SupplierCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: SupplierCreateManyMedicalStoreInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput> | MedicalStoreMedicineCreateWithoutMedicalStoreInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput | MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicalStoreInputEnvelope
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
  }

  export type MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicalStoreInput, MedicineLocationUncheckedCreateWithoutMedicalStoreInput> | MedicineLocationCreateWithoutMedicalStoreInput[] | MedicineLocationUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicalStoreInput | MedicineLocationCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: MedicineLocationCreateManyMedicalStoreInputEnvelope
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<PurchaseOrderCreateWithoutMedicalStoreInput, PurchaseOrderUncheckedCreateWithoutMedicalStoreInput> | PurchaseOrderCreateWithoutMedicalStoreInput[] | PurchaseOrderUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutMedicalStoreInput | PurchaseOrderCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: PurchaseOrderCreateManyMedicalStoreInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<StockTransactionCreateWithoutMedicalStoreInput, StockTransactionUncheckedCreateWithoutMedicalStoreInput> | StockTransactionCreateWithoutMedicalStoreInput[] | StockTransactionUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicalStoreInput | StockTransactionCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: StockTransactionCreateManyMedicalStoreInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<CompanyCreateWithoutMedicalStoreInput, CompanyUncheckedCreateWithoutMedicalStoreInput> | CompanyCreateWithoutMedicalStoreInput[] | CompanyUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutMedicalStoreInput | CompanyCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: CompanyCreateManyMedicalStoreInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput = {
    create?: XOR<SupplierCreateWithoutMedicalStoreInput, SupplierUncheckedCreateWithoutMedicalStoreInput> | SupplierCreateWithoutMedicalStoreInput[] | SupplierUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutMedicalStoreInput | SupplierCreateOrConnectWithoutMedicalStoreInput[]
    createMany?: SupplierCreateManyMedicalStoreInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMedicalStoreNestedInput = {
    create?: XOR<UserCreateWithoutMedicalStoreInput, UserUncheckedCreateWithoutMedicalStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicalStoreInput
    upsert?: UserUpsertWithoutMedicalStoreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicalStoreInput, UserUpdateWithoutMedicalStoreInput>, UserUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput> | MedicalStoreMedicineCreateWithoutMedicalStoreInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput | MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicalStoreInput | MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicalStoreInputEnvelope
    set?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    disconnect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    delete?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    update?: MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicalStoreInput | MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: MedicalStoreMedicineUpdateManyWithWhereWithoutMedicalStoreInput | MedicalStoreMedicineUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: MedicalStoreMedicineScalarWhereInput | MedicalStoreMedicineScalarWhereInput[]
  }

  export type MedicineLocationUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicalStoreInput, MedicineLocationUncheckedCreateWithoutMedicalStoreInput> | MedicineLocationCreateWithoutMedicalStoreInput[] | MedicineLocationUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicalStoreInput | MedicineLocationCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: MedicineLocationUpsertWithWhereUniqueWithoutMedicalStoreInput | MedicineLocationUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: MedicineLocationCreateManyMedicalStoreInputEnvelope
    set?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    disconnect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    delete?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    update?: MedicineLocationUpdateWithWhereUniqueWithoutMedicalStoreInput | MedicineLocationUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: MedicineLocationUpdateManyWithWhereWithoutMedicalStoreInput | MedicineLocationUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutMedicalStoreInput, PurchaseOrderUncheckedCreateWithoutMedicalStoreInput> | PurchaseOrderCreateWithoutMedicalStoreInput[] | PurchaseOrderUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutMedicalStoreInput | PurchaseOrderCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutMedicalStoreInput | PurchaseOrderUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: PurchaseOrderCreateManyMedicalStoreInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutMedicalStoreInput | PurchaseOrderUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutMedicalStoreInput | PurchaseOrderUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type StockTransactionUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<StockTransactionCreateWithoutMedicalStoreInput, StockTransactionUncheckedCreateWithoutMedicalStoreInput> | StockTransactionCreateWithoutMedicalStoreInput[] | StockTransactionUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicalStoreInput | StockTransactionCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutMedicalStoreInput | StockTransactionUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: StockTransactionCreateManyMedicalStoreInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutMedicalStoreInput | StockTransactionUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutMedicalStoreInput | StockTransactionUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type CompanyUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<CompanyCreateWithoutMedicalStoreInput, CompanyUncheckedCreateWithoutMedicalStoreInput> | CompanyCreateWithoutMedicalStoreInput[] | CompanyUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutMedicalStoreInput | CompanyCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutMedicalStoreInput | CompanyUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: CompanyCreateManyMedicalStoreInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutMedicalStoreInput | CompanyUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutMedicalStoreInput | CompanyUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<SupplierCreateWithoutMedicalStoreInput, SupplierUncheckedCreateWithoutMedicalStoreInput> | SupplierCreateWithoutMedicalStoreInput[] | SupplierUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutMedicalStoreInput | SupplierCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutMedicalStoreInput | SupplierUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: SupplierCreateManyMedicalStoreInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutMedicalStoreInput | SupplierUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutMedicalStoreInput | SupplierUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput> | MedicalStoreMedicineCreateWithoutMedicalStoreInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput | MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicalStoreInput | MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicalStoreInputEnvelope
    set?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    disconnect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    delete?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    update?: MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicalStoreInput | MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: MedicalStoreMedicineUpdateManyWithWhereWithoutMedicalStoreInput | MedicalStoreMedicineUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: MedicalStoreMedicineScalarWhereInput | MedicalStoreMedicineScalarWhereInput[]
  }

  export type MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicalStoreInput, MedicineLocationUncheckedCreateWithoutMedicalStoreInput> | MedicineLocationCreateWithoutMedicalStoreInput[] | MedicineLocationUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicalStoreInput | MedicineLocationCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: MedicineLocationUpsertWithWhereUniqueWithoutMedicalStoreInput | MedicineLocationUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: MedicineLocationCreateManyMedicalStoreInputEnvelope
    set?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    disconnect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    delete?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    update?: MedicineLocationUpdateWithWhereUniqueWithoutMedicalStoreInput | MedicineLocationUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: MedicineLocationUpdateManyWithWhereWithoutMedicalStoreInput | MedicineLocationUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutMedicalStoreInput, PurchaseOrderUncheckedCreateWithoutMedicalStoreInput> | PurchaseOrderCreateWithoutMedicalStoreInput[] | PurchaseOrderUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutMedicalStoreInput | PurchaseOrderCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutMedicalStoreInput | PurchaseOrderUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: PurchaseOrderCreateManyMedicalStoreInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutMedicalStoreInput | PurchaseOrderUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutMedicalStoreInput | PurchaseOrderUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<StockTransactionCreateWithoutMedicalStoreInput, StockTransactionUncheckedCreateWithoutMedicalStoreInput> | StockTransactionCreateWithoutMedicalStoreInput[] | StockTransactionUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicalStoreInput | StockTransactionCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutMedicalStoreInput | StockTransactionUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: StockTransactionCreateManyMedicalStoreInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutMedicalStoreInput | StockTransactionUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutMedicalStoreInput | StockTransactionUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<CompanyCreateWithoutMedicalStoreInput, CompanyUncheckedCreateWithoutMedicalStoreInput> | CompanyCreateWithoutMedicalStoreInput[] | CompanyUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutMedicalStoreInput | CompanyCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutMedicalStoreInput | CompanyUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: CompanyCreateManyMedicalStoreInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutMedicalStoreInput | CompanyUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutMedicalStoreInput | CompanyUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput = {
    create?: XOR<SupplierCreateWithoutMedicalStoreInput, SupplierUncheckedCreateWithoutMedicalStoreInput> | SupplierCreateWithoutMedicalStoreInput[] | SupplierUncheckedCreateWithoutMedicalStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutMedicalStoreInput | SupplierCreateOrConnectWithoutMedicalStoreInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutMedicalStoreInput | SupplierUpsertWithWhereUniqueWithoutMedicalStoreInput[]
    createMany?: SupplierCreateManyMedicalStoreInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutMedicalStoreInput | SupplierUpdateWithWhereUniqueWithoutMedicalStoreInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutMedicalStoreInput | SupplierUpdateManyWithWhereWithoutMedicalStoreInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type MedicalStoreCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<MedicalStoreCreateWithoutCompaniesInput, MedicalStoreUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutCompaniesInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type SupplierCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type MedicineCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MedicineCreateWithoutCompanyInput, MedicineUncheckedCreateWithoutCompanyInput> | MedicineCreateWithoutCompanyInput[] | MedicineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutCompanyInput | MedicineCreateOrConnectWithoutCompanyInput[]
    createMany?: MedicineCreateManyCompanyInputEnvelope
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type MedicineUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MedicineCreateWithoutCompanyInput, MedicineUncheckedCreateWithoutCompanyInput> | MedicineCreateWithoutCompanyInput[] | MedicineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutCompanyInput | MedicineCreateOrConnectWithoutCompanyInput[]
    createMany?: MedicineCreateManyCompanyInputEnvelope
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MedicalStoreUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutCompaniesInput, MedicalStoreUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutCompaniesInput
    upsert?: MedicalStoreUpsertWithoutCompaniesInput
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutCompaniesInput, MedicalStoreUpdateWithoutCompaniesInput>, MedicalStoreUncheckedUpdateWithoutCompaniesInput>
  }

  export type SupplierUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutCompanyInput | SupplierUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutCompanyInput | SupplierUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutCompanyInput | SupplierUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type MedicineUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MedicineCreateWithoutCompanyInput, MedicineUncheckedCreateWithoutCompanyInput> | MedicineCreateWithoutCompanyInput[] | MedicineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutCompanyInput | MedicineCreateOrConnectWithoutCompanyInput[]
    upsert?: MedicineUpsertWithWhereUniqueWithoutCompanyInput | MedicineUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MedicineCreateManyCompanyInputEnvelope
    set?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    disconnect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    delete?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    update?: MedicineUpdateWithWhereUniqueWithoutCompanyInput | MedicineUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MedicineUpdateManyWithWhereWithoutCompanyInput | MedicineUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MedicineScalarWhereInput | MedicineScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutCompanyInput | SupplierUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutCompanyInput | SupplierUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutCompanyInput | SupplierUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type MedicineUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MedicineCreateWithoutCompanyInput, MedicineUncheckedCreateWithoutCompanyInput> | MedicineCreateWithoutCompanyInput[] | MedicineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutCompanyInput | MedicineCreateOrConnectWithoutCompanyInput[]
    upsert?: MedicineUpsertWithWhereUniqueWithoutCompanyInput | MedicineUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MedicineCreateManyCompanyInputEnvelope
    set?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    disconnect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    delete?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    update?: MedicineUpdateWithWhereUniqueWithoutCompanyInput | MedicineUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MedicineUpdateManyWithWhereWithoutCompanyInput | MedicineUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MedicineScalarWhereInput | MedicineScalarWhereInput[]
  }

  export type MedicalStoreCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<MedicalStoreCreateWithoutSuppliersInput, MedicalStoreUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutSuppliersInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSuppliersInput
    connect?: CompanyWhereUniqueInput
  }

  export type MedicineCreateNestedManyWithoutSupplierInput = {
    create?: XOR<MedicineCreateWithoutSupplierInput, MedicineUncheckedCreateWithoutSupplierInput> | MedicineCreateWithoutSupplierInput[] | MedicineUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutSupplierInput | MedicineCreateOrConnectWithoutSupplierInput[]
    createMany?: MedicineCreateManySupplierInputEnvelope
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MedicineUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<MedicineCreateWithoutSupplierInput, MedicineUncheckedCreateWithoutSupplierInput> | MedicineCreateWithoutSupplierInput[] | MedicineUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutSupplierInput | MedicineCreateOrConnectWithoutSupplierInput[]
    createMany?: MedicineCreateManySupplierInputEnvelope
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type MedicalStoreUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutSuppliersInput, MedicalStoreUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutSuppliersInput
    upsert?: MedicalStoreUpsertWithoutSuppliersInput
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutSuppliersInput, MedicalStoreUpdateWithoutSuppliersInput>, MedicalStoreUncheckedUpdateWithoutSuppliersInput>
  }

  export type CompanyUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSuppliersInput
    upsert?: CompanyUpsertWithoutSuppliersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSuppliersInput, CompanyUpdateWithoutSuppliersInput>, CompanyUncheckedUpdateWithoutSuppliersInput>
  }

  export type MedicineUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<MedicineCreateWithoutSupplierInput, MedicineUncheckedCreateWithoutSupplierInput> | MedicineCreateWithoutSupplierInput[] | MedicineUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutSupplierInput | MedicineCreateOrConnectWithoutSupplierInput[]
    upsert?: MedicineUpsertWithWhereUniqueWithoutSupplierInput | MedicineUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: MedicineCreateManySupplierInputEnvelope
    set?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    disconnect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    delete?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    update?: MedicineUpdateWithWhereUniqueWithoutSupplierInput | MedicineUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: MedicineUpdateManyWithWhereWithoutSupplierInput | MedicineUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: MedicineScalarWhereInput | MedicineScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type MedicineUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<MedicineCreateWithoutSupplierInput, MedicineUncheckedCreateWithoutSupplierInput> | MedicineCreateWithoutSupplierInput[] | MedicineUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MedicineCreateOrConnectWithoutSupplierInput | MedicineCreateOrConnectWithoutSupplierInput[]
    upsert?: MedicineUpsertWithWhereUniqueWithoutSupplierInput | MedicineUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: MedicineCreateManySupplierInputEnvelope
    set?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    disconnect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    delete?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    connect?: MedicineWhereUniqueInput | MedicineWhereUniqueInput[]
    update?: MedicineUpdateWithWhereUniqueWithoutSupplierInput | MedicineUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: MedicineUpdateManyWithWhereWithoutSupplierInput | MedicineUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: MedicineScalarWhereInput | MedicineScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutMedicinesInput = {
    create?: XOR<CompanyCreateWithoutMedicinesInput, CompanyUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMedicinesInput
    connect?: CompanyWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutMedicinesInput = {
    create?: XOR<SupplierCreateWithoutMedicinesInput, SupplierUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutMedicinesInput
    connect?: SupplierWhereUniqueInput
  }

  export type VariationCreateNestedManyWithoutMedicineInput = {
    create?: XOR<VariationCreateWithoutMedicineInput, VariationUncheckedCreateWithoutMedicineInput> | VariationCreateWithoutMedicineInput[] | VariationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutMedicineInput | VariationCreateOrConnectWithoutMedicineInput[]
    createMany?: VariationCreateManyMedicineInputEnvelope
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
  }

  export type MedicineLocationCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicineInput, MedicineLocationUncheckedCreateWithoutMedicineInput> | MedicineLocationCreateWithoutMedicineInput[] | MedicineLocationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicineInput | MedicineLocationCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicineLocationCreateManyMedicineInputEnvelope
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
  }

  export type MedicalStoreMedicineCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicineInput, MedicalStoreMedicineUncheckedCreateWithoutMedicineInput> | MedicalStoreMedicineCreateWithoutMedicineInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicineInput | MedicalStoreMedicineCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicineInputEnvelope
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
  }

  export type MedicineExpiryCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicineExpiryCreateWithoutMedicineInput, MedicineExpiryUncheckedCreateWithoutMedicineInput> | MedicineExpiryCreateWithoutMedicineInput[] | MedicineExpiryUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineExpiryCreateOrConnectWithoutMedicineInput | MedicineExpiryCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicineExpiryCreateManyMedicineInputEnvelope
    connect?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
  }

  export type SoldItemsCreateNestedManyWithoutMedicineInput = {
    create?: XOR<SoldItemsCreateWithoutMedicineInput, SoldItemsUncheckedCreateWithoutMedicineInput> | SoldItemsCreateWithoutMedicineInput[] | SoldItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutMedicineInput | SoldItemsCreateOrConnectWithoutMedicineInput[]
    createMany?: SoldItemsCreateManyMedicineInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsCreateNestedManyWithoutMedicineInput = {
    create?: XOR<ReturnedItemsCreateWithoutMedicineInput, ReturnedItemsUncheckedCreateWithoutMedicineInput> | ReturnedItemsCreateWithoutMedicineInput[] | ReturnedItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutMedicineInput | ReturnedItemsCreateOrConnectWithoutMedicineInput[]
    createMany?: ReturnedItemsCreateManyMedicineInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type VariationUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<VariationCreateWithoutMedicineInput, VariationUncheckedCreateWithoutMedicineInput> | VariationCreateWithoutMedicineInput[] | VariationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutMedicineInput | VariationCreateOrConnectWithoutMedicineInput[]
    createMany?: VariationCreateManyMedicineInputEnvelope
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
  }

  export type MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicineInput, MedicineLocationUncheckedCreateWithoutMedicineInput> | MedicineLocationCreateWithoutMedicineInput[] | MedicineLocationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicineInput | MedicineLocationCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicineLocationCreateManyMedicineInputEnvelope
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
  }

  export type MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicineInput, MedicalStoreMedicineUncheckedCreateWithoutMedicineInput> | MedicalStoreMedicineCreateWithoutMedicineInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicineInput | MedicalStoreMedicineCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicineInputEnvelope
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
  }

  export type MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicineExpiryCreateWithoutMedicineInput, MedicineExpiryUncheckedCreateWithoutMedicineInput> | MedicineExpiryCreateWithoutMedicineInput[] | MedicineExpiryUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineExpiryCreateOrConnectWithoutMedicineInput | MedicineExpiryCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicineExpiryCreateManyMedicineInputEnvelope
    connect?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
  }

  export type SoldItemsUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<SoldItemsCreateWithoutMedicineInput, SoldItemsUncheckedCreateWithoutMedicineInput> | SoldItemsCreateWithoutMedicineInput[] | SoldItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutMedicineInput | SoldItemsCreateOrConnectWithoutMedicineInput[]
    createMany?: SoldItemsCreateManyMedicineInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<ReturnedItemsCreateWithoutMedicineInput, ReturnedItemsUncheckedCreateWithoutMedicineInput> | ReturnedItemsCreateWithoutMedicineInput[] | ReturnedItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutMedicineInput | ReturnedItemsCreateOrConnectWithoutMedicineInput[]
    createMany?: ReturnedItemsCreateManyMedicineInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutMedicinesNestedInput = {
    create?: XOR<CompanyCreateWithoutMedicinesInput, CompanyUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMedicinesInput
    upsert?: CompanyUpsertWithoutMedicinesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutMedicinesInput, CompanyUpdateWithoutMedicinesInput>, CompanyUncheckedUpdateWithoutMedicinesInput>
  }

  export type SupplierUpdateOneRequiredWithoutMedicinesNestedInput = {
    create?: XOR<SupplierCreateWithoutMedicinesInput, SupplierUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutMedicinesInput
    upsert?: SupplierUpsertWithoutMedicinesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutMedicinesInput, SupplierUpdateWithoutMedicinesInput>, SupplierUncheckedUpdateWithoutMedicinesInput>
  }

  export type VariationUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<VariationCreateWithoutMedicineInput, VariationUncheckedCreateWithoutMedicineInput> | VariationCreateWithoutMedicineInput[] | VariationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutMedicineInput | VariationCreateOrConnectWithoutMedicineInput[]
    upsert?: VariationUpsertWithWhereUniqueWithoutMedicineInput | VariationUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: VariationCreateManyMedicineInputEnvelope
    set?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    disconnect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    delete?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    update?: VariationUpdateWithWhereUniqueWithoutMedicineInput | VariationUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: VariationUpdateManyWithWhereWithoutMedicineInput | VariationUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: VariationScalarWhereInput | VariationScalarWhereInput[]
  }

  export type MedicineLocationUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicineInput, MedicineLocationUncheckedCreateWithoutMedicineInput> | MedicineLocationCreateWithoutMedicineInput[] | MedicineLocationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicineInput | MedicineLocationCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicineLocationUpsertWithWhereUniqueWithoutMedicineInput | MedicineLocationUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicineLocationCreateManyMedicineInputEnvelope
    set?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    disconnect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    delete?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    update?: MedicineLocationUpdateWithWhereUniqueWithoutMedicineInput | MedicineLocationUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicineLocationUpdateManyWithWhereWithoutMedicineInput | MedicineLocationUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
  }

  export type MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicineInput, MedicalStoreMedicineUncheckedCreateWithoutMedicineInput> | MedicalStoreMedicineCreateWithoutMedicineInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicineInput | MedicalStoreMedicineCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicineInput | MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicineInputEnvelope
    set?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    disconnect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    delete?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    update?: MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicineInput | MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicalStoreMedicineUpdateManyWithWhereWithoutMedicineInput | MedicalStoreMedicineUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicalStoreMedicineScalarWhereInput | MedicalStoreMedicineScalarWhereInput[]
  }

  export type MedicineExpiryUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicineExpiryCreateWithoutMedicineInput, MedicineExpiryUncheckedCreateWithoutMedicineInput> | MedicineExpiryCreateWithoutMedicineInput[] | MedicineExpiryUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineExpiryCreateOrConnectWithoutMedicineInput | MedicineExpiryCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicineExpiryUpsertWithWhereUniqueWithoutMedicineInput | MedicineExpiryUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicineExpiryCreateManyMedicineInputEnvelope
    set?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    disconnect?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    delete?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    connect?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    update?: MedicineExpiryUpdateWithWhereUniqueWithoutMedicineInput | MedicineExpiryUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicineExpiryUpdateManyWithWhereWithoutMedicineInput | MedicineExpiryUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicineExpiryScalarWhereInput | MedicineExpiryScalarWhereInput[]
  }

  export type SoldItemsUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<SoldItemsCreateWithoutMedicineInput, SoldItemsUncheckedCreateWithoutMedicineInput> | SoldItemsCreateWithoutMedicineInput[] | SoldItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutMedicineInput | SoldItemsCreateOrConnectWithoutMedicineInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutMedicineInput | SoldItemsUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: SoldItemsCreateManyMedicineInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutMedicineInput | SoldItemsUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutMedicineInput | SoldItemsUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutMedicineInput, ReturnedItemsUncheckedCreateWithoutMedicineInput> | ReturnedItemsCreateWithoutMedicineInput[] | ReturnedItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutMedicineInput | ReturnedItemsCreateOrConnectWithoutMedicineInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutMedicineInput | ReturnedItemsUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: ReturnedItemsCreateManyMedicineInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutMedicineInput | ReturnedItemsUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutMedicineInput | ReturnedItemsUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type VariationUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<VariationCreateWithoutMedicineInput, VariationUncheckedCreateWithoutMedicineInput> | VariationCreateWithoutMedicineInput[] | VariationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutMedicineInput | VariationCreateOrConnectWithoutMedicineInput[]
    upsert?: VariationUpsertWithWhereUniqueWithoutMedicineInput | VariationUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: VariationCreateManyMedicineInputEnvelope
    set?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    disconnect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    delete?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    update?: VariationUpdateWithWhereUniqueWithoutMedicineInput | VariationUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: VariationUpdateManyWithWhereWithoutMedicineInput | VariationUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: VariationScalarWhereInput | VariationScalarWhereInput[]
  }

  export type MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicineLocationCreateWithoutMedicineInput, MedicineLocationUncheckedCreateWithoutMedicineInput> | MedicineLocationCreateWithoutMedicineInput[] | MedicineLocationUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutMedicineInput | MedicineLocationCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicineLocationUpsertWithWhereUniqueWithoutMedicineInput | MedicineLocationUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicineLocationCreateManyMedicineInputEnvelope
    set?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    disconnect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    delete?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    update?: MedicineLocationUpdateWithWhereUniqueWithoutMedicineInput | MedicineLocationUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicineLocationUpdateManyWithWhereWithoutMedicineInput | MedicineLocationUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
  }

  export type MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicalStoreMedicineCreateWithoutMedicineInput, MedicalStoreMedicineUncheckedCreateWithoutMedicineInput> | MedicalStoreMedicineCreateWithoutMedicineInput[] | MedicalStoreMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicalStoreMedicineCreateOrConnectWithoutMedicineInput | MedicalStoreMedicineCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicineInput | MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicalStoreMedicineCreateManyMedicineInputEnvelope
    set?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    disconnect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    delete?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    connect?: MedicalStoreMedicineWhereUniqueInput | MedicalStoreMedicineWhereUniqueInput[]
    update?: MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicineInput | MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicalStoreMedicineUpdateManyWithWhereWithoutMedicineInput | MedicalStoreMedicineUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicalStoreMedicineScalarWhereInput | MedicalStoreMedicineScalarWhereInput[]
  }

  export type MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicineExpiryCreateWithoutMedicineInput, MedicineExpiryUncheckedCreateWithoutMedicineInput> | MedicineExpiryCreateWithoutMedicineInput[] | MedicineExpiryUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineExpiryCreateOrConnectWithoutMedicineInput | MedicineExpiryCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicineExpiryUpsertWithWhereUniqueWithoutMedicineInput | MedicineExpiryUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicineExpiryCreateManyMedicineInputEnvelope
    set?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    disconnect?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    delete?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    connect?: MedicineExpiryWhereUniqueInput | MedicineExpiryWhereUniqueInput[]
    update?: MedicineExpiryUpdateWithWhereUniqueWithoutMedicineInput | MedicineExpiryUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicineExpiryUpdateManyWithWhereWithoutMedicineInput | MedicineExpiryUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicineExpiryScalarWhereInput | MedicineExpiryScalarWhereInput[]
  }

  export type SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<SoldItemsCreateWithoutMedicineInput, SoldItemsUncheckedCreateWithoutMedicineInput> | SoldItemsCreateWithoutMedicineInput[] | SoldItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutMedicineInput | SoldItemsCreateOrConnectWithoutMedicineInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutMedicineInput | SoldItemsUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: SoldItemsCreateManyMedicineInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutMedicineInput | SoldItemsUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutMedicineInput | SoldItemsUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutMedicineInput, ReturnedItemsUncheckedCreateWithoutMedicineInput> | ReturnedItemsCreateWithoutMedicineInput[] | ReturnedItemsUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutMedicineInput | ReturnedItemsCreateOrConnectWithoutMedicineInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutMedicineInput | ReturnedItemsUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: ReturnedItemsCreateManyMedicineInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutMedicineInput | ReturnedItemsUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutMedicineInput | ReturnedItemsUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type MedicineCreateNestedOneWithoutVariationsInput = {
    create?: XOR<MedicineCreateWithoutVariationsInput, MedicineUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutVariationsInput
    connect?: MedicineWhereUniqueInput
  }

  export type BatchCreateNestedManyWithoutVariationInput = {
    create?: XOR<BatchCreateWithoutVariationInput, BatchUncheckedCreateWithoutVariationInput> | BatchCreateWithoutVariationInput[] | BatchUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutVariationInput | BatchCreateOrConnectWithoutVariationInput[]
    createMany?: BatchCreateManyVariationInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type MedicineInstanceCreateNestedManyWithoutVariationInput = {
    create?: XOR<MedicineInstanceCreateWithoutVariationInput, MedicineInstanceUncheckedCreateWithoutVariationInput> | MedicineInstanceCreateWithoutVariationInput[] | MedicineInstanceUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutVariationInput | MedicineInstanceCreateOrConnectWithoutVariationInput[]
    createMany?: MedicineInstanceCreateManyVariationInputEnvelope
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutVariationInput = {
    create?: XOR<BatchCreateWithoutVariationInput, BatchUncheckedCreateWithoutVariationInput> | BatchCreateWithoutVariationInput[] | BatchUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutVariationInput | BatchCreateOrConnectWithoutVariationInput[]
    createMany?: BatchCreateManyVariationInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type MedicineInstanceUncheckedCreateNestedManyWithoutVariationInput = {
    create?: XOR<MedicineInstanceCreateWithoutVariationInput, MedicineInstanceUncheckedCreateWithoutVariationInput> | MedicineInstanceCreateWithoutVariationInput[] | MedicineInstanceUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutVariationInput | MedicineInstanceCreateOrConnectWithoutVariationInput[]
    createMany?: MedicineInstanceCreateManyVariationInputEnvelope
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
  }

  export type MedicineUpdateOneRequiredWithoutVariationsNestedInput = {
    create?: XOR<MedicineCreateWithoutVariationsInput, MedicineUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutVariationsInput
    upsert?: MedicineUpsertWithoutVariationsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutVariationsInput, MedicineUpdateWithoutVariationsInput>, MedicineUncheckedUpdateWithoutVariationsInput>
  }

  export type BatchUpdateManyWithoutVariationNestedInput = {
    create?: XOR<BatchCreateWithoutVariationInput, BatchUncheckedCreateWithoutVariationInput> | BatchCreateWithoutVariationInput[] | BatchUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutVariationInput | BatchCreateOrConnectWithoutVariationInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutVariationInput | BatchUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: BatchCreateManyVariationInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutVariationInput | BatchUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutVariationInput | BatchUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type MedicineInstanceUpdateManyWithoutVariationNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutVariationInput, MedicineInstanceUncheckedCreateWithoutVariationInput> | MedicineInstanceCreateWithoutVariationInput[] | MedicineInstanceUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutVariationInput | MedicineInstanceCreateOrConnectWithoutVariationInput[]
    upsert?: MedicineInstanceUpsertWithWhereUniqueWithoutVariationInput | MedicineInstanceUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: MedicineInstanceCreateManyVariationInputEnvelope
    set?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    disconnect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    delete?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    update?: MedicineInstanceUpdateWithWhereUniqueWithoutVariationInput | MedicineInstanceUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: MedicineInstanceUpdateManyWithWhereWithoutVariationInput | MedicineInstanceUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: MedicineInstanceScalarWhereInput | MedicineInstanceScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutVariationNestedInput = {
    create?: XOR<BatchCreateWithoutVariationInput, BatchUncheckedCreateWithoutVariationInput> | BatchCreateWithoutVariationInput[] | BatchUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutVariationInput | BatchCreateOrConnectWithoutVariationInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutVariationInput | BatchUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: BatchCreateManyVariationInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutVariationInput | BatchUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutVariationInput | BatchUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type MedicineInstanceUncheckedUpdateManyWithoutVariationNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutVariationInput, MedicineInstanceUncheckedCreateWithoutVariationInput> | MedicineInstanceCreateWithoutVariationInput[] | MedicineInstanceUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutVariationInput | MedicineInstanceCreateOrConnectWithoutVariationInput[]
    upsert?: MedicineInstanceUpsertWithWhereUniqueWithoutVariationInput | MedicineInstanceUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: MedicineInstanceCreateManyVariationInputEnvelope
    set?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    disconnect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    delete?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    update?: MedicineInstanceUpdateWithWhereUniqueWithoutVariationInput | MedicineInstanceUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: MedicineInstanceUpdateManyWithWhereWithoutVariationInput | MedicineInstanceUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: MedicineInstanceScalarWhereInput | MedicineInstanceScalarWhereInput[]
  }

  export type VariationCreateNestedOneWithoutBatchesInput = {
    create?: XOR<VariationCreateWithoutBatchesInput, VariationUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: VariationCreateOrConnectWithoutBatchesInput
    connect?: VariationWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutBatchesInput = {
    create?: XOR<PurchaseOrderCreateWithoutBatchesInput, PurchaseOrderUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutBatchesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type MedicineInstanceCreateNestedManyWithoutBatchInput = {
    create?: XOR<MedicineInstanceCreateWithoutBatchInput, MedicineInstanceUncheckedCreateWithoutBatchInput> | MedicineInstanceCreateWithoutBatchInput[] | MedicineInstanceUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutBatchInput | MedicineInstanceCreateOrConnectWithoutBatchInput[]
    createMany?: MedicineInstanceCreateManyBatchInputEnvelope
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
  }

  export type SoldItemsCreateNestedManyWithoutBatchInput = {
    create?: XOR<SoldItemsCreateWithoutBatchInput, SoldItemsUncheckedCreateWithoutBatchInput> | SoldItemsCreateWithoutBatchInput[] | SoldItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutBatchInput | SoldItemsCreateOrConnectWithoutBatchInput[]
    createMany?: SoldItemsCreateManyBatchInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsCreateNestedManyWithoutBatchInput = {
    create?: XOR<ReturnedItemsCreateWithoutBatchInput, ReturnedItemsUncheckedCreateWithoutBatchInput> | ReturnedItemsCreateWithoutBatchInput[] | ReturnedItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutBatchInput | ReturnedItemsCreateOrConnectWithoutBatchInput[]
    createMany?: ReturnedItemsCreateManyBatchInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type MedicineInstanceUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<MedicineInstanceCreateWithoutBatchInput, MedicineInstanceUncheckedCreateWithoutBatchInput> | MedicineInstanceCreateWithoutBatchInput[] | MedicineInstanceUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutBatchInput | MedicineInstanceCreateOrConnectWithoutBatchInput[]
    createMany?: MedicineInstanceCreateManyBatchInputEnvelope
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
  }

  export type SoldItemsUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<SoldItemsCreateWithoutBatchInput, SoldItemsUncheckedCreateWithoutBatchInput> | SoldItemsCreateWithoutBatchInput[] | SoldItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutBatchInput | SoldItemsCreateOrConnectWithoutBatchInput[]
    createMany?: SoldItemsCreateManyBatchInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<ReturnedItemsCreateWithoutBatchInput, ReturnedItemsUncheckedCreateWithoutBatchInput> | ReturnedItemsCreateWithoutBatchInput[] | ReturnedItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutBatchInput | ReturnedItemsCreateOrConnectWithoutBatchInput[]
    createMany?: ReturnedItemsCreateManyBatchInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VariationUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<VariationCreateWithoutBatchesInput, VariationUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: VariationCreateOrConnectWithoutBatchesInput
    upsert?: VariationUpsertWithoutBatchesInput
    connect?: VariationWhereUniqueInput
    update?: XOR<XOR<VariationUpdateToOneWithWhereWithoutBatchesInput, VariationUpdateWithoutBatchesInput>, VariationUncheckedUpdateWithoutBatchesInput>
  }

  export type PurchaseOrderUpdateOneWithoutBatchesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutBatchesInput, PurchaseOrderUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutBatchesInput
    upsert?: PurchaseOrderUpsertWithoutBatchesInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutBatchesInput, PurchaseOrderUpdateWithoutBatchesInput>, PurchaseOrderUncheckedUpdateWithoutBatchesInput>
  }

  export type MedicineInstanceUpdateManyWithoutBatchNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutBatchInput, MedicineInstanceUncheckedCreateWithoutBatchInput> | MedicineInstanceCreateWithoutBatchInput[] | MedicineInstanceUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutBatchInput | MedicineInstanceCreateOrConnectWithoutBatchInput[]
    upsert?: MedicineInstanceUpsertWithWhereUniqueWithoutBatchInput | MedicineInstanceUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: MedicineInstanceCreateManyBatchInputEnvelope
    set?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    disconnect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    delete?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    update?: MedicineInstanceUpdateWithWhereUniqueWithoutBatchInput | MedicineInstanceUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: MedicineInstanceUpdateManyWithWhereWithoutBatchInput | MedicineInstanceUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: MedicineInstanceScalarWhereInput | MedicineInstanceScalarWhereInput[]
  }

  export type SoldItemsUpdateManyWithoutBatchNestedInput = {
    create?: XOR<SoldItemsCreateWithoutBatchInput, SoldItemsUncheckedCreateWithoutBatchInput> | SoldItemsCreateWithoutBatchInput[] | SoldItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutBatchInput | SoldItemsCreateOrConnectWithoutBatchInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutBatchInput | SoldItemsUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: SoldItemsCreateManyBatchInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutBatchInput | SoldItemsUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutBatchInput | SoldItemsUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutBatchInput, ReturnedItemsUncheckedCreateWithoutBatchInput> | ReturnedItemsCreateWithoutBatchInput[] | ReturnedItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutBatchInput | ReturnedItemsCreateOrConnectWithoutBatchInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutBatchInput | ReturnedItemsUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ReturnedItemsCreateManyBatchInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutBatchInput | ReturnedItemsUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutBatchInput | ReturnedItemsUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type MedicineInstanceUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutBatchInput, MedicineInstanceUncheckedCreateWithoutBatchInput> | MedicineInstanceCreateWithoutBatchInput[] | MedicineInstanceUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutBatchInput | MedicineInstanceCreateOrConnectWithoutBatchInput[]
    upsert?: MedicineInstanceUpsertWithWhereUniqueWithoutBatchInput | MedicineInstanceUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: MedicineInstanceCreateManyBatchInputEnvelope
    set?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    disconnect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    delete?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    connect?: MedicineInstanceWhereUniqueInput | MedicineInstanceWhereUniqueInput[]
    update?: MedicineInstanceUpdateWithWhereUniqueWithoutBatchInput | MedicineInstanceUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: MedicineInstanceUpdateManyWithWhereWithoutBatchInput | MedicineInstanceUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: MedicineInstanceScalarWhereInput | MedicineInstanceScalarWhereInput[]
  }

  export type SoldItemsUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<SoldItemsCreateWithoutBatchInput, SoldItemsUncheckedCreateWithoutBatchInput> | SoldItemsCreateWithoutBatchInput[] | SoldItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutBatchInput | SoldItemsCreateOrConnectWithoutBatchInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutBatchInput | SoldItemsUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: SoldItemsCreateManyBatchInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutBatchInput | SoldItemsUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutBatchInput | SoldItemsUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutBatchInput, ReturnedItemsUncheckedCreateWithoutBatchInput> | ReturnedItemsCreateWithoutBatchInput[] | ReturnedItemsUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutBatchInput | ReturnedItemsCreateOrConnectWithoutBatchInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutBatchInput | ReturnedItemsUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ReturnedItemsCreateManyBatchInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutBatchInput | ReturnedItemsUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutBatchInput | ReturnedItemsUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type VariationCreateNestedOneWithoutInstancesInput = {
    create?: XOR<VariationCreateWithoutInstancesInput, VariationUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: VariationCreateOrConnectWithoutInstancesInput
    connect?: VariationWhereUniqueInput
  }

  export type BatchCreateNestedOneWithoutInstancesInput = {
    create?: XOR<BatchCreateWithoutInstancesInput, BatchUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutInstancesInput
    connect?: BatchWhereUniqueInput
  }

  export type MedicineLocationCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MedicineLocationCreateWithoutInstanceInput, MedicineLocationUncheckedCreateWithoutInstanceInput> | MedicineLocationCreateWithoutInstanceInput[] | MedicineLocationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutInstanceInput | MedicineLocationCreateOrConnectWithoutInstanceInput[]
    createMany?: MedicineLocationCreateManyInstanceInputEnvelope
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
  }

  export type SubUnitCreateNestedManyWithoutInstanceInput = {
    create?: XOR<SubUnitCreateWithoutInstanceInput, SubUnitUncheckedCreateWithoutInstanceInput> | SubUnitCreateWithoutInstanceInput[] | SubUnitUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: SubUnitCreateOrConnectWithoutInstanceInput | SubUnitCreateOrConnectWithoutInstanceInput[]
    createMany?: SubUnitCreateManyInstanceInputEnvelope
    connect?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
  }

  export type StockTransactionCreateNestedManyWithoutMedicineInstanceInput = {
    create?: XOR<StockTransactionCreateWithoutMedicineInstanceInput, StockTransactionUncheckedCreateWithoutMedicineInstanceInput> | StockTransactionCreateWithoutMedicineInstanceInput[] | StockTransactionUncheckedCreateWithoutMedicineInstanceInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicineInstanceInput | StockTransactionCreateOrConnectWithoutMedicineInstanceInput[]
    createMany?: StockTransactionCreateManyMedicineInstanceInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type MedicineLocationUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MedicineLocationCreateWithoutInstanceInput, MedicineLocationUncheckedCreateWithoutInstanceInput> | MedicineLocationCreateWithoutInstanceInput[] | MedicineLocationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutInstanceInput | MedicineLocationCreateOrConnectWithoutInstanceInput[]
    createMany?: MedicineLocationCreateManyInstanceInputEnvelope
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
  }

  export type SubUnitUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<SubUnitCreateWithoutInstanceInput, SubUnitUncheckedCreateWithoutInstanceInput> | SubUnitCreateWithoutInstanceInput[] | SubUnitUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: SubUnitCreateOrConnectWithoutInstanceInput | SubUnitCreateOrConnectWithoutInstanceInput[]
    createMany?: SubUnitCreateManyInstanceInputEnvelope
    connect?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutMedicineInstanceInput = {
    create?: XOR<StockTransactionCreateWithoutMedicineInstanceInput, StockTransactionUncheckedCreateWithoutMedicineInstanceInput> | StockTransactionCreateWithoutMedicineInstanceInput[] | StockTransactionUncheckedCreateWithoutMedicineInstanceInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicineInstanceInput | StockTransactionCreateOrConnectWithoutMedicineInstanceInput[]
    createMany?: StockTransactionCreateManyMedicineInstanceInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type VariationUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<VariationCreateWithoutInstancesInput, VariationUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: VariationCreateOrConnectWithoutInstancesInput
    upsert?: VariationUpsertWithoutInstancesInput
    connect?: VariationWhereUniqueInput
    update?: XOR<XOR<VariationUpdateToOneWithWhereWithoutInstancesInput, VariationUpdateWithoutInstancesInput>, VariationUncheckedUpdateWithoutInstancesInput>
  }

  export type BatchUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<BatchCreateWithoutInstancesInput, BatchUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutInstancesInput
    upsert?: BatchUpsertWithoutInstancesInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutInstancesInput, BatchUpdateWithoutInstancesInput>, BatchUncheckedUpdateWithoutInstancesInput>
  }

  export type MedicineLocationUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MedicineLocationCreateWithoutInstanceInput, MedicineLocationUncheckedCreateWithoutInstanceInput> | MedicineLocationCreateWithoutInstanceInput[] | MedicineLocationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutInstanceInput | MedicineLocationCreateOrConnectWithoutInstanceInput[]
    upsert?: MedicineLocationUpsertWithWhereUniqueWithoutInstanceInput | MedicineLocationUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MedicineLocationCreateManyInstanceInputEnvelope
    set?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    disconnect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    delete?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    update?: MedicineLocationUpdateWithWhereUniqueWithoutInstanceInput | MedicineLocationUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MedicineLocationUpdateManyWithWhereWithoutInstanceInput | MedicineLocationUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
  }

  export type SubUnitUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<SubUnitCreateWithoutInstanceInput, SubUnitUncheckedCreateWithoutInstanceInput> | SubUnitCreateWithoutInstanceInput[] | SubUnitUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: SubUnitCreateOrConnectWithoutInstanceInput | SubUnitCreateOrConnectWithoutInstanceInput[]
    upsert?: SubUnitUpsertWithWhereUniqueWithoutInstanceInput | SubUnitUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: SubUnitCreateManyInstanceInputEnvelope
    set?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    disconnect?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    delete?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    connect?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    update?: SubUnitUpdateWithWhereUniqueWithoutInstanceInput | SubUnitUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: SubUnitUpdateManyWithWhereWithoutInstanceInput | SubUnitUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: SubUnitScalarWhereInput | SubUnitScalarWhereInput[]
  }

  export type StockTransactionUpdateManyWithoutMedicineInstanceNestedInput = {
    create?: XOR<StockTransactionCreateWithoutMedicineInstanceInput, StockTransactionUncheckedCreateWithoutMedicineInstanceInput> | StockTransactionCreateWithoutMedicineInstanceInput[] | StockTransactionUncheckedCreateWithoutMedicineInstanceInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicineInstanceInput | StockTransactionCreateOrConnectWithoutMedicineInstanceInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutMedicineInstanceInput | StockTransactionUpsertWithWhereUniqueWithoutMedicineInstanceInput[]
    createMany?: StockTransactionCreateManyMedicineInstanceInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutMedicineInstanceInput | StockTransactionUpdateWithWhereUniqueWithoutMedicineInstanceInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutMedicineInstanceInput | StockTransactionUpdateManyWithWhereWithoutMedicineInstanceInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type MedicineLocationUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MedicineLocationCreateWithoutInstanceInput, MedicineLocationUncheckedCreateWithoutInstanceInput> | MedicineLocationCreateWithoutInstanceInput[] | MedicineLocationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MedicineLocationCreateOrConnectWithoutInstanceInput | MedicineLocationCreateOrConnectWithoutInstanceInput[]
    upsert?: MedicineLocationUpsertWithWhereUniqueWithoutInstanceInput | MedicineLocationUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MedicineLocationCreateManyInstanceInputEnvelope
    set?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    disconnect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    delete?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    connect?: MedicineLocationWhereUniqueInput | MedicineLocationWhereUniqueInput[]
    update?: MedicineLocationUpdateWithWhereUniqueWithoutInstanceInput | MedicineLocationUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MedicineLocationUpdateManyWithWhereWithoutInstanceInput | MedicineLocationUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
  }

  export type SubUnitUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<SubUnitCreateWithoutInstanceInput, SubUnitUncheckedCreateWithoutInstanceInput> | SubUnitCreateWithoutInstanceInput[] | SubUnitUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: SubUnitCreateOrConnectWithoutInstanceInput | SubUnitCreateOrConnectWithoutInstanceInput[]
    upsert?: SubUnitUpsertWithWhereUniqueWithoutInstanceInput | SubUnitUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: SubUnitCreateManyInstanceInputEnvelope
    set?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    disconnect?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    delete?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    connect?: SubUnitWhereUniqueInput | SubUnitWhereUniqueInput[]
    update?: SubUnitUpdateWithWhereUniqueWithoutInstanceInput | SubUnitUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: SubUnitUpdateManyWithWhereWithoutInstanceInput | SubUnitUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: SubUnitScalarWhereInput | SubUnitScalarWhereInput[]
  }

  export type StockTransactionUncheckedUpdateManyWithoutMedicineInstanceNestedInput = {
    create?: XOR<StockTransactionCreateWithoutMedicineInstanceInput, StockTransactionUncheckedCreateWithoutMedicineInstanceInput> | StockTransactionCreateWithoutMedicineInstanceInput[] | StockTransactionUncheckedCreateWithoutMedicineInstanceInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutMedicineInstanceInput | StockTransactionCreateOrConnectWithoutMedicineInstanceInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutMedicineInstanceInput | StockTransactionUpsertWithWhereUniqueWithoutMedicineInstanceInput[]
    createMany?: StockTransactionCreateManyMedicineInstanceInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutMedicineInstanceInput | StockTransactionUpdateWithWhereUniqueWithoutMedicineInstanceInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutMedicineInstanceInput | StockTransactionUpdateManyWithWhereWithoutMedicineInstanceInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type MedicineInstanceCreateNestedOneWithoutSubunitsInput = {
    create?: XOR<MedicineInstanceCreateWithoutSubunitsInput, MedicineInstanceUncheckedCreateWithoutSubunitsInput>
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutSubunitsInput
    connect?: MedicineInstanceWhereUniqueInput
  }

  export type SoldItemsCreateNestedManyWithoutSubUnitInput = {
    create?: XOR<SoldItemsCreateWithoutSubUnitInput, SoldItemsUncheckedCreateWithoutSubUnitInput> | SoldItemsCreateWithoutSubUnitInput[] | SoldItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutSubUnitInput | SoldItemsCreateOrConnectWithoutSubUnitInput[]
    createMany?: SoldItemsCreateManySubUnitInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsCreateNestedManyWithoutSubUnitInput = {
    create?: XOR<ReturnedItemsCreateWithoutSubUnitInput, ReturnedItemsUncheckedCreateWithoutSubUnitInput> | ReturnedItemsCreateWithoutSubUnitInput[] | ReturnedItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutSubUnitInput | ReturnedItemsCreateOrConnectWithoutSubUnitInput[]
    createMany?: ReturnedItemsCreateManySubUnitInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type SoldItemsUncheckedCreateNestedManyWithoutSubUnitInput = {
    create?: XOR<SoldItemsCreateWithoutSubUnitInput, SoldItemsUncheckedCreateWithoutSubUnitInput> | SoldItemsCreateWithoutSubUnitInput[] | SoldItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutSubUnitInput | SoldItemsCreateOrConnectWithoutSubUnitInput[]
    createMany?: SoldItemsCreateManySubUnitInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsUncheckedCreateNestedManyWithoutSubUnitInput = {
    create?: XOR<ReturnedItemsCreateWithoutSubUnitInput, ReturnedItemsUncheckedCreateWithoutSubUnitInput> | ReturnedItemsCreateWithoutSubUnitInput[] | ReturnedItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutSubUnitInput | ReturnedItemsCreateOrConnectWithoutSubUnitInput[]
    createMany?: ReturnedItemsCreateManySubUnitInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type MedicineInstanceUpdateOneRequiredWithoutSubunitsNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutSubunitsInput, MedicineInstanceUncheckedCreateWithoutSubunitsInput>
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutSubunitsInput
    upsert?: MedicineInstanceUpsertWithoutSubunitsInput
    connect?: MedicineInstanceWhereUniqueInput
    update?: XOR<XOR<MedicineInstanceUpdateToOneWithWhereWithoutSubunitsInput, MedicineInstanceUpdateWithoutSubunitsInput>, MedicineInstanceUncheckedUpdateWithoutSubunitsInput>
  }

  export type SoldItemsUpdateManyWithoutSubUnitNestedInput = {
    create?: XOR<SoldItemsCreateWithoutSubUnitInput, SoldItemsUncheckedCreateWithoutSubUnitInput> | SoldItemsCreateWithoutSubUnitInput[] | SoldItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutSubUnitInput | SoldItemsCreateOrConnectWithoutSubUnitInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutSubUnitInput | SoldItemsUpsertWithWhereUniqueWithoutSubUnitInput[]
    createMany?: SoldItemsCreateManySubUnitInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutSubUnitInput | SoldItemsUpdateWithWhereUniqueWithoutSubUnitInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutSubUnitInput | SoldItemsUpdateManyWithWhereWithoutSubUnitInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUpdateManyWithoutSubUnitNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutSubUnitInput, ReturnedItemsUncheckedCreateWithoutSubUnitInput> | ReturnedItemsCreateWithoutSubUnitInput[] | ReturnedItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutSubUnitInput | ReturnedItemsCreateOrConnectWithoutSubUnitInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutSubUnitInput | ReturnedItemsUpsertWithWhereUniqueWithoutSubUnitInput[]
    createMany?: ReturnedItemsCreateManySubUnitInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutSubUnitInput | ReturnedItemsUpdateWithWhereUniqueWithoutSubUnitInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutSubUnitInput | ReturnedItemsUpdateManyWithWhereWithoutSubUnitInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type SoldItemsUncheckedUpdateManyWithoutSubUnitNestedInput = {
    create?: XOR<SoldItemsCreateWithoutSubUnitInput, SoldItemsUncheckedCreateWithoutSubUnitInput> | SoldItemsCreateWithoutSubUnitInput[] | SoldItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutSubUnitInput | SoldItemsCreateOrConnectWithoutSubUnitInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutSubUnitInput | SoldItemsUpsertWithWhereUniqueWithoutSubUnitInput[]
    createMany?: SoldItemsCreateManySubUnitInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutSubUnitInput | SoldItemsUpdateWithWhereUniqueWithoutSubUnitInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutSubUnitInput | SoldItemsUpdateManyWithWhereWithoutSubUnitInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutSubUnitNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutSubUnitInput, ReturnedItemsUncheckedCreateWithoutSubUnitInput> | ReturnedItemsCreateWithoutSubUnitInput[] | ReturnedItemsUncheckedCreateWithoutSubUnitInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutSubUnitInput | ReturnedItemsCreateOrConnectWithoutSubUnitInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutSubUnitInput | ReturnedItemsUpsertWithWhereUniqueWithoutSubUnitInput[]
    createMany?: ReturnedItemsCreateManySubUnitInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutSubUnitInput | ReturnedItemsUpdateWithWhereUniqueWithoutSubUnitInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutSubUnitInput | ReturnedItemsUpdateManyWithWhereWithoutSubUnitInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type MedicalStoreCreateNestedOneWithoutLocationsInput = {
    create?: XOR<MedicalStoreCreateWithoutLocationsInput, MedicalStoreUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutLocationsInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type MedicineCreateNestedOneWithoutLocationsInput = {
    create?: XOR<MedicineCreateWithoutLocationsInput, MedicineUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutLocationsInput
    connect?: MedicineWhereUniqueInput
  }

  export type MedicineInstanceCreateNestedOneWithoutLocationsInput = {
    create?: XOR<MedicineInstanceCreateWithoutLocationsInput, MedicineInstanceUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutLocationsInput
    connect?: MedicineInstanceWhereUniqueInput
  }

  export type MedicalStoreUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutLocationsInput, MedicalStoreUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutLocationsInput
    upsert?: MedicalStoreUpsertWithoutLocationsInput
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutLocationsInput, MedicalStoreUpdateWithoutLocationsInput>, MedicalStoreUncheckedUpdateWithoutLocationsInput>
  }

  export type MedicineUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<MedicineCreateWithoutLocationsInput, MedicineUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutLocationsInput
    upsert?: MedicineUpsertWithoutLocationsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutLocationsInput, MedicineUpdateWithoutLocationsInput>, MedicineUncheckedUpdateWithoutLocationsInput>
  }

  export type MedicineInstanceUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutLocationsInput, MedicineInstanceUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutLocationsInput
    upsert?: MedicineInstanceUpsertWithoutLocationsInput
    connect?: MedicineInstanceWhereUniqueInput
    update?: XOR<XOR<MedicineInstanceUpdateToOneWithWhereWithoutLocationsInput, MedicineInstanceUpdateWithoutLocationsInput>, MedicineInstanceUncheckedUpdateWithoutLocationsInput>
  }

  export type MedicalStoreCreateNestedOneWithoutMedicinesInput = {
    create?: XOR<MedicalStoreCreateWithoutMedicinesInput, MedicalStoreUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutMedicinesInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type MedicineCreateNestedOneWithoutMedicalStoreMedicinesInput = {
    create?: XOR<MedicineCreateWithoutMedicalStoreMedicinesInput, MedicineUncheckedCreateWithoutMedicalStoreMedicinesInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutMedicalStoreMedicinesInput
    connect?: MedicineWhereUniqueInput
  }

  export type MedicalStoreUpdateOneRequiredWithoutMedicinesNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutMedicinesInput, MedicalStoreUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutMedicinesInput
    upsert?: MedicalStoreUpsertWithoutMedicinesInput
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutMedicinesInput, MedicalStoreUpdateWithoutMedicinesInput>, MedicalStoreUncheckedUpdateWithoutMedicinesInput>
  }

  export type MedicineUpdateOneRequiredWithoutMedicalStoreMedicinesNestedInput = {
    create?: XOR<MedicineCreateWithoutMedicalStoreMedicinesInput, MedicineUncheckedCreateWithoutMedicalStoreMedicinesInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutMedicalStoreMedicinesInput
    upsert?: MedicineUpsertWithoutMedicalStoreMedicinesInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutMedicalStoreMedicinesInput, MedicineUpdateWithoutMedicalStoreMedicinesInput>, MedicineUncheckedUpdateWithoutMedicalStoreMedicinesInput>
  }

  export type MedicineCreateNestedOneWithoutExpiryRecordsInput = {
    create?: XOR<MedicineCreateWithoutExpiryRecordsInput, MedicineUncheckedCreateWithoutExpiryRecordsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutExpiryRecordsInput
    connect?: MedicineWhereUniqueInput
  }

  export type MedicineUpdateOneRequiredWithoutExpiryRecordsNestedInput = {
    create?: XOR<MedicineCreateWithoutExpiryRecordsInput, MedicineUncheckedCreateWithoutExpiryRecordsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutExpiryRecordsInput
    upsert?: MedicineUpsertWithoutExpiryRecordsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutExpiryRecordsInput, MedicineUpdateWithoutExpiryRecordsInput>, MedicineUncheckedUpdateWithoutExpiryRecordsInput>
  }

  export type MedicalStoreCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<MedicalStoreCreateWithoutStockTransactionsInput, MedicalStoreUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutStockTransactionsInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type MedicineInstanceCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<MedicineInstanceCreateWithoutStockTransactionsInput, MedicineInstanceUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutStockTransactionsInput
    connect?: MedicineInstanceWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<PurchaseOrderCreateWithoutStockTransactionsInput, PurchaseOrderUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStockTransactionsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type MedicalStoreUpdateOneRequiredWithoutStockTransactionsNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutStockTransactionsInput, MedicalStoreUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutStockTransactionsInput
    upsert?: MedicalStoreUpsertWithoutStockTransactionsInput
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutStockTransactionsInput, MedicalStoreUpdateWithoutStockTransactionsInput>, MedicalStoreUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type MedicineInstanceUpdateOneRequiredWithoutStockTransactionsNestedInput = {
    create?: XOR<MedicineInstanceCreateWithoutStockTransactionsInput, MedicineInstanceUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: MedicineInstanceCreateOrConnectWithoutStockTransactionsInput
    upsert?: MedicineInstanceUpsertWithoutStockTransactionsInput
    connect?: MedicineInstanceWhereUniqueInput
    update?: XOR<XOR<MedicineInstanceUpdateToOneWithWhereWithoutStockTransactionsInput, MedicineInstanceUpdateWithoutStockTransactionsInput>, MedicineInstanceUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type PurchaseOrderUpdateOneWithoutStockTransactionsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutStockTransactionsInput, PurchaseOrderUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStockTransactionsInput
    upsert?: PurchaseOrderUpsertWithoutStockTransactionsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutStockTransactionsInput, PurchaseOrderUpdateWithoutStockTransactionsInput>, PurchaseOrderUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type MedicalStoreCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<MedicalStoreCreateWithoutPurchaseOrdersInput, MedicalStoreUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutPurchaseOrdersInput
    connect?: MedicalStoreWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type BatchCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<BatchCreateWithoutPurchaseOrderInput, BatchUncheckedCreateWithoutPurchaseOrderInput> | BatchCreateWithoutPurchaseOrderInput[] | BatchUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutPurchaseOrderInput | BatchCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: BatchCreateManyPurchaseOrderInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type StockTransactionCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<StockTransactionCreateWithoutPurchaseOrderInput, StockTransactionUncheckedCreateWithoutPurchaseOrderInput> | StockTransactionCreateWithoutPurchaseOrderInput[] | StockTransactionUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutPurchaseOrderInput | StockTransactionCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: StockTransactionCreateManyPurchaseOrderInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<BatchCreateWithoutPurchaseOrderInput, BatchUncheckedCreateWithoutPurchaseOrderInput> | BatchCreateWithoutPurchaseOrderInput[] | BatchUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutPurchaseOrderInput | BatchCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: BatchCreateManyPurchaseOrderInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<StockTransactionCreateWithoutPurchaseOrderInput, StockTransactionUncheckedCreateWithoutPurchaseOrderInput> | StockTransactionCreateWithoutPurchaseOrderInput[] | StockTransactionUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutPurchaseOrderInput | StockTransactionCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: StockTransactionCreateManyPurchaseOrderInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type MedicalStoreUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<MedicalStoreCreateWithoutPurchaseOrdersInput, MedicalStoreUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: MedicalStoreCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: MedicalStoreUpsertWithoutPurchaseOrdersInput
    connect?: MedicalStoreWhereUniqueInput
    update?: XOR<XOR<MedicalStoreUpdateToOneWithWhereWithoutPurchaseOrdersInput, MedicalStoreUpdateWithoutPurchaseOrdersInput>, MedicalStoreUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: UserUpsertWithoutPurchaseOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseOrdersInput, UserUpdateWithoutPurchaseOrdersInput>, UserUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type BatchUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<BatchCreateWithoutPurchaseOrderInput, BatchUncheckedCreateWithoutPurchaseOrderInput> | BatchCreateWithoutPurchaseOrderInput[] | BatchUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutPurchaseOrderInput | BatchCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutPurchaseOrderInput | BatchUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: BatchCreateManyPurchaseOrderInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutPurchaseOrderInput | BatchUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutPurchaseOrderInput | BatchUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type StockTransactionUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<StockTransactionCreateWithoutPurchaseOrderInput, StockTransactionUncheckedCreateWithoutPurchaseOrderInput> | StockTransactionCreateWithoutPurchaseOrderInput[] | StockTransactionUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutPurchaseOrderInput | StockTransactionCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutPurchaseOrderInput | StockTransactionUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: StockTransactionCreateManyPurchaseOrderInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutPurchaseOrderInput | StockTransactionUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutPurchaseOrderInput | StockTransactionUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<BatchCreateWithoutPurchaseOrderInput, BatchUncheckedCreateWithoutPurchaseOrderInput> | BatchCreateWithoutPurchaseOrderInput[] | BatchUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutPurchaseOrderInput | BatchCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutPurchaseOrderInput | BatchUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: BatchCreateManyPurchaseOrderInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutPurchaseOrderInput | BatchUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutPurchaseOrderInput | BatchUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type StockTransactionUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<StockTransactionCreateWithoutPurchaseOrderInput, StockTransactionUncheckedCreateWithoutPurchaseOrderInput> | StockTransactionCreateWithoutPurchaseOrderInput[] | StockTransactionUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutPurchaseOrderInput | StockTransactionCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutPurchaseOrderInput | StockTransactionUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: StockTransactionCreateManyPurchaseOrderInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutPurchaseOrderInput | StockTransactionUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutPurchaseOrderInput | StockTransactionUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type SoldItemsCreateNestedManyWithoutOrderInput = {
    create?: XOR<SoldItemsCreateWithoutOrderInput, SoldItemsUncheckedCreateWithoutOrderInput> | SoldItemsCreateWithoutOrderInput[] | SoldItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutOrderInput | SoldItemsCreateOrConnectWithoutOrderInput[]
    createMany?: SoldItemsCreateManyOrderInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReturnedItemsCreateWithoutOrderInput, ReturnedItemsUncheckedCreateWithoutOrderInput> | ReturnedItemsCreateWithoutOrderInput[] | ReturnedItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutOrderInput | ReturnedItemsCreateOrConnectWithoutOrderInput[]
    createMany?: ReturnedItemsCreateManyOrderInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type SoldItemsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SoldItemsCreateWithoutOrderInput, SoldItemsUncheckedCreateWithoutOrderInput> | SoldItemsCreateWithoutOrderInput[] | SoldItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutOrderInput | SoldItemsCreateOrConnectWithoutOrderInput[]
    createMany?: SoldItemsCreateManyOrderInputEnvelope
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
  }

  export type ReturnedItemsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReturnedItemsCreateWithoutOrderInput, ReturnedItemsUncheckedCreateWithoutOrderInput> | ReturnedItemsCreateWithoutOrderInput[] | ReturnedItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutOrderInput | ReturnedItemsCreateOrConnectWithoutOrderInput[]
    createMany?: ReturnedItemsCreateManyOrderInputEnvelope
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType | null
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type SoldItemsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SoldItemsCreateWithoutOrderInput, SoldItemsUncheckedCreateWithoutOrderInput> | SoldItemsCreateWithoutOrderInput[] | SoldItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutOrderInput | SoldItemsCreateOrConnectWithoutOrderInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutOrderInput | SoldItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SoldItemsCreateManyOrderInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutOrderInput | SoldItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutOrderInput | SoldItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutOrderInput, ReturnedItemsUncheckedCreateWithoutOrderInput> | ReturnedItemsCreateWithoutOrderInput[] | ReturnedItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutOrderInput | ReturnedItemsCreateOrConnectWithoutOrderInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutOrderInput | ReturnedItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReturnedItemsCreateManyOrderInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutOrderInput | ReturnedItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutOrderInput | ReturnedItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type SoldItemsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SoldItemsCreateWithoutOrderInput, SoldItemsUncheckedCreateWithoutOrderInput> | SoldItemsCreateWithoutOrderInput[] | SoldItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SoldItemsCreateOrConnectWithoutOrderInput | SoldItemsCreateOrConnectWithoutOrderInput[]
    upsert?: SoldItemsUpsertWithWhereUniqueWithoutOrderInput | SoldItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SoldItemsCreateManyOrderInputEnvelope
    set?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    disconnect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    delete?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    connect?: SoldItemsWhereUniqueInput | SoldItemsWhereUniqueInput[]
    update?: SoldItemsUpdateWithWhereUniqueWithoutOrderInput | SoldItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SoldItemsUpdateManyWithWhereWithoutOrderInput | SoldItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReturnedItemsCreateWithoutOrderInput, ReturnedItemsUncheckedCreateWithoutOrderInput> | ReturnedItemsCreateWithoutOrderInput[] | ReturnedItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnedItemsCreateOrConnectWithoutOrderInput | ReturnedItemsCreateOrConnectWithoutOrderInput[]
    upsert?: ReturnedItemsUpsertWithWhereUniqueWithoutOrderInput | ReturnedItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReturnedItemsCreateManyOrderInputEnvelope
    set?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    disconnect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    delete?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    connect?: ReturnedItemsWhereUniqueInput | ReturnedItemsWhereUniqueInput[]
    update?: ReturnedItemsUpdateWithWhereUniqueWithoutOrderInput | ReturnedItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReturnedItemsUpdateManyWithWhereWithoutOrderInput | ReturnedItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MedicineCreateNestedOneWithoutSoldItemsInput = {
    create?: XOR<MedicineCreateWithoutSoldItemsInput, MedicineUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutSoldItemsInput
    connect?: MedicineWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutSoldItemsInput = {
    create?: XOR<OrderCreateWithoutSoldItemsInput, OrderUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSoldItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type BatchCreateNestedOneWithoutSoldItemsInput = {
    create?: XOR<BatchCreateWithoutSoldItemsInput, BatchUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutSoldItemsInput
    connect?: BatchWhereUniqueInput
  }

  export type SubUnitCreateNestedOneWithoutSoldItemsInput = {
    create?: XOR<SubUnitCreateWithoutSoldItemsInput, SubUnitUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: SubUnitCreateOrConnectWithoutSoldItemsInput
    connect?: SubUnitWhereUniqueInput
  }

  export type MedicineUpdateOneRequiredWithoutSoldItemsNestedInput = {
    create?: XOR<MedicineCreateWithoutSoldItemsInput, MedicineUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutSoldItemsInput
    upsert?: MedicineUpsertWithoutSoldItemsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutSoldItemsInput, MedicineUpdateWithoutSoldItemsInput>, MedicineUncheckedUpdateWithoutSoldItemsInput>
  }

  export type OrderUpdateOneRequiredWithoutSoldItemsNestedInput = {
    create?: XOR<OrderCreateWithoutSoldItemsInput, OrderUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSoldItemsInput
    upsert?: OrderUpsertWithoutSoldItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutSoldItemsInput, OrderUpdateWithoutSoldItemsInput>, OrderUncheckedUpdateWithoutSoldItemsInput>
  }

  export type BatchUpdateOneWithoutSoldItemsNestedInput = {
    create?: XOR<BatchCreateWithoutSoldItemsInput, BatchUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutSoldItemsInput
    upsert?: BatchUpsertWithoutSoldItemsInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutSoldItemsInput, BatchUpdateWithoutSoldItemsInput>, BatchUncheckedUpdateWithoutSoldItemsInput>
  }

  export type SubUnitUpdateOneWithoutSoldItemsNestedInput = {
    create?: XOR<SubUnitCreateWithoutSoldItemsInput, SubUnitUncheckedCreateWithoutSoldItemsInput>
    connectOrCreate?: SubUnitCreateOrConnectWithoutSoldItemsInput
    upsert?: SubUnitUpsertWithoutSoldItemsInput
    disconnect?: SubUnitWhereInput | boolean
    delete?: SubUnitWhereInput | boolean
    connect?: SubUnitWhereUniqueInput
    update?: XOR<XOR<SubUnitUpdateToOneWithWhereWithoutSoldItemsInput, SubUnitUpdateWithoutSoldItemsInput>, SubUnitUncheckedUpdateWithoutSoldItemsInput>
  }

  export type MedicineCreateNestedOneWithoutReturnedItemsInput = {
    create?: XOR<MedicineCreateWithoutReturnedItemsInput, MedicineUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutReturnedItemsInput
    connect?: MedicineWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutReturnedItemsInput = {
    create?: XOR<OrderCreateWithoutReturnedItemsInput, OrderUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReturnedItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type BatchCreateNestedOneWithoutReturnedItemsInput = {
    create?: XOR<BatchCreateWithoutReturnedItemsInput, BatchUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutReturnedItemsInput
    connect?: BatchWhereUniqueInput
  }

  export type SubUnitCreateNestedOneWithoutReturnedItemsInput = {
    create?: XOR<SubUnitCreateWithoutReturnedItemsInput, SubUnitUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: SubUnitCreateOrConnectWithoutReturnedItemsInput
    connect?: SubUnitWhereUniqueInput
  }

  export type EnumReturnTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReturnType
  }

  export type MedicineUpdateOneRequiredWithoutReturnedItemsNestedInput = {
    create?: XOR<MedicineCreateWithoutReturnedItemsInput, MedicineUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutReturnedItemsInput
    upsert?: MedicineUpsertWithoutReturnedItemsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutReturnedItemsInput, MedicineUpdateWithoutReturnedItemsInput>, MedicineUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type OrderUpdateOneRequiredWithoutReturnedItemsNestedInput = {
    create?: XOR<OrderCreateWithoutReturnedItemsInput, OrderUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReturnedItemsInput
    upsert?: OrderUpsertWithoutReturnedItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReturnedItemsInput, OrderUpdateWithoutReturnedItemsInput>, OrderUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type BatchUpdateOneWithoutReturnedItemsNestedInput = {
    create?: XOR<BatchCreateWithoutReturnedItemsInput, BatchUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutReturnedItemsInput
    upsert?: BatchUpsertWithoutReturnedItemsInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutReturnedItemsInput, BatchUpdateWithoutReturnedItemsInput>, BatchUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type SubUnitUpdateOneWithoutReturnedItemsNestedInput = {
    create?: XOR<SubUnitCreateWithoutReturnedItemsInput, SubUnitUncheckedCreateWithoutReturnedItemsInput>
    connectOrCreate?: SubUnitCreateOrConnectWithoutReturnedItemsInput
    upsert?: SubUnitUpsertWithoutReturnedItemsInput
    disconnect?: SubUnitWhereInput | boolean
    delete?: SubUnitWhereInput | boolean
    connect?: SubUnitWhereUniqueInput
    update?: XOR<XOR<SubUnitUpdateToOneWithWhereWithoutReturnedItemsInput, SubUnitUpdateWithoutReturnedItemsInput>, SubUnitUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumDiscountTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableFilter<$PrismaModel> | $Enums.DiscountType | null
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReturnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnType | EnumReturnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnTypeFilter<$PrismaModel> | $Enums.ReturnType
  }

  export type NestedEnumReturnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnType | EnumReturnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnType[] | ListEnumReturnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReturnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnTypeFilter<$PrismaModel>
    _max?: NestedEnumReturnTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutChildrenInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: UserCreateNestedOneWithoutChildrenInput
    medicalStore?: MedicalStoreCreateNestedOneWithoutOwnerInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore?: MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChildrenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
  }

  export type UserCreateWithoutParentInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreCreateNestedOneWithoutOwnerInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserUncheckedCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type UserCreateManyParentInputEnvelope = {
    data: UserCreateManyParentInput | UserCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MedicalStoreCreateWithoutOwnerInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutOwnerInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutOwnerInput, MedicalStoreUncheckedCreateWithoutOwnerInput>
  }

  export type OrderCreateWithoutUserInput = {
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    soldItems?: SoldItemsCreateNestedManyWithoutOrderInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    customerId?: number | null
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutOrderInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    entity: string
    entityId: number
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    entity: string
    entityId: number
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutUserInput = {
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    batches?: BatchCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutUserInput = {
    id?: number
    medicalStoreId: number
    supplierId?: number | null
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutUserInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput>
  }

  export type PurchaseOrderCreateManyUserInputEnvelope = {
    data: PurchaseOrderCreateManyUserInput | PurchaseOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChildrenInput = {
    update: XOR<UserUpdateWithoutChildrenInput, UserUncheckedUpdateWithoutChildrenInput>
    create: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChildrenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChildrenInput, UserUncheckedUpdateWithoutChildrenInput>
  }

  export type UserUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneWithoutChildrenNestedInput
    medicalStore?: MedicalStoreUpdateOneWithoutOwnerNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutParentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutParentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
  }

  export type UserUpdateManyWithWhereWithoutParentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutParentInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    city?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    employeeId?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    parentId?: IntNullableFilter<"User"> | number | null
    medicalStoreId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type MedicalStoreUpsertWithoutOwnerInput = {
    update: XOR<MedicalStoreUpdateWithoutOwnerInput, MedicalStoreUncheckedUpdateWithoutOwnerInput>
    create: XOR<MedicalStoreCreateWithoutOwnerInput, MedicalStoreUncheckedCreateWithoutOwnerInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutOwnerInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutOwnerInput, MedicalStoreUncheckedUpdateWithoutOwnerInput>
  }

  export type MedicalStoreUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    userId?: IntFilter<"Order"> | number
    customerId?: IntNullableFilter<"Order"> | number | null
    customerName?: StringNullableFilter<"Order"> | string | null
    customerLocation?: StringNullableFilter<"Order"> | string | null
    customerContact?: StringNullableFilter<"Order"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    changeCash?: FloatNullableFilter<"Order"> | number | null
    discount?: FloatNullableFilter<"Order"> | number | null
    discountType?: EnumDiscountTypeNullableFilter<"Order"> | $Enums.DiscountType | null
    itemsCost?: FloatFilter<"Order"> | number
    tax?: FloatNullableFilter<"Order"> | number | null
    sellingPrice?: FloatFilter<"Order"> | number
    profit?: FloatNullableFilter<"Order"> | number | null
    bill?: FloatFilter<"Order"> | number
    invoiceDate?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutUserInput, PurchaseOrderUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutUserInput, PurchaseOrderUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: IntFilter<"PurchaseOrder"> | number
    medicalStoreId?: IntFilter<"PurchaseOrder"> | number
    supplierId?: IntNullableFilter<"PurchaseOrder"> | number | null
    userId?: IntFilter<"PurchaseOrder"> | number
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: StringFilter<"PurchaseOrder"> | string
    totalCost?: FloatFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type UserCreateWithoutMedicalStoreInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: UserCreateNestedOneWithoutChildrenInput
    children?: UserCreateNestedManyWithoutParentInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserUncheckedCreateNestedManyWithoutParentInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMedicalStoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicalStoreInput, UserUncheckedCreateWithoutMedicalStoreInput>
  }

  export type MedicalStoreMedicineCreateWithoutMedicalStoreInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutMedicalStoreMedicinesInput
  }

  export type MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    medicineId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreMedicineCreateOrConnectWithoutMedicalStoreInput = {
    where: MedicalStoreMedicineWhereUniqueInput
    create: XOR<MedicalStoreMedicineCreateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput>
  }

  export type MedicalStoreMedicineCreateManyMedicalStoreInputEnvelope = {
    data: MedicalStoreMedicineCreateManyMedicalStoreInput | MedicalStoreMedicineCreateManyMedicalStoreInput[]
    skipDuplicates?: boolean
  }

  export type MedicineLocationCreateWithoutMedicalStoreInput = {
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutLocationsInput
    instance: MedicineInstanceCreateNestedOneWithoutLocationsInput
  }

  export type MedicineLocationUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    medicineId: number
    medicineInstanceId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationCreateOrConnectWithoutMedicalStoreInput = {
    where: MedicineLocationWhereUniqueInput
    create: XOR<MedicineLocationCreateWithoutMedicalStoreInput, MedicineLocationUncheckedCreateWithoutMedicalStoreInput>
  }

  export type MedicineLocationCreateManyMedicalStoreInputEnvelope = {
    data: MedicineLocationCreateManyMedicalStoreInput | MedicineLocationCreateManyMedicalStoreInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutMedicalStoreInput = {
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    user: UserCreateNestedOneWithoutPurchaseOrdersInput
    batches?: BatchCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    supplierId?: number | null
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutMedicalStoreInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutMedicalStoreInput, PurchaseOrderUncheckedCreateWithoutMedicalStoreInput>
  }

  export type PurchaseOrderCreateManyMedicalStoreInputEnvelope = {
    data: PurchaseOrderCreateManyMedicalStoreInput | PurchaseOrderCreateManyMedicalStoreInput[]
    skipDuplicates?: boolean
  }

  export type StockTransactionCreateWithoutMedicalStoreInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicineInstance: MedicineInstanceCreateNestedOneWithoutStockTransactionsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    medicineInstanceId: number
    purchaseOrderId?: number | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutMedicalStoreInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutMedicalStoreInput, StockTransactionUncheckedCreateWithoutMedicalStoreInput>
  }

  export type StockTransactionCreateManyMedicalStoreInputEnvelope = {
    data: StockTransactionCreateManyMedicalStoreInput | StockTransactionCreateManyMedicalStoreInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutMedicalStoreInput = {
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    medicines?: MedicineCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    medicines?: MedicineUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMedicalStoreInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMedicalStoreInput, CompanyUncheckedCreateWithoutMedicalStoreInput>
  }

  export type CompanyCreateManyMedicalStoreInputEnvelope = {
    data: CompanyCreateManyMedicalStoreInput | CompanyCreateManyMedicalStoreInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutMedicalStoreInput = {
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSuppliersInput
    medicines?: MedicineCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutMedicalStoreInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicineUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutMedicalStoreInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutMedicalStoreInput, SupplierUncheckedCreateWithoutMedicalStoreInput>
  }

  export type SupplierCreateManyMedicalStoreInputEnvelope = {
    data: SupplierCreateManyMedicalStoreInput | SupplierCreateManyMedicalStoreInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMedicalStoreInput = {
    update: XOR<UserUpdateWithoutMedicalStoreInput, UserUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<UserCreateWithoutMedicalStoreInput, UserUncheckedCreateWithoutMedicalStoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicalStoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicalStoreInput, UserUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type UserUpdateWithoutMedicalStoreInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneWithoutChildrenNestedInput
    children?: UserUpdateManyWithoutParentNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUncheckedUpdateManyWithoutParentNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicalStoreInput = {
    where: MedicalStoreMedicineWhereUniqueInput
    update: XOR<MedicalStoreMedicineUpdateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<MedicalStoreMedicineCreateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedCreateWithoutMedicalStoreInput>
  }

  export type MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicalStoreInput = {
    where: MedicalStoreMedicineWhereUniqueInput
    data: XOR<MedicalStoreMedicineUpdateWithoutMedicalStoreInput, MedicalStoreMedicineUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type MedicalStoreMedicineUpdateManyWithWhereWithoutMedicalStoreInput = {
    where: MedicalStoreMedicineScalarWhereInput
    data: XOR<MedicalStoreMedicineUpdateManyMutationInput, MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreInput>
  }

  export type MedicalStoreMedicineScalarWhereInput = {
    AND?: MedicalStoreMedicineScalarWhereInput | MedicalStoreMedicineScalarWhereInput[]
    OR?: MedicalStoreMedicineScalarWhereInput[]
    NOT?: MedicalStoreMedicineScalarWhereInput | MedicalStoreMedicineScalarWhereInput[]
    id?: IntFilter<"MedicalStoreMedicine"> | number
    medicalStoreId?: IntFilter<"MedicalStoreMedicine"> | number
    medicineId?: IntFilter<"MedicalStoreMedicine"> | number
    quantity?: IntFilter<"MedicalStoreMedicine"> | number
    createdAt?: DateTimeFilter<"MedicalStoreMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalStoreMedicine"> | Date | string
  }

  export type MedicineLocationUpsertWithWhereUniqueWithoutMedicalStoreInput = {
    where: MedicineLocationWhereUniqueInput
    update: XOR<MedicineLocationUpdateWithoutMedicalStoreInput, MedicineLocationUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<MedicineLocationCreateWithoutMedicalStoreInput, MedicineLocationUncheckedCreateWithoutMedicalStoreInput>
  }

  export type MedicineLocationUpdateWithWhereUniqueWithoutMedicalStoreInput = {
    where: MedicineLocationWhereUniqueInput
    data: XOR<MedicineLocationUpdateWithoutMedicalStoreInput, MedicineLocationUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type MedicineLocationUpdateManyWithWhereWithoutMedicalStoreInput = {
    where: MedicineLocationScalarWhereInput
    data: XOR<MedicineLocationUpdateManyMutationInput, MedicineLocationUncheckedUpdateManyWithoutMedicalStoreInput>
  }

  export type MedicineLocationScalarWhereInput = {
    AND?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
    OR?: MedicineLocationScalarWhereInput[]
    NOT?: MedicineLocationScalarWhereInput | MedicineLocationScalarWhereInput[]
    id?: IntFilter<"MedicineLocation"> | number
    medicalStoreId?: IntFilter<"MedicineLocation"> | number
    medicineId?: IntFilter<"MedicineLocation"> | number
    medicineInstanceId?: IntFilter<"MedicineLocation"> | number
    location?: StringFilter<"MedicineLocation"> | string
    rank?: StringNullableFilter<"MedicineLocation"> | string | null
    quantity?: IntFilter<"MedicineLocation"> | number
    createdAt?: DateTimeFilter<"MedicineLocation"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineLocation"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutMedicalStoreInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutMedicalStoreInput, PurchaseOrderUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<PurchaseOrderCreateWithoutMedicalStoreInput, PurchaseOrderUncheckedCreateWithoutMedicalStoreInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutMedicalStoreInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutMedicalStoreInput, PurchaseOrderUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutMedicalStoreInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreInput>
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutMedicalStoreInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutMedicalStoreInput, StockTransactionUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<StockTransactionCreateWithoutMedicalStoreInput, StockTransactionUncheckedCreateWithoutMedicalStoreInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutMedicalStoreInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutMedicalStoreInput, StockTransactionUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutMedicalStoreInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutMedicalStoreInput>
  }

  export type StockTransactionScalarWhereInput = {
    AND?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
    OR?: StockTransactionScalarWhereInput[]
    NOT?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
    id?: IntFilter<"StockTransaction"> | number
    medicalStoreId?: IntFilter<"StockTransaction"> | number
    medicineInstanceId?: IntFilter<"StockTransaction"> | number
    purchaseOrderId?: IntNullableFilter<"StockTransaction"> | number | null
    quantity?: IntFilter<"StockTransaction"> | number
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransaction"> | Date | string
  }

  export type CompanyUpsertWithWhereUniqueWithoutMedicalStoreInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutMedicalStoreInput, CompanyUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<CompanyCreateWithoutMedicalStoreInput, CompanyUncheckedCreateWithoutMedicalStoreInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutMedicalStoreInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutMedicalStoreInput, CompanyUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type CompanyUpdateManyWithWhereWithoutMedicalStoreInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutMedicalStoreInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: IntFilter<"Company"> | number
    companyCode?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    mobile?: StringNullableFilter<"Company"> | string | null
    distributorCode?: StringNullableFilter<"Company"> | string | null
    ntnNumber?: StringNullableFilter<"Company"> | string | null
    registrationDate?: DateTimeFilter<"Company"> | Date | string
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    medicalStoreId?: IntFilter<"Company"> | number
  }

  export type SupplierUpsertWithWhereUniqueWithoutMedicalStoreInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutMedicalStoreInput, SupplierUncheckedUpdateWithoutMedicalStoreInput>
    create: XOR<SupplierCreateWithoutMedicalStoreInput, SupplierUncheckedCreateWithoutMedicalStoreInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutMedicalStoreInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutMedicalStoreInput, SupplierUncheckedUpdateWithoutMedicalStoreInput>
  }

  export type SupplierUpdateManyWithWhereWithoutMedicalStoreInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutMedicalStoreInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: IntFilter<"Supplier"> | number
    supplierCode?: StringNullableFilter<"Supplier"> | string | null
    name?: StringFilter<"Supplier"> | string
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringFilter<"Supplier"> | string
    distributorCode?: StringFilter<"Supplier"> | string
    ntnNumber?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    companyId?: IntFilter<"Supplier"> | number
    medicalStoreId?: IntFilter<"Supplier"> | number
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type MedicalStoreCreateWithoutCompaniesInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutCompaniesInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutCompaniesInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutCompaniesInput, MedicalStoreUncheckedCreateWithoutCompaniesInput>
  }

  export type SupplierCreateWithoutCompanyInput = {
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutSuppliersInput
    medicines?: MedicineCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutCompanyInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    medicalStoreId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicineUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutCompanyInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
  }

  export type SupplierCreateManyCompanyInputEnvelope = {
    data: SupplierCreateManyCompanyInput | SupplierCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type MedicineCreateWithoutCompanyInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutCompanyInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutCompanyInput, MedicineUncheckedCreateWithoutCompanyInput>
  }

  export type MedicineCreateManyCompanyInputEnvelope = {
    data: MedicineCreateManyCompanyInput | MedicineCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type MedicalStoreUpsertWithoutCompaniesInput = {
    update: XOR<MedicalStoreUpdateWithoutCompaniesInput, MedicalStoreUncheckedUpdateWithoutCompaniesInput>
    create: XOR<MedicalStoreCreateWithoutCompaniesInput, MedicalStoreUncheckedCreateWithoutCompaniesInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutCompaniesInput, MedicalStoreUncheckedUpdateWithoutCompaniesInput>
  }

  export type MedicalStoreUpdateWithoutCompaniesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type SupplierUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutCompanyInput, SupplierUncheckedUpdateWithoutCompanyInput>
    create: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutCompanyInput, SupplierUncheckedUpdateWithoutCompanyInput>
  }

  export type SupplierUpdateManyWithWhereWithoutCompanyInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutCompanyInput>
  }

  export type MedicineUpsertWithWhereUniqueWithoutCompanyInput = {
    where: MedicineWhereUniqueInput
    update: XOR<MedicineUpdateWithoutCompanyInput, MedicineUncheckedUpdateWithoutCompanyInput>
    create: XOR<MedicineCreateWithoutCompanyInput, MedicineUncheckedCreateWithoutCompanyInput>
  }

  export type MedicineUpdateWithWhereUniqueWithoutCompanyInput = {
    where: MedicineWhereUniqueInput
    data: XOR<MedicineUpdateWithoutCompanyInput, MedicineUncheckedUpdateWithoutCompanyInput>
  }

  export type MedicineUpdateManyWithWhereWithoutCompanyInput = {
    where: MedicineScalarWhereInput
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyWithoutCompanyInput>
  }

  export type MedicineScalarWhereInput = {
    AND?: MedicineScalarWhereInput | MedicineScalarWhereInput[]
    OR?: MedicineScalarWhereInput[]
    NOT?: MedicineScalarWhereInput | MedicineScalarWhereInput[]
    id?: IntFilter<"Medicine"> | number
    name?: StringFilter<"Medicine"> | string
    formula?: StringNullableFilter<"Medicine"> | string | null
    description?: StringNullableFilter<"Medicine"> | string | null
    minquantity?: IntFilter<"Medicine"> | number
    companyId?: IntFilter<"Medicine"> | number
    supplierId?: IntFilter<"Medicine"> | number
    isActive?: BoolFilter<"Medicine"> | boolean
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeFilter<"Medicine"> | Date | string
  }

  export type MedicalStoreCreateWithoutSuppliersInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutSuppliersInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutSuppliersInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutSuppliersInput, MedicalStoreUncheckedCreateWithoutSuppliersInput>
  }

  export type CompanyCreateWithoutSuppliersInput = {
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutCompaniesInput
    medicines?: MedicineCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSuppliersInput = {
    id?: number
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStoreId: number
    medicines?: MedicineUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSuppliersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
  }

  export type MedicineCreateWithoutSupplierInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutSupplierInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutSupplierInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutSupplierInput, MedicineUncheckedCreateWithoutSupplierInput>
  }

  export type MedicineCreateManySupplierInputEnvelope = {
    data: MedicineCreateManySupplierInput | MedicineCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutPurchaseOrdersInput
    user: UserCreateNestedOneWithoutPurchaseOrdersInput
    batches?: BatchCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: number
    medicalStoreId: number
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type MedicalStoreUpsertWithoutSuppliersInput = {
    update: XOR<MedicalStoreUpdateWithoutSuppliersInput, MedicalStoreUncheckedUpdateWithoutSuppliersInput>
    create: XOR<MedicalStoreCreateWithoutSuppliersInput, MedicalStoreUncheckedCreateWithoutSuppliersInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutSuppliersInput, MedicalStoreUncheckedUpdateWithoutSuppliersInput>
  }

  export type MedicalStoreUpdateWithoutSuppliersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type CompanyUpsertWithoutSuppliersInput = {
    update: XOR<CompanyUpdateWithoutSuppliersInput, CompanyUncheckedUpdateWithoutSuppliersInput>
    create: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSuppliersInput, CompanyUncheckedUpdateWithoutSuppliersInput>
  }

  export type CompanyUpdateWithoutSuppliersInput = {
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutCompaniesNestedInput
    medicines?: MedicineUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicines?: MedicineUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type MedicineUpsertWithWhereUniqueWithoutSupplierInput = {
    where: MedicineWhereUniqueInput
    update: XOR<MedicineUpdateWithoutSupplierInput, MedicineUncheckedUpdateWithoutSupplierInput>
    create: XOR<MedicineCreateWithoutSupplierInput, MedicineUncheckedCreateWithoutSupplierInput>
  }

  export type MedicineUpdateWithWhereUniqueWithoutSupplierInput = {
    where: MedicineWhereUniqueInput
    data: XOR<MedicineUpdateWithoutSupplierInput, MedicineUncheckedUpdateWithoutSupplierInput>
  }

  export type MedicineUpdateManyWithWhereWithoutSupplierInput = {
    where: MedicineScalarWhereInput
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CompanyCreateWithoutMedicinesInput = {
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutCompaniesInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMedicinesInput = {
    id?: number
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStoreId: number
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMedicinesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMedicinesInput, CompanyUncheckedCreateWithoutMedicinesInput>
  }

  export type SupplierCreateWithoutMedicinesInput = {
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutSuppliersInput
    company: CompanyCreateNestedOneWithoutSuppliersInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutMedicinesInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    companyId: number
    medicalStoreId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutMedicinesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutMedicinesInput, SupplierUncheckedCreateWithoutMedicinesInput>
  }

  export type VariationCreateWithoutMedicineInput = {
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchCreateNestedManyWithoutVariationInput
    instances?: MedicineInstanceCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutMedicineInput = {
    id?: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutVariationInput
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutMedicineInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutMedicineInput, VariationUncheckedCreateWithoutMedicineInput>
  }

  export type VariationCreateManyMedicineInputEnvelope = {
    data: VariationCreateManyMedicineInput | VariationCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type MedicineLocationCreateWithoutMedicineInput = {
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutLocationsInput
    instance: MedicineInstanceCreateNestedOneWithoutLocationsInput
  }

  export type MedicineLocationUncheckedCreateWithoutMedicineInput = {
    id?: number
    medicalStoreId: number
    medicineInstanceId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationCreateOrConnectWithoutMedicineInput = {
    where: MedicineLocationWhereUniqueInput
    create: XOR<MedicineLocationCreateWithoutMedicineInput, MedicineLocationUncheckedCreateWithoutMedicineInput>
  }

  export type MedicineLocationCreateManyMedicineInputEnvelope = {
    data: MedicineLocationCreateManyMedicineInput | MedicineLocationCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type MedicalStoreMedicineCreateWithoutMedicineInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutMedicinesInput
  }

  export type MedicalStoreMedicineUncheckedCreateWithoutMedicineInput = {
    id?: number
    medicalStoreId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreMedicineCreateOrConnectWithoutMedicineInput = {
    where: MedicalStoreMedicineWhereUniqueInput
    create: XOR<MedicalStoreMedicineCreateWithoutMedicineInput, MedicalStoreMedicineUncheckedCreateWithoutMedicineInput>
  }

  export type MedicalStoreMedicineCreateManyMedicineInputEnvelope = {
    data: MedicalStoreMedicineCreateManyMedicineInput | MedicalStoreMedicineCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type MedicineExpiryCreateWithoutMedicineInput = {
    expiryDate: Date | string
    isNearExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineExpiryUncheckedCreateWithoutMedicineInput = {
    id?: number
    expiryDate: Date | string
    isNearExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineExpiryCreateOrConnectWithoutMedicineInput = {
    where: MedicineExpiryWhereUniqueInput
    create: XOR<MedicineExpiryCreateWithoutMedicineInput, MedicineExpiryUncheckedCreateWithoutMedicineInput>
  }

  export type MedicineExpiryCreateManyMedicineInputEnvelope = {
    data: MedicineExpiryCreateManyMedicineInput | MedicineExpiryCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type SoldItemsCreateWithoutMedicineInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutSoldItemsInput
    batch?: BatchCreateNestedOneWithoutSoldItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutSoldItemsInput
  }

  export type SoldItemsUncheckedCreateWithoutMedicineInput = {
    id?: number
    orderId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsCreateOrConnectWithoutMedicineInput = {
    where: SoldItemsWhereUniqueInput
    create: XOR<SoldItemsCreateWithoutMedicineInput, SoldItemsUncheckedCreateWithoutMedicineInput>
  }

  export type SoldItemsCreateManyMedicineInputEnvelope = {
    data: SoldItemsCreateManyMedicineInput | SoldItemsCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type ReturnedItemsCreateWithoutMedicineInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReturnedItemsInput
    batch?: BatchCreateNestedOneWithoutReturnedItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutReturnedItemsInput
  }

  export type ReturnedItemsUncheckedCreateWithoutMedicineInput = {
    id?: number
    orderId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateOrConnectWithoutMedicineInput = {
    where: ReturnedItemsWhereUniqueInput
    create: XOR<ReturnedItemsCreateWithoutMedicineInput, ReturnedItemsUncheckedCreateWithoutMedicineInput>
  }

  export type ReturnedItemsCreateManyMedicineInputEnvelope = {
    data: ReturnedItemsCreateManyMedicineInput | ReturnedItemsCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutMedicinesInput = {
    update: XOR<CompanyUpdateWithoutMedicinesInput, CompanyUncheckedUpdateWithoutMedicinesInput>
    create: XOR<CompanyCreateWithoutMedicinesInput, CompanyUncheckedCreateWithoutMedicinesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutMedicinesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutMedicinesInput, CompanyUncheckedUpdateWithoutMedicinesInput>
  }

  export type CompanyUpdateWithoutMedicinesInput = {
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutCompaniesNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMedicinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type SupplierUpsertWithoutMedicinesInput = {
    update: XOR<SupplierUpdateWithoutMedicinesInput, SupplierUncheckedUpdateWithoutMedicinesInput>
    create: XOR<SupplierCreateWithoutMedicinesInput, SupplierUncheckedCreateWithoutMedicinesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutMedicinesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutMedicinesInput, SupplierUncheckedUpdateWithoutMedicinesInput>
  }

  export type SupplierUpdateWithoutMedicinesInput = {
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutSuppliersNestedInput
    company?: CompanyUpdateOneRequiredWithoutSuppliersNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutMedicinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type VariationUpsertWithWhereUniqueWithoutMedicineInput = {
    where: VariationWhereUniqueInput
    update: XOR<VariationUpdateWithoutMedicineInput, VariationUncheckedUpdateWithoutMedicineInput>
    create: XOR<VariationCreateWithoutMedicineInput, VariationUncheckedCreateWithoutMedicineInput>
  }

  export type VariationUpdateWithWhereUniqueWithoutMedicineInput = {
    where: VariationWhereUniqueInput
    data: XOR<VariationUpdateWithoutMedicineInput, VariationUncheckedUpdateWithoutMedicineInput>
  }

  export type VariationUpdateManyWithWhereWithoutMedicineInput = {
    where: VariationScalarWhereInput
    data: XOR<VariationUpdateManyMutationInput, VariationUncheckedUpdateManyWithoutMedicineInput>
  }

  export type VariationScalarWhereInput = {
    AND?: VariationScalarWhereInput | VariationScalarWhereInput[]
    OR?: VariationScalarWhereInput[]
    NOT?: VariationScalarWhereInput | VariationScalarWhereInput[]
    id?: IntFilter<"Variation"> | number
    medicineId?: IntFilter<"Variation"> | number
    potency?: StringFilter<"Variation"> | string
    packaging?: StringFilter<"Variation"> | string
    unitType?: StringFilter<"Variation"> | string
    unitsPerPack?: IntFilter<"Variation"> | number
    createdAt?: DateTimeFilter<"Variation"> | Date | string
    updatedAt?: DateTimeFilter<"Variation"> | Date | string
  }

  export type MedicineLocationUpsertWithWhereUniqueWithoutMedicineInput = {
    where: MedicineLocationWhereUniqueInput
    update: XOR<MedicineLocationUpdateWithoutMedicineInput, MedicineLocationUncheckedUpdateWithoutMedicineInput>
    create: XOR<MedicineLocationCreateWithoutMedicineInput, MedicineLocationUncheckedCreateWithoutMedicineInput>
  }

  export type MedicineLocationUpdateWithWhereUniqueWithoutMedicineInput = {
    where: MedicineLocationWhereUniqueInput
    data: XOR<MedicineLocationUpdateWithoutMedicineInput, MedicineLocationUncheckedUpdateWithoutMedicineInput>
  }

  export type MedicineLocationUpdateManyWithWhereWithoutMedicineInput = {
    where: MedicineLocationScalarWhereInput
    data: XOR<MedicineLocationUpdateManyMutationInput, MedicineLocationUncheckedUpdateManyWithoutMedicineInput>
  }

  export type MedicalStoreMedicineUpsertWithWhereUniqueWithoutMedicineInput = {
    where: MedicalStoreMedicineWhereUniqueInput
    update: XOR<MedicalStoreMedicineUpdateWithoutMedicineInput, MedicalStoreMedicineUncheckedUpdateWithoutMedicineInput>
    create: XOR<MedicalStoreMedicineCreateWithoutMedicineInput, MedicalStoreMedicineUncheckedCreateWithoutMedicineInput>
  }

  export type MedicalStoreMedicineUpdateWithWhereUniqueWithoutMedicineInput = {
    where: MedicalStoreMedicineWhereUniqueInput
    data: XOR<MedicalStoreMedicineUpdateWithoutMedicineInput, MedicalStoreMedicineUncheckedUpdateWithoutMedicineInput>
  }

  export type MedicalStoreMedicineUpdateManyWithWhereWithoutMedicineInput = {
    where: MedicalStoreMedicineScalarWhereInput
    data: XOR<MedicalStoreMedicineUpdateManyMutationInput, MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineInput>
  }

  export type MedicineExpiryUpsertWithWhereUniqueWithoutMedicineInput = {
    where: MedicineExpiryWhereUniqueInput
    update: XOR<MedicineExpiryUpdateWithoutMedicineInput, MedicineExpiryUncheckedUpdateWithoutMedicineInput>
    create: XOR<MedicineExpiryCreateWithoutMedicineInput, MedicineExpiryUncheckedCreateWithoutMedicineInput>
  }

  export type MedicineExpiryUpdateWithWhereUniqueWithoutMedicineInput = {
    where: MedicineExpiryWhereUniqueInput
    data: XOR<MedicineExpiryUpdateWithoutMedicineInput, MedicineExpiryUncheckedUpdateWithoutMedicineInput>
  }

  export type MedicineExpiryUpdateManyWithWhereWithoutMedicineInput = {
    where: MedicineExpiryScalarWhereInput
    data: XOR<MedicineExpiryUpdateManyMutationInput, MedicineExpiryUncheckedUpdateManyWithoutMedicineInput>
  }

  export type MedicineExpiryScalarWhereInput = {
    AND?: MedicineExpiryScalarWhereInput | MedicineExpiryScalarWhereInput[]
    OR?: MedicineExpiryScalarWhereInput[]
    NOT?: MedicineExpiryScalarWhereInput | MedicineExpiryScalarWhereInput[]
    id?: IntFilter<"MedicineExpiry"> | number
    medicineId?: IntFilter<"MedicineExpiry"> | number
    expiryDate?: DateTimeFilter<"MedicineExpiry"> | Date | string
    isNearExpiry?: BoolFilter<"MedicineExpiry"> | boolean
    createdAt?: DateTimeFilter<"MedicineExpiry"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineExpiry"> | Date | string
  }

  export type SoldItemsUpsertWithWhereUniqueWithoutMedicineInput = {
    where: SoldItemsWhereUniqueInput
    update: XOR<SoldItemsUpdateWithoutMedicineInput, SoldItemsUncheckedUpdateWithoutMedicineInput>
    create: XOR<SoldItemsCreateWithoutMedicineInput, SoldItemsUncheckedCreateWithoutMedicineInput>
  }

  export type SoldItemsUpdateWithWhereUniqueWithoutMedicineInput = {
    where: SoldItemsWhereUniqueInput
    data: XOR<SoldItemsUpdateWithoutMedicineInput, SoldItemsUncheckedUpdateWithoutMedicineInput>
  }

  export type SoldItemsUpdateManyWithWhereWithoutMedicineInput = {
    where: SoldItemsScalarWhereInput
    data: XOR<SoldItemsUpdateManyMutationInput, SoldItemsUncheckedUpdateManyWithoutMedicineInput>
  }

  export type SoldItemsScalarWhereInput = {
    AND?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
    OR?: SoldItemsScalarWhereInput[]
    NOT?: SoldItemsScalarWhereInput | SoldItemsScalarWhereInput[]
    id?: IntFilter<"SoldItems"> | number
    orderId?: IntFilter<"SoldItems"> | number
    medicineId?: IntFilter<"SoldItems"> | number
    batchId?: IntNullableFilter<"SoldItems"> | number | null
    subUnitId?: IntNullableFilter<"SoldItems"> | number | null
    packing?: StringNullableFilter<"SoldItems"> | string | null
    quantity?: IntFilter<"SoldItems"> | number
    retailPrice?: FloatFilter<"SoldItems"> | number
    discountPrice?: FloatNullableFilter<"SoldItems"> | number | null
    margin?: FloatFilter<"SoldItems"> | number
    saleDate?: DateTimeFilter<"SoldItems"> | Date | string
    updatedAt?: DateTimeFilter<"SoldItems"> | Date | string
  }

  export type ReturnedItemsUpsertWithWhereUniqueWithoutMedicineInput = {
    where: ReturnedItemsWhereUniqueInput
    update: XOR<ReturnedItemsUpdateWithoutMedicineInput, ReturnedItemsUncheckedUpdateWithoutMedicineInput>
    create: XOR<ReturnedItemsCreateWithoutMedicineInput, ReturnedItemsUncheckedCreateWithoutMedicineInput>
  }

  export type ReturnedItemsUpdateWithWhereUniqueWithoutMedicineInput = {
    where: ReturnedItemsWhereUniqueInput
    data: XOR<ReturnedItemsUpdateWithoutMedicineInput, ReturnedItemsUncheckedUpdateWithoutMedicineInput>
  }

  export type ReturnedItemsUpdateManyWithWhereWithoutMedicineInput = {
    where: ReturnedItemsScalarWhereInput
    data: XOR<ReturnedItemsUpdateManyMutationInput, ReturnedItemsUncheckedUpdateManyWithoutMedicineInput>
  }

  export type ReturnedItemsScalarWhereInput = {
    AND?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
    OR?: ReturnedItemsScalarWhereInput[]
    NOT?: ReturnedItemsScalarWhereInput | ReturnedItemsScalarWhereInput[]
    id?: IntFilter<"ReturnedItems"> | number
    orderId?: IntFilter<"ReturnedItems"> | number
    medicineId?: IntFilter<"ReturnedItems"> | number
    batchId?: IntNullableFilter<"ReturnedItems"> | number | null
    subUnitId?: IntNullableFilter<"ReturnedItems"> | number | null
    packing?: StringNullableFilter<"ReturnedItems"> | string | null
    quantity?: IntFilter<"ReturnedItems"> | number
    retailPrice?: FloatFilter<"ReturnedItems"> | number
    discountPrice?: FloatNullableFilter<"ReturnedItems"> | number | null
    margin?: FloatFilter<"ReturnedItems"> | number
    returnType?: EnumReturnTypeFilter<"ReturnedItems"> | $Enums.ReturnType
    returnedDate?: DateTimeFilter<"ReturnedItems"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnedItems"> | Date | string
  }

  export type MedicineCreateWithoutVariationsInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutVariationsInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutVariationsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutVariationsInput, MedicineUncheckedCreateWithoutVariationsInput>
  }

  export type BatchCreateWithoutVariationInput = {
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutBatchesInput
    instances?: MedicineInstanceCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutVariationInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutVariationInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutVariationInput, BatchUncheckedCreateWithoutVariationInput>
  }

  export type BatchCreateManyVariationInputEnvelope = {
    data: BatchCreateManyVariationInput | BatchCreateManyVariationInput[]
    skipDuplicates?: boolean
  }

  export type MedicineInstanceCreateWithoutVariationInput = {
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: BatchCreateNestedOneWithoutInstancesInput
    locations?: MedicineLocationCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceUncheckedCreateWithoutVariationInput = {
    id?: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitUncheckedCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceCreateOrConnectWithoutVariationInput = {
    where: MedicineInstanceWhereUniqueInput
    create: XOR<MedicineInstanceCreateWithoutVariationInput, MedicineInstanceUncheckedCreateWithoutVariationInput>
  }

  export type MedicineInstanceCreateManyVariationInputEnvelope = {
    data: MedicineInstanceCreateManyVariationInput | MedicineInstanceCreateManyVariationInput[]
    skipDuplicates?: boolean
  }

  export type MedicineUpsertWithoutVariationsInput = {
    update: XOR<MedicineUpdateWithoutVariationsInput, MedicineUncheckedUpdateWithoutVariationsInput>
    create: XOR<MedicineCreateWithoutVariationsInput, MedicineUncheckedCreateWithoutVariationsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutVariationsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutVariationsInput, MedicineUncheckedUpdateWithoutVariationsInput>
  }

  export type MedicineUpdateWithoutVariationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutVariationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type BatchUpsertWithWhereUniqueWithoutVariationInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutVariationInput, BatchUncheckedUpdateWithoutVariationInput>
    create: XOR<BatchCreateWithoutVariationInput, BatchUncheckedCreateWithoutVariationInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutVariationInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutVariationInput, BatchUncheckedUpdateWithoutVariationInput>
  }

  export type BatchUpdateManyWithWhereWithoutVariationInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutVariationInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: IntFilter<"Batch"> | number
    batchNo?: StringFilter<"Batch"> | string
    mfgDate?: DateTimeFilter<"Batch"> | Date | string
    expiryDate?: DateTimeFilter<"Batch"> | Date | string
    quantity?: IntFilter<"Batch"> | number
    price?: FloatFilter<"Batch"> | number
    variationId?: IntFilter<"Batch"> | number
    purchaseOrderId?: IntNullableFilter<"Batch"> | number | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
  }

  export type MedicineInstanceUpsertWithWhereUniqueWithoutVariationInput = {
    where: MedicineInstanceWhereUniqueInput
    update: XOR<MedicineInstanceUpdateWithoutVariationInput, MedicineInstanceUncheckedUpdateWithoutVariationInput>
    create: XOR<MedicineInstanceCreateWithoutVariationInput, MedicineInstanceUncheckedCreateWithoutVariationInput>
  }

  export type MedicineInstanceUpdateWithWhereUniqueWithoutVariationInput = {
    where: MedicineInstanceWhereUniqueInput
    data: XOR<MedicineInstanceUpdateWithoutVariationInput, MedicineInstanceUncheckedUpdateWithoutVariationInput>
  }

  export type MedicineInstanceUpdateManyWithWhereWithoutVariationInput = {
    where: MedicineInstanceScalarWhereInput
    data: XOR<MedicineInstanceUpdateManyMutationInput, MedicineInstanceUncheckedUpdateManyWithoutVariationInput>
  }

  export type MedicineInstanceScalarWhereInput = {
    AND?: MedicineInstanceScalarWhereInput | MedicineInstanceScalarWhereInput[]
    OR?: MedicineInstanceScalarWhereInput[]
    NOT?: MedicineInstanceScalarWhereInput | MedicineInstanceScalarWhereInput[]
    id?: IntFilter<"MedicineInstance"> | number
    variationId?: IntFilter<"MedicineInstance"> | number
    batchId?: IntFilter<"MedicineInstance"> | number
    expiryDate?: DateTimeFilter<"MedicineInstance"> | Date | string
    quantity?: IntFilter<"MedicineInstance"> | number
    purchasePrice?: FloatFilter<"MedicineInstance"> | number
    sellingPrice?: FloatFilter<"MedicineInstance"> | number
    createdAt?: DateTimeFilter<"MedicineInstance"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineInstance"> | Date | string
  }

  export type VariationCreateWithoutBatchesInput = {
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutVariationsInput
    instances?: MedicineInstanceCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutBatchesInput = {
    id?: number
    medicineId: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutBatchesInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutBatchesInput, VariationUncheckedCreateWithoutBatchesInput>
  }

  export type PurchaseOrderCreateWithoutBatchesInput = {
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    user: UserCreateNestedOneWithoutPurchaseOrdersInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutBatchesInput = {
    id?: number
    medicalStoreId: number
    supplierId?: number | null
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutBatchesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutBatchesInput, PurchaseOrderUncheckedCreateWithoutBatchesInput>
  }

  export type MedicineInstanceCreateWithoutBatchInput = {
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutInstancesInput
    locations?: MedicineLocationCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceUncheckedCreateWithoutBatchInput = {
    id?: number
    variationId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitUncheckedCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceCreateOrConnectWithoutBatchInput = {
    where: MedicineInstanceWhereUniqueInput
    create: XOR<MedicineInstanceCreateWithoutBatchInput, MedicineInstanceUncheckedCreateWithoutBatchInput>
  }

  export type MedicineInstanceCreateManyBatchInputEnvelope = {
    data: MedicineInstanceCreateManyBatchInput | MedicineInstanceCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type SoldItemsCreateWithoutBatchInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutSoldItemsInput
    order: OrderCreateNestedOneWithoutSoldItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutSoldItemsInput
  }

  export type SoldItemsUncheckedCreateWithoutBatchInput = {
    id?: number
    orderId: number
    medicineId: number
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsCreateOrConnectWithoutBatchInput = {
    where: SoldItemsWhereUniqueInput
    create: XOR<SoldItemsCreateWithoutBatchInput, SoldItemsUncheckedCreateWithoutBatchInput>
  }

  export type SoldItemsCreateManyBatchInputEnvelope = {
    data: SoldItemsCreateManyBatchInput | SoldItemsCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type ReturnedItemsCreateWithoutBatchInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutReturnedItemsInput
    order: OrderCreateNestedOneWithoutReturnedItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutReturnedItemsInput
  }

  export type ReturnedItemsUncheckedCreateWithoutBatchInput = {
    id?: number
    orderId: number
    medicineId: number
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateOrConnectWithoutBatchInput = {
    where: ReturnedItemsWhereUniqueInput
    create: XOR<ReturnedItemsCreateWithoutBatchInput, ReturnedItemsUncheckedCreateWithoutBatchInput>
  }

  export type ReturnedItemsCreateManyBatchInputEnvelope = {
    data: ReturnedItemsCreateManyBatchInput | ReturnedItemsCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type VariationUpsertWithoutBatchesInput = {
    update: XOR<VariationUpdateWithoutBatchesInput, VariationUncheckedUpdateWithoutBatchesInput>
    create: XOR<VariationCreateWithoutBatchesInput, VariationUncheckedCreateWithoutBatchesInput>
    where?: VariationWhereInput
  }

  export type VariationUpdateToOneWithWhereWithoutBatchesInput = {
    where?: VariationWhereInput
    data: XOR<VariationUpdateWithoutBatchesInput, VariationUncheckedUpdateWithoutBatchesInput>
  }

  export type VariationUpdateWithoutBatchesInput = {
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutVariationsNestedInput
    instances?: MedicineInstanceUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: MedicineInstanceUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type PurchaseOrderUpsertWithoutBatchesInput = {
    update: XOR<PurchaseOrderUpdateWithoutBatchesInput, PurchaseOrderUncheckedUpdateWithoutBatchesInput>
    create: XOR<PurchaseOrderCreateWithoutBatchesInput, PurchaseOrderUncheckedCreateWithoutBatchesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutBatchesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutBatchesInput, PurchaseOrderUncheckedUpdateWithoutBatchesInput>
  }

  export type PurchaseOrderUpdateWithoutBatchesInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type MedicineInstanceUpsertWithWhereUniqueWithoutBatchInput = {
    where: MedicineInstanceWhereUniqueInput
    update: XOR<MedicineInstanceUpdateWithoutBatchInput, MedicineInstanceUncheckedUpdateWithoutBatchInput>
    create: XOR<MedicineInstanceCreateWithoutBatchInput, MedicineInstanceUncheckedCreateWithoutBatchInput>
  }

  export type MedicineInstanceUpdateWithWhereUniqueWithoutBatchInput = {
    where: MedicineInstanceWhereUniqueInput
    data: XOR<MedicineInstanceUpdateWithoutBatchInput, MedicineInstanceUncheckedUpdateWithoutBatchInput>
  }

  export type MedicineInstanceUpdateManyWithWhereWithoutBatchInput = {
    where: MedicineInstanceScalarWhereInput
    data: XOR<MedicineInstanceUpdateManyMutationInput, MedicineInstanceUncheckedUpdateManyWithoutBatchInput>
  }

  export type SoldItemsUpsertWithWhereUniqueWithoutBatchInput = {
    where: SoldItemsWhereUniqueInput
    update: XOR<SoldItemsUpdateWithoutBatchInput, SoldItemsUncheckedUpdateWithoutBatchInput>
    create: XOR<SoldItemsCreateWithoutBatchInput, SoldItemsUncheckedCreateWithoutBatchInput>
  }

  export type SoldItemsUpdateWithWhereUniqueWithoutBatchInput = {
    where: SoldItemsWhereUniqueInput
    data: XOR<SoldItemsUpdateWithoutBatchInput, SoldItemsUncheckedUpdateWithoutBatchInput>
  }

  export type SoldItemsUpdateManyWithWhereWithoutBatchInput = {
    where: SoldItemsScalarWhereInput
    data: XOR<SoldItemsUpdateManyMutationInput, SoldItemsUncheckedUpdateManyWithoutBatchInput>
  }

  export type ReturnedItemsUpsertWithWhereUniqueWithoutBatchInput = {
    where: ReturnedItemsWhereUniqueInput
    update: XOR<ReturnedItemsUpdateWithoutBatchInput, ReturnedItemsUncheckedUpdateWithoutBatchInput>
    create: XOR<ReturnedItemsCreateWithoutBatchInput, ReturnedItemsUncheckedCreateWithoutBatchInput>
  }

  export type ReturnedItemsUpdateWithWhereUniqueWithoutBatchInput = {
    where: ReturnedItemsWhereUniqueInput
    data: XOR<ReturnedItemsUpdateWithoutBatchInput, ReturnedItemsUncheckedUpdateWithoutBatchInput>
  }

  export type ReturnedItemsUpdateManyWithWhereWithoutBatchInput = {
    where: ReturnedItemsScalarWhereInput
    data: XOR<ReturnedItemsUpdateManyMutationInput, ReturnedItemsUncheckedUpdateManyWithoutBatchInput>
  }

  export type VariationCreateWithoutInstancesInput = {
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutVariationsInput
    batches?: BatchCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutInstancesInput = {
    id?: number
    medicineId: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutInstancesInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutInstancesInput, VariationUncheckedCreateWithoutInstancesInput>
  }

  export type BatchCreateWithoutInstancesInput = {
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutBatchesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutBatchesInput
    soldItems?: SoldItemsCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutInstancesInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutInstancesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutInstancesInput, BatchUncheckedCreateWithoutInstancesInput>
  }

  export type MedicineLocationCreateWithoutInstanceInput = {
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutLocationsInput
    medicine: MedicineCreateNestedOneWithoutLocationsInput
  }

  export type MedicineLocationUncheckedCreateWithoutInstanceInput = {
    id?: number
    medicalStoreId: number
    medicineId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationCreateOrConnectWithoutInstanceInput = {
    where: MedicineLocationWhereUniqueInput
    create: XOR<MedicineLocationCreateWithoutInstanceInput, MedicineLocationUncheckedCreateWithoutInstanceInput>
  }

  export type MedicineLocationCreateManyInstanceInputEnvelope = {
    data: MedicineLocationCreateManyInstanceInput | MedicineLocationCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type SubUnitCreateWithoutInstanceInput = {
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsCreateNestedManyWithoutSubUnitInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitUncheckedCreateWithoutInstanceInput = {
    id?: number
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutSubUnitInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitCreateOrConnectWithoutInstanceInput = {
    where: SubUnitWhereUniqueInput
    create: XOR<SubUnitCreateWithoutInstanceInput, SubUnitUncheckedCreateWithoutInstanceInput>
  }

  export type SubUnitCreateManyInstanceInputEnvelope = {
    data: SubUnitCreateManyInstanceInput | SubUnitCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type StockTransactionCreateWithoutMedicineInstanceInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutStockTransactionsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutMedicineInstanceInput = {
    id?: number
    medicalStoreId: number
    purchaseOrderId?: number | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutMedicineInstanceInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutMedicineInstanceInput, StockTransactionUncheckedCreateWithoutMedicineInstanceInput>
  }

  export type StockTransactionCreateManyMedicineInstanceInputEnvelope = {
    data: StockTransactionCreateManyMedicineInstanceInput | StockTransactionCreateManyMedicineInstanceInput[]
    skipDuplicates?: boolean
  }

  export type VariationUpsertWithoutInstancesInput = {
    update: XOR<VariationUpdateWithoutInstancesInput, VariationUncheckedUpdateWithoutInstancesInput>
    create: XOR<VariationCreateWithoutInstancesInput, VariationUncheckedCreateWithoutInstancesInput>
    where?: VariationWhereInput
  }

  export type VariationUpdateToOneWithWhereWithoutInstancesInput = {
    where?: VariationWhereInput
    data: XOR<VariationUpdateWithoutInstancesInput, VariationUncheckedUpdateWithoutInstancesInput>
  }

  export type VariationUpdateWithoutInstancesInput = {
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutVariationsNestedInput
    batches?: BatchUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutInstancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type BatchUpsertWithoutInstancesInput = {
    update: XOR<BatchUpdateWithoutInstancesInput, BatchUncheckedUpdateWithoutInstancesInput>
    create: XOR<BatchCreateWithoutInstancesInput, BatchUncheckedCreateWithoutInstancesInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutInstancesInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutInstancesInput, BatchUncheckedUpdateWithoutInstancesInput>
  }

  export type BatchUpdateWithoutInstancesInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutBatchesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutBatchesNestedInput
    soldItems?: SoldItemsUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutInstancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type MedicineLocationUpsertWithWhereUniqueWithoutInstanceInput = {
    where: MedicineLocationWhereUniqueInput
    update: XOR<MedicineLocationUpdateWithoutInstanceInput, MedicineLocationUncheckedUpdateWithoutInstanceInput>
    create: XOR<MedicineLocationCreateWithoutInstanceInput, MedicineLocationUncheckedCreateWithoutInstanceInput>
  }

  export type MedicineLocationUpdateWithWhereUniqueWithoutInstanceInput = {
    where: MedicineLocationWhereUniqueInput
    data: XOR<MedicineLocationUpdateWithoutInstanceInput, MedicineLocationUncheckedUpdateWithoutInstanceInput>
  }

  export type MedicineLocationUpdateManyWithWhereWithoutInstanceInput = {
    where: MedicineLocationScalarWhereInput
    data: XOR<MedicineLocationUpdateManyMutationInput, MedicineLocationUncheckedUpdateManyWithoutInstanceInput>
  }

  export type SubUnitUpsertWithWhereUniqueWithoutInstanceInput = {
    where: SubUnitWhereUniqueInput
    update: XOR<SubUnitUpdateWithoutInstanceInput, SubUnitUncheckedUpdateWithoutInstanceInput>
    create: XOR<SubUnitCreateWithoutInstanceInput, SubUnitUncheckedCreateWithoutInstanceInput>
  }

  export type SubUnitUpdateWithWhereUniqueWithoutInstanceInput = {
    where: SubUnitWhereUniqueInput
    data: XOR<SubUnitUpdateWithoutInstanceInput, SubUnitUncheckedUpdateWithoutInstanceInput>
  }

  export type SubUnitUpdateManyWithWhereWithoutInstanceInput = {
    where: SubUnitScalarWhereInput
    data: XOR<SubUnitUpdateManyMutationInput, SubUnitUncheckedUpdateManyWithoutInstanceInput>
  }

  export type SubUnitScalarWhereInput = {
    AND?: SubUnitScalarWhereInput | SubUnitScalarWhereInput[]
    OR?: SubUnitScalarWhereInput[]
    NOT?: SubUnitScalarWhereInput | SubUnitScalarWhereInput[]
    id?: IntFilter<"SubUnit"> | number
    unitId?: IntFilter<"SubUnit"> | number
    name?: StringFilter<"SubUnit"> | string
    description?: StringNullableFilter<"SubUnit"> | string | null
    unitType?: StringFilter<"SubUnit"> | string
    subUnitCount?: IntFilter<"SubUnit"> | number
    subUnitPrice?: FloatFilter<"SubUnit"> | number
    isSold?: BoolFilter<"SubUnit"> | boolean
    isReturnedByCustomer?: BoolFilter<"SubUnit"> | boolean
    isReturnedToSupplier?: BoolFilter<"SubUnit"> | boolean
    createdAt?: DateTimeFilter<"SubUnit"> | Date | string
    updatedAt?: DateTimeFilter<"SubUnit"> | Date | string
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutMedicineInstanceInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutMedicineInstanceInput, StockTransactionUncheckedUpdateWithoutMedicineInstanceInput>
    create: XOR<StockTransactionCreateWithoutMedicineInstanceInput, StockTransactionUncheckedCreateWithoutMedicineInstanceInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutMedicineInstanceInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutMedicineInstanceInput, StockTransactionUncheckedUpdateWithoutMedicineInstanceInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutMedicineInstanceInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutMedicineInstanceInput>
  }

  export type MedicineInstanceCreateWithoutSubunitsInput = {
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutInstancesInput
    batch: BatchCreateNestedOneWithoutInstancesInput
    locations?: MedicineLocationCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceUncheckedCreateWithoutSubunitsInput = {
    id?: number
    variationId: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceCreateOrConnectWithoutSubunitsInput = {
    where: MedicineInstanceWhereUniqueInput
    create: XOR<MedicineInstanceCreateWithoutSubunitsInput, MedicineInstanceUncheckedCreateWithoutSubunitsInput>
  }

  export type SoldItemsCreateWithoutSubUnitInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutSoldItemsInput
    order: OrderCreateNestedOneWithoutSoldItemsInput
    batch?: BatchCreateNestedOneWithoutSoldItemsInput
  }

  export type SoldItemsUncheckedCreateWithoutSubUnitInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsCreateOrConnectWithoutSubUnitInput = {
    where: SoldItemsWhereUniqueInput
    create: XOR<SoldItemsCreateWithoutSubUnitInput, SoldItemsUncheckedCreateWithoutSubUnitInput>
  }

  export type SoldItemsCreateManySubUnitInputEnvelope = {
    data: SoldItemsCreateManySubUnitInput | SoldItemsCreateManySubUnitInput[]
    skipDuplicates?: boolean
  }

  export type ReturnedItemsCreateWithoutSubUnitInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutReturnedItemsInput
    order: OrderCreateNestedOneWithoutReturnedItemsInput
    batch?: BatchCreateNestedOneWithoutReturnedItemsInput
  }

  export type ReturnedItemsUncheckedCreateWithoutSubUnitInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateOrConnectWithoutSubUnitInput = {
    where: ReturnedItemsWhereUniqueInput
    create: XOR<ReturnedItemsCreateWithoutSubUnitInput, ReturnedItemsUncheckedCreateWithoutSubUnitInput>
  }

  export type ReturnedItemsCreateManySubUnitInputEnvelope = {
    data: ReturnedItemsCreateManySubUnitInput | ReturnedItemsCreateManySubUnitInput[]
    skipDuplicates?: boolean
  }

  export type MedicineInstanceUpsertWithoutSubunitsInput = {
    update: XOR<MedicineInstanceUpdateWithoutSubunitsInput, MedicineInstanceUncheckedUpdateWithoutSubunitsInput>
    create: XOR<MedicineInstanceCreateWithoutSubunitsInput, MedicineInstanceUncheckedCreateWithoutSubunitsInput>
    where?: MedicineInstanceWhereInput
  }

  export type MedicineInstanceUpdateToOneWithWhereWithoutSubunitsInput = {
    where?: MedicineInstanceWhereInput
    data: XOR<MedicineInstanceUpdateWithoutSubunitsInput, MedicineInstanceUncheckedUpdateWithoutSubunitsInput>
  }

  export type MedicineInstanceUpdateWithoutSubunitsInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutInstancesNestedInput
    batch?: BatchUpdateOneRequiredWithoutInstancesNestedInput
    locations?: MedicineLocationUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateWithoutSubunitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type SoldItemsUpsertWithWhereUniqueWithoutSubUnitInput = {
    where: SoldItemsWhereUniqueInput
    update: XOR<SoldItemsUpdateWithoutSubUnitInput, SoldItemsUncheckedUpdateWithoutSubUnitInput>
    create: XOR<SoldItemsCreateWithoutSubUnitInput, SoldItemsUncheckedCreateWithoutSubUnitInput>
  }

  export type SoldItemsUpdateWithWhereUniqueWithoutSubUnitInput = {
    where: SoldItemsWhereUniqueInput
    data: XOR<SoldItemsUpdateWithoutSubUnitInput, SoldItemsUncheckedUpdateWithoutSubUnitInput>
  }

  export type SoldItemsUpdateManyWithWhereWithoutSubUnitInput = {
    where: SoldItemsScalarWhereInput
    data: XOR<SoldItemsUpdateManyMutationInput, SoldItemsUncheckedUpdateManyWithoutSubUnitInput>
  }

  export type ReturnedItemsUpsertWithWhereUniqueWithoutSubUnitInput = {
    where: ReturnedItemsWhereUniqueInput
    update: XOR<ReturnedItemsUpdateWithoutSubUnitInput, ReturnedItemsUncheckedUpdateWithoutSubUnitInput>
    create: XOR<ReturnedItemsCreateWithoutSubUnitInput, ReturnedItemsUncheckedCreateWithoutSubUnitInput>
  }

  export type ReturnedItemsUpdateWithWhereUniqueWithoutSubUnitInput = {
    where: ReturnedItemsWhereUniqueInput
    data: XOR<ReturnedItemsUpdateWithoutSubUnitInput, ReturnedItemsUncheckedUpdateWithoutSubUnitInput>
  }

  export type ReturnedItemsUpdateManyWithWhereWithoutSubUnitInput = {
    where: ReturnedItemsScalarWhereInput
    data: XOR<ReturnedItemsUpdateManyMutationInput, ReturnedItemsUncheckedUpdateManyWithoutSubUnitInput>
  }

  export type MedicalStoreCreateWithoutLocationsInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutLocationsInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutLocationsInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutLocationsInput, MedicalStoreUncheckedCreateWithoutLocationsInput>
  }

  export type MedicineCreateWithoutLocationsInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutLocationsInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutLocationsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutLocationsInput, MedicineUncheckedCreateWithoutLocationsInput>
  }

  export type MedicineInstanceCreateWithoutLocationsInput = {
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutInstancesInput
    batch: BatchCreateNestedOneWithoutInstancesInput
    subunits?: SubUnitCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceUncheckedCreateWithoutLocationsInput = {
    id?: number
    variationId: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subunits?: SubUnitUncheckedCreateNestedManyWithoutInstanceInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicineInstanceInput
  }

  export type MedicineInstanceCreateOrConnectWithoutLocationsInput = {
    where: MedicineInstanceWhereUniqueInput
    create: XOR<MedicineInstanceCreateWithoutLocationsInput, MedicineInstanceUncheckedCreateWithoutLocationsInput>
  }

  export type MedicalStoreUpsertWithoutLocationsInput = {
    update: XOR<MedicalStoreUpdateWithoutLocationsInput, MedicalStoreUncheckedUpdateWithoutLocationsInput>
    create: XOR<MedicalStoreCreateWithoutLocationsInput, MedicalStoreUncheckedCreateWithoutLocationsInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutLocationsInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutLocationsInput, MedicalStoreUncheckedUpdateWithoutLocationsInput>
  }

  export type MedicalStoreUpdateWithoutLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicineUpsertWithoutLocationsInput = {
    update: XOR<MedicineUpdateWithoutLocationsInput, MedicineUncheckedUpdateWithoutLocationsInput>
    create: XOR<MedicineCreateWithoutLocationsInput, MedicineUncheckedCreateWithoutLocationsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutLocationsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutLocationsInput, MedicineUncheckedUpdateWithoutLocationsInput>
  }

  export type MedicineUpdateWithoutLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineInstanceUpsertWithoutLocationsInput = {
    update: XOR<MedicineInstanceUpdateWithoutLocationsInput, MedicineInstanceUncheckedUpdateWithoutLocationsInput>
    create: XOR<MedicineInstanceCreateWithoutLocationsInput, MedicineInstanceUncheckedCreateWithoutLocationsInput>
    where?: MedicineInstanceWhereInput
  }

  export type MedicineInstanceUpdateToOneWithWhereWithoutLocationsInput = {
    where?: MedicineInstanceWhereInput
    data: XOR<MedicineInstanceUpdateWithoutLocationsInput, MedicineInstanceUncheckedUpdateWithoutLocationsInput>
  }

  export type MedicineInstanceUpdateWithoutLocationsInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutInstancesNestedInput
    batch?: BatchUpdateOneRequiredWithoutInstancesNestedInput
    subunits?: SubUnitUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subunits?: SubUnitUncheckedUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicalStoreCreateWithoutMedicinesInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutMedicinesInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutMedicinesInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutMedicinesInput, MedicalStoreUncheckedCreateWithoutMedicinesInput>
  }

  export type MedicineCreateWithoutMedicalStoreMedicinesInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutMedicalStoreMedicinesInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutMedicalStoreMedicinesInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutMedicalStoreMedicinesInput, MedicineUncheckedCreateWithoutMedicalStoreMedicinesInput>
  }

  export type MedicalStoreUpsertWithoutMedicinesInput = {
    update: XOR<MedicalStoreUpdateWithoutMedicinesInput, MedicalStoreUncheckedUpdateWithoutMedicinesInput>
    create: XOR<MedicalStoreCreateWithoutMedicinesInput, MedicalStoreUncheckedCreateWithoutMedicinesInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutMedicinesInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutMedicinesInput, MedicalStoreUncheckedUpdateWithoutMedicinesInput>
  }

  export type MedicalStoreUpdateWithoutMedicinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutMedicinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicineUpsertWithoutMedicalStoreMedicinesInput = {
    update: XOR<MedicineUpdateWithoutMedicalStoreMedicinesInput, MedicineUncheckedUpdateWithoutMedicalStoreMedicinesInput>
    create: XOR<MedicineCreateWithoutMedicalStoreMedicinesInput, MedicineUncheckedCreateWithoutMedicalStoreMedicinesInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutMedicalStoreMedicinesInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutMedicalStoreMedicinesInput, MedicineUncheckedUpdateWithoutMedicalStoreMedicinesInput>
  }

  export type MedicineUpdateWithoutMedicalStoreMedicinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutMedicalStoreMedicinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineCreateWithoutExpiryRecordsInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutExpiryRecordsInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutExpiryRecordsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutExpiryRecordsInput, MedicineUncheckedCreateWithoutExpiryRecordsInput>
  }

  export type MedicineUpsertWithoutExpiryRecordsInput = {
    update: XOR<MedicineUpdateWithoutExpiryRecordsInput, MedicineUncheckedUpdateWithoutExpiryRecordsInput>
    create: XOR<MedicineCreateWithoutExpiryRecordsInput, MedicineUncheckedCreateWithoutExpiryRecordsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutExpiryRecordsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutExpiryRecordsInput, MedicineUncheckedUpdateWithoutExpiryRecordsInput>
  }

  export type MedicineUpdateWithoutExpiryRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutExpiryRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicalStoreCreateWithoutStockTransactionsInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutStockTransactionsInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutStockTransactionsInput, MedicalStoreUncheckedCreateWithoutStockTransactionsInput>
  }

  export type MedicineInstanceCreateWithoutStockTransactionsInput = {
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutInstancesInput
    batch: BatchCreateNestedOneWithoutInstancesInput
    locations?: MedicineLocationCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitCreateNestedManyWithoutInstanceInput
  }

  export type MedicineInstanceUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    variationId: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutInstanceInput
    subunits?: SubUnitUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type MedicineInstanceCreateOrConnectWithoutStockTransactionsInput = {
    where: MedicineInstanceWhereUniqueInput
    create: XOR<MedicineInstanceCreateWithoutStockTransactionsInput, MedicineInstanceUncheckedCreateWithoutStockTransactionsInput>
  }

  export type PurchaseOrderCreateWithoutStockTransactionsInput = {
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutPurchaseOrdersInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    user: UserCreateNestedOneWithoutPurchaseOrdersInput
    batches?: BatchCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    medicalStoreId: number
    supplierId?: number | null
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutStockTransactionsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutStockTransactionsInput, PurchaseOrderUncheckedCreateWithoutStockTransactionsInput>
  }

  export type MedicalStoreUpsertWithoutStockTransactionsInput = {
    update: XOR<MedicalStoreUpdateWithoutStockTransactionsInput, MedicalStoreUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<MedicalStoreCreateWithoutStockTransactionsInput, MedicalStoreUncheckedCreateWithoutStockTransactionsInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutStockTransactionsInput, MedicalStoreUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type MedicalStoreUpdateWithoutStockTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicineInstanceUpsertWithoutStockTransactionsInput = {
    update: XOR<MedicineInstanceUpdateWithoutStockTransactionsInput, MedicineInstanceUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<MedicineInstanceCreateWithoutStockTransactionsInput, MedicineInstanceUncheckedCreateWithoutStockTransactionsInput>
    where?: MedicineInstanceWhereInput
  }

  export type MedicineInstanceUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: MedicineInstanceWhereInput
    data: XOR<MedicineInstanceUpdateWithoutStockTransactionsInput, MedicineInstanceUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type MedicineInstanceUpdateWithoutStockTransactionsInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutInstancesNestedInput
    batch?: BatchUpdateOneRequiredWithoutInstancesNestedInput
    locations?: MedicineLocationUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUpdateManyWithoutInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type PurchaseOrderUpsertWithoutStockTransactionsInput = {
    update: XOR<PurchaseOrderUpdateWithoutStockTransactionsInput, PurchaseOrderUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<PurchaseOrderCreateWithoutStockTransactionsInput, PurchaseOrderUncheckedCreateWithoutStockTransactionsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutStockTransactionsInput, PurchaseOrderUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type PurchaseOrderUpdateWithoutStockTransactionsInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    batches?: BatchUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type MedicalStoreCreateWithoutPurchaseOrdersInput = {
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMedicalStoreInput
    medicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    ownerId: number
    name: string
    address: string
    licenseNumber: string
    phoneNumber: string
    ntnNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicalStoreInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicalStoreInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutMedicalStoreInput
    companies?: CompanyUncheckedCreateNestedManyWithoutMedicalStoreInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutMedicalStoreInput
  }

  export type MedicalStoreCreateOrConnectWithoutPurchaseOrdersInput = {
    where: MedicalStoreWhereUniqueInput
    create: XOR<MedicalStoreCreateWithoutPurchaseOrdersInput, MedicalStoreUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutSuppliersInput
    company: CompanyCreateNestedOneWithoutSuppliersInput
    medicines?: MedicineCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    companyId: number
    medicalStoreId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: MedicineUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type UserCreateWithoutPurchaseOrdersInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: UserCreateNestedOneWithoutChildrenInput
    children?: UserCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreCreateNestedOneWithoutOwnerInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserUncheckedCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchaseOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type BatchCreateWithoutPurchaseOrderInput = {
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutBatchesInput
    instances?: MedicineInstanceCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutPurchaseOrderInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutPurchaseOrderInput, BatchUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type BatchCreateManyPurchaseOrderInputEnvelope = {
    data: BatchCreateManyPurchaseOrderInput | BatchCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type StockTransactionCreateWithoutPurchaseOrderInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalStore: MedicalStoreCreateNestedOneWithoutStockTransactionsInput
    medicineInstance: MedicineInstanceCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    medicalStoreId: number
    medicineInstanceId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutPurchaseOrderInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutPurchaseOrderInput, StockTransactionUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type StockTransactionCreateManyPurchaseOrderInputEnvelope = {
    data: StockTransactionCreateManyPurchaseOrderInput | StockTransactionCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type MedicalStoreUpsertWithoutPurchaseOrdersInput = {
    update: XOR<MedicalStoreUpdateWithoutPurchaseOrdersInput, MedicalStoreUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<MedicalStoreCreateWithoutPurchaseOrdersInput, MedicalStoreUncheckedCreateWithoutPurchaseOrdersInput>
    where?: MedicalStoreWhereInput
  }

  export type MedicalStoreUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: MedicalStoreWhereInput
    data: XOR<MedicalStoreUpdateWithoutPurchaseOrdersInput, MedicalStoreUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type MedicalStoreUpdateWithoutPurchaseOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMedicalStoreNestedInput
    medicines?: MedicalStoreMedicineUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUpdateManyWithoutMedicalStoreNestedInput
  }

  export type MedicalStoreUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ntnNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicalStoreNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicalStoreNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutMedicalStoreNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutMedicalStoreNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutSuppliersNestedInput
    company?: CompanyUpdateOneRequiredWithoutSuppliersNestedInput
    medicines?: MedicineUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicineUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserUpsertWithoutPurchaseOrdersInput = {
    update: XOR<UserUpdateWithoutPurchaseOrdersInput, UserUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseOrdersInput, UserUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateWithoutPurchaseOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneWithoutChildrenNestedInput
    children?: UserUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUpdateOneWithoutOwnerNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUncheckedUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BatchUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutPurchaseOrderInput, BatchUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<BatchCreateWithoutPurchaseOrderInput, BatchUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutPurchaseOrderInput, BatchUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type BatchUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutPurchaseOrderInput, StockTransactionUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<StockTransactionCreateWithoutPurchaseOrderInput, StockTransactionUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutPurchaseOrderInput, StockTransactionUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type UserCreateWithoutOrdersInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: UserCreateNestedOneWithoutChildrenInput
    children?: UserCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreCreateNestedOneWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserUncheckedCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type SoldItemsCreateWithoutOrderInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutSoldItemsInput
    batch?: BatchCreateNestedOneWithoutSoldItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutSoldItemsInput
  }

  export type SoldItemsUncheckedCreateWithoutOrderInput = {
    id?: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsCreateOrConnectWithoutOrderInput = {
    where: SoldItemsWhereUniqueInput
    create: XOR<SoldItemsCreateWithoutOrderInput, SoldItemsUncheckedCreateWithoutOrderInput>
  }

  export type SoldItemsCreateManyOrderInputEnvelope = {
    data: SoldItemsCreateManyOrderInput | SoldItemsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReturnedItemsCreateWithoutOrderInput = {
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutReturnedItemsInput
    batch?: BatchCreateNestedOneWithoutReturnedItemsInput
    subUnit?: SubUnitCreateNestedOneWithoutReturnedItemsInput
  }

  export type ReturnedItemsUncheckedCreateWithoutOrderInput = {
    id?: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateOrConnectWithoutOrderInput = {
    where: ReturnedItemsWhereUniqueInput
    create: XOR<ReturnedItemsCreateWithoutOrderInput, ReturnedItemsUncheckedCreateWithoutOrderInput>
  }

  export type ReturnedItemsCreateManyOrderInputEnvelope = {
    data: ReturnedItemsCreateManyOrderInput | ReturnedItemsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneWithoutChildrenNestedInput
    children?: UserUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUpdateOneWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUncheckedUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUpsertWithWhereUniqueWithoutOrderInput = {
    where: SoldItemsWhereUniqueInput
    update: XOR<SoldItemsUpdateWithoutOrderInput, SoldItemsUncheckedUpdateWithoutOrderInput>
    create: XOR<SoldItemsCreateWithoutOrderInput, SoldItemsUncheckedCreateWithoutOrderInput>
  }

  export type SoldItemsUpdateWithWhereUniqueWithoutOrderInput = {
    where: SoldItemsWhereUniqueInput
    data: XOR<SoldItemsUpdateWithoutOrderInput, SoldItemsUncheckedUpdateWithoutOrderInput>
  }

  export type SoldItemsUpdateManyWithWhereWithoutOrderInput = {
    where: SoldItemsScalarWhereInput
    data: XOR<SoldItemsUpdateManyMutationInput, SoldItemsUncheckedUpdateManyWithoutOrderInput>
  }

  export type ReturnedItemsUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReturnedItemsWhereUniqueInput
    update: XOR<ReturnedItemsUpdateWithoutOrderInput, ReturnedItemsUncheckedUpdateWithoutOrderInput>
    create: XOR<ReturnedItemsCreateWithoutOrderInput, ReturnedItemsUncheckedCreateWithoutOrderInput>
  }

  export type ReturnedItemsUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReturnedItemsWhereUniqueInput
    data: XOR<ReturnedItemsUpdateWithoutOrderInput, ReturnedItemsUncheckedUpdateWithoutOrderInput>
  }

  export type ReturnedItemsUpdateManyWithWhereWithoutOrderInput = {
    where: ReturnedItemsScalarWhereInput
    data: XOR<ReturnedItemsUpdateManyMutationInput, ReturnedItemsUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    soldItems?: SoldItemsCreateNestedManyWithoutOrderInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    userId: number
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutOrderInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type MedicineCreateWithoutSoldItemsInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutSoldItemsInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutSoldItemsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutSoldItemsInput, MedicineUncheckedCreateWithoutSoldItemsInput>
  }

  export type OrderCreateWithoutSoldItemsInput = {
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSoldItemsInput = {
    id?: number
    userId: number
    customerId?: number | null
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSoldItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSoldItemsInput, OrderUncheckedCreateWithoutSoldItemsInput>
  }

  export type BatchCreateWithoutSoldItemsInput = {
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutBatchesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutBatchesInput
    instances?: MedicineInstanceCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutSoldItemsInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutBatchInput
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutSoldItemsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutSoldItemsInput, BatchUncheckedCreateWithoutSoldItemsInput>
  }

  export type SubUnitCreateWithoutSoldItemsInput = {
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: MedicineInstanceCreateNestedOneWithoutSubunitsInput
    returnedItems?: ReturnedItemsCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitUncheckedCreateWithoutSoldItemsInput = {
    id?: number
    unitId: number
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    returnedItems?: ReturnedItemsUncheckedCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitCreateOrConnectWithoutSoldItemsInput = {
    where: SubUnitWhereUniqueInput
    create: XOR<SubUnitCreateWithoutSoldItemsInput, SubUnitUncheckedCreateWithoutSoldItemsInput>
  }

  export type MedicineUpsertWithoutSoldItemsInput = {
    update: XOR<MedicineUpdateWithoutSoldItemsInput, MedicineUncheckedUpdateWithoutSoldItemsInput>
    create: XOR<MedicineCreateWithoutSoldItemsInput, MedicineUncheckedCreateWithoutSoldItemsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutSoldItemsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutSoldItemsInput, MedicineUncheckedUpdateWithoutSoldItemsInput>
  }

  export type MedicineUpdateWithoutSoldItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutSoldItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type OrderUpsertWithoutSoldItemsInput = {
    update: XOR<OrderUpdateWithoutSoldItemsInput, OrderUncheckedUpdateWithoutSoldItemsInput>
    create: XOR<OrderCreateWithoutSoldItemsInput, OrderUncheckedCreateWithoutSoldItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutSoldItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutSoldItemsInput, OrderUncheckedUpdateWithoutSoldItemsInput>
  }

  export type OrderUpdateWithoutSoldItemsInput = {
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSoldItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BatchUpsertWithoutSoldItemsInput = {
    update: XOR<BatchUpdateWithoutSoldItemsInput, BatchUncheckedUpdateWithoutSoldItemsInput>
    create: XOR<BatchCreateWithoutSoldItemsInput, BatchUncheckedCreateWithoutSoldItemsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutSoldItemsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutSoldItemsInput, BatchUncheckedUpdateWithoutSoldItemsInput>
  }

  export type BatchUpdateWithoutSoldItemsInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutBatchesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutBatchesNestedInput
    instances?: MedicineInstanceUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutSoldItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: MedicineInstanceUncheckedUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type SubUnitUpsertWithoutSoldItemsInput = {
    update: XOR<SubUnitUpdateWithoutSoldItemsInput, SubUnitUncheckedUpdateWithoutSoldItemsInput>
    create: XOR<SubUnitCreateWithoutSoldItemsInput, SubUnitUncheckedCreateWithoutSoldItemsInput>
    where?: SubUnitWhereInput
  }

  export type SubUnitUpdateToOneWithWhereWithoutSoldItemsInput = {
    where?: SubUnitWhereInput
    data: XOR<SubUnitUpdateWithoutSoldItemsInput, SubUnitUncheckedUpdateWithoutSoldItemsInput>
  }

  export type SubUnitUpdateWithoutSoldItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: MedicineInstanceUpdateOneRequiredWithoutSubunitsNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutSubUnitNestedInput
  }

  export type SubUnitUncheckedUpdateWithoutSoldItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutSubUnitNestedInput
  }

  export type MedicineCreateWithoutReturnedItemsInput = {
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMedicinesInput
    supplier: SupplierCreateNestedOneWithoutMedicinesInput
    variations?: VariationCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutReturnedItemsInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variations?: VariationUncheckedCreateNestedManyWithoutMedicineInput
    locations?: MedicineLocationUncheckedCreateNestedManyWithoutMedicineInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedCreateNestedManyWithoutMedicineInput
    expiryRecords?: MedicineExpiryUncheckedCreateNestedManyWithoutMedicineInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutReturnedItemsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutReturnedItemsInput, MedicineUncheckedCreateWithoutReturnedItemsInput>
  }

  export type OrderCreateWithoutReturnedItemsInput = {
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    soldItems?: SoldItemsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReturnedItemsInput = {
    id?: number
    userId: number
    customerId?: number | null
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReturnedItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReturnedItemsInput, OrderUncheckedCreateWithoutReturnedItemsInput>
  }

  export type BatchCreateWithoutReturnedItemsInput = {
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutBatchesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutBatchesInput
    instances?: MedicineInstanceCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutReturnedItemsInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: MedicineInstanceUncheckedCreateNestedManyWithoutBatchInput
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutReturnedItemsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutReturnedItemsInput, BatchUncheckedCreateWithoutReturnedItemsInput>
  }

  export type SubUnitCreateWithoutReturnedItemsInput = {
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: MedicineInstanceCreateNestedOneWithoutSubunitsInput
    soldItems?: SoldItemsCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitUncheckedCreateWithoutReturnedItemsInput = {
    id?: number
    unitId: number
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soldItems?: SoldItemsUncheckedCreateNestedManyWithoutSubUnitInput
  }

  export type SubUnitCreateOrConnectWithoutReturnedItemsInput = {
    where: SubUnitWhereUniqueInput
    create: XOR<SubUnitCreateWithoutReturnedItemsInput, SubUnitUncheckedCreateWithoutReturnedItemsInput>
  }

  export type MedicineUpsertWithoutReturnedItemsInput = {
    update: XOR<MedicineUpdateWithoutReturnedItemsInput, MedicineUncheckedUpdateWithoutReturnedItemsInput>
    create: XOR<MedicineCreateWithoutReturnedItemsInput, MedicineUncheckedCreateWithoutReturnedItemsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutReturnedItemsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutReturnedItemsInput, MedicineUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type MedicineUpdateWithoutReturnedItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutReturnedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type OrderUpsertWithoutReturnedItemsInput = {
    update: XOR<OrderUpdateWithoutReturnedItemsInput, OrderUncheckedUpdateWithoutReturnedItemsInput>
    create: XOR<OrderCreateWithoutReturnedItemsInput, OrderUncheckedCreateWithoutReturnedItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReturnedItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReturnedItemsInput, OrderUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type OrderUpdateWithoutReturnedItemsInput = {
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    soldItems?: SoldItemsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReturnedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BatchUpsertWithoutReturnedItemsInput = {
    update: XOR<BatchUpdateWithoutReturnedItemsInput, BatchUncheckedUpdateWithoutReturnedItemsInput>
    create: XOR<BatchCreateWithoutReturnedItemsInput, BatchUncheckedCreateWithoutReturnedItemsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutReturnedItemsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutReturnedItemsInput, BatchUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type BatchUpdateWithoutReturnedItemsInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutBatchesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutBatchesNestedInput
    instances?: MedicineInstanceUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutReturnedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: MedicineInstanceUncheckedUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type SubUnitUpsertWithoutReturnedItemsInput = {
    update: XOR<SubUnitUpdateWithoutReturnedItemsInput, SubUnitUncheckedUpdateWithoutReturnedItemsInput>
    create: XOR<SubUnitCreateWithoutReturnedItemsInput, SubUnitUncheckedCreateWithoutReturnedItemsInput>
    where?: SubUnitWhereInput
  }

  export type SubUnitUpdateToOneWithWhereWithoutReturnedItemsInput = {
    where?: SubUnitWhereInput
    data: XOR<SubUnitUpdateWithoutReturnedItemsInput, SubUnitUncheckedUpdateWithoutReturnedItemsInput>
  }

  export type SubUnitUpdateWithoutReturnedItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: MedicineInstanceUpdateOneRequiredWithoutSubunitsNestedInput
    soldItems?: SoldItemsUpdateManyWithoutSubUnitNestedInput
  }

  export type SubUnitUncheckedUpdateWithoutReturnedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutSubUnitNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: UserCreateNestedOneWithoutChildrenInput
    children?: UserCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreCreateNestedOneWithoutOwnerInput
    orders?: OrderCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    parentId?: number | null
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: UserUncheckedCreateNestedManyWithoutParentInput
    medicalStore?: MedicalStoreUncheckedCreateNestedOneWithoutOwnerInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneWithoutChildrenNestedInput
    children?: UserUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUpdateOneWithoutOwnerNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUncheckedUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyParentInput = {
    id?: number
    name: string
    address: string
    city: string
    phoneNumber: string
    email: string
    employeeId: string
    password: string
    role: $Enums.Role
    isActive?: boolean
    medicalStoreId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: number
    customerId?: number | null
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    action: string
    entity: string
    entityId: number
    description?: string | null
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManyUserInput = {
    id?: number
    medicalStoreId: number
    supplierId?: number | null
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUpdateOneWithoutOwnerNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: UserUncheckedUpdateManyWithoutParentNestedInput
    medicalStore?: MedicalStoreUncheckedUpdateOneWithoutOwnerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    soldItems?: SoldItemsUpdateManyWithoutOrderNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutOrderNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutUserInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    batches?: BatchUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineCreateManyMedicalStoreInput = {
    id?: number
    medicineId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationCreateManyMedicalStoreInput = {
    id?: number
    medicineId: number
    medicineInstanceId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyMedicalStoreInput = {
    id?: number
    supplierId?: number | null
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionCreateManyMedicalStoreInput = {
    id?: number
    medicineInstanceId: number
    purchaseOrderId?: number | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCreateManyMedicalStoreInput = {
    id?: number
    companyCode: string
    name: string
    address: string
    phone?: string | null
    mobile?: string | null
    distributorCode?: string | null
    ntnNumber?: string | null
    registrationDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyMedicalStoreInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreMedicineUpdateWithoutMedicalStoreInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutMedicalStoreMedicinesNestedInput
  }

  export type MedicalStoreMedicineUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineUncheckedUpdateManyWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationUpdateWithoutMedicalStoreInput = {
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutLocationsNestedInput
    instance?: MedicineInstanceUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type MedicineLocationUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationUncheckedUpdateManyWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutMedicalStoreInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    batches?: BatchUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUpdateWithoutMedicalStoreInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineInstance?: MedicineInstanceUpdateOneRequiredWithoutStockTransactionsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUpdateWithoutMedicalStoreInput = {
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    medicines?: MedicineUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    medicines?: MedicineUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    distributorCode?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutMedicalStoreInput = {
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSuppliersNestedInput
    medicines?: MedicineUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicineUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutMedicalStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateManyCompanyInput = {
    id?: number
    supplierCode?: string | null
    name: string
    email?: string | null
    phone?: string | null
    address: string
    distributorCode: string
    ntnNumber?: string | null
    isActive?: boolean
    medicalStoreId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineCreateManyCompanyInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    supplierId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateWithoutCompanyInput = {
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutSuppliersNestedInput
    medicines?: MedicineUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: MedicineUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    distributorCode?: StringFieldUpdateOperationsInput | string
    ntnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineCreateManySupplierInput = {
    id?: number
    name: string
    formula?: string | null
    description?: string | null
    minquantity: number
    companyId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: number
    medicalStoreId: number
    userId: number
    orderDate: Date | string
    status?: string
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineUpdateWithoutSupplierInput = {
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMedicinesNestedInput
    variations?: VariationUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variations?: VariationUncheckedUpdateManyWithoutMedicineNestedInput
    locations?: MedicineLocationUncheckedUpdateManyWithoutMedicineNestedInput
    medicalStoreMedicines?: MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    expiryRecords?: MedicineExpiryUncheckedUpdateManyWithoutMedicineNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutMedicineNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minquantity?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    batches?: BatchUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationCreateManyMedicineInput = {
    id?: number
    potency: string
    packaging: string
    unitType: string
    unitsPerPack: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationCreateManyMedicineInput = {
    id?: number
    medicalStoreId: number
    medicineInstanceId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalStoreMedicineCreateManyMedicineInput = {
    id?: number
    medicalStoreId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineExpiryCreateManyMedicineInput = {
    id?: number
    expiryDate: Date | string
    isNearExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsCreateManyMedicineInput = {
    id?: number
    orderId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateManyMedicineInput = {
    id?: number
    orderId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type VariationUpdateWithoutMedicineInput = {
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutVariationNestedInput
    instances?: MedicineInstanceUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutVariationNestedInput
    instances?: MedicineInstanceUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    potency?: StringFieldUpdateOperationsInput | string
    packaging?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    unitsPerPack?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationUpdateWithoutMedicineInput = {
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutLocationsNestedInput
    instance?: MedicineInstanceUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type MedicineLocationUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineUpdateWithoutMedicineInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutMedicinesNestedInput
  }

  export type MedicalStoreMedicineUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalStoreMedicineUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineExpiryUpdateWithoutMedicineInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineExpiryUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineExpiryUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isNearExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUpdateWithoutMedicineInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutSoldItemsNestedInput
    batch?: BatchUpdateOneWithoutSoldItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutSoldItemsNestedInput
  }

  export type SoldItemsUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUpdateWithoutMedicineInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReturnedItemsNestedInput
    batch?: BatchUpdateOneWithoutReturnedItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutReturnedItemsNestedInput
  }

  export type ReturnedItemsUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyVariationInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    purchaseOrderId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineInstanceCreateManyVariationInput = {
    id?: number
    batchId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateWithoutVariationInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutBatchesNestedInput
    instances?: MedicineInstanceUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: MedicineInstanceUncheckedUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineInstanceUpdateWithoutVariationInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutInstancesNestedInput
    locations?: MedicineLocationUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateWithoutVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUncheckedUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateManyWithoutVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineInstanceCreateManyBatchInput = {
    id?: number
    variationId: number
    expiryDate: Date | string
    quantity: number
    purchasePrice: number
    sellingPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsCreateManyBatchInput = {
    id?: number
    orderId: number
    medicineId: number
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateManyBatchInput = {
    id?: number
    orderId: number
    medicineId: number
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineInstanceUpdateWithoutBatchInput = {
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutInstancesNestedInput
    locations?: MedicineLocationUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: MedicineLocationUncheckedUpdateManyWithoutInstanceNestedInput
    subunits?: SubUnitUncheckedUpdateManyWithoutInstanceNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutMedicineInstanceNestedInput
  }

  export type MedicineInstanceUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUpdateWithoutBatchInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutSoldItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutSoldItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutSoldItemsNestedInput
  }

  export type SoldItemsUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUpdateWithoutBatchInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutReturnedItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutReturnedItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutReturnedItemsNestedInput
  }

  export type ReturnedItemsUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationCreateManyInstanceInput = {
    id?: number
    medicalStoreId: number
    medicineId: number
    location: string
    rank?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubUnitCreateManyInstanceInput = {
    id?: number
    name: string
    description?: string | null
    unitType: string
    subUnitCount: number
    subUnitPrice: number
    isSold?: boolean
    isReturnedByCustomer?: boolean
    isReturnedToSupplier?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionCreateManyMedicineInstanceInput = {
    id?: number
    medicalStoreId: number
    purchaseOrderId?: number | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineLocationUpdateWithoutInstanceInput = {
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutLocationsNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type MedicineLocationUncheckedUpdateWithoutInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineLocationUncheckedUpdateManyWithoutInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubUnitUpdateWithoutInstanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUpdateManyWithoutSubUnitNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutSubUnitNestedInput
  }

  export type SubUnitUncheckedUpdateWithoutInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutSubUnitNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutSubUnitNestedInput
  }

  export type SubUnitUncheckedUpdateManyWithoutInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    subUnitCount?: IntFieldUpdateOperationsInput | number
    subUnitPrice?: FloatFieldUpdateOperationsInput | number
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isReturnedByCustomer?: BoolFieldUpdateOperationsInput | boolean
    isReturnedToSupplier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUpdateWithoutMedicineInstanceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutStockTransactionsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutMedicineInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutMedicineInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsCreateManySubUnitInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateManySubUnitInput = {
    id?: number
    orderId: number
    medicineId: number
    batchId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsUpdateWithoutSubUnitInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutSoldItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutSoldItemsNestedInput
    batch?: BatchUpdateOneWithoutSoldItemsNestedInput
  }

  export type SoldItemsUncheckedUpdateWithoutSubUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUncheckedUpdateManyWithoutSubUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUpdateWithoutSubUnitInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutReturnedItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutReturnedItemsNestedInput
    batch?: BatchUpdateOneWithoutReturnedItemsNestedInput
  }

  export type ReturnedItemsUncheckedUpdateWithoutSubUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutSubUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyPurchaseOrderInput = {
    id?: number
    batchNo: string
    mfgDate: Date | string
    expiryDate: Date | string
    quantity: number
    price: number
    variationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransactionCreateManyPurchaseOrderInput = {
    id?: number
    medicalStoreId: number
    medicineInstanceId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateWithoutPurchaseOrderInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutBatchesNestedInput
    instances?: MedicineInstanceUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: MedicineInstanceUncheckedUpdateManyWithoutBatchNestedInput
    soldItems?: SoldItemsUncheckedUpdateManyWithoutBatchNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    mfgDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    variationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUpdateWithoutPurchaseOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalStore?: MedicalStoreUpdateOneRequiredWithoutStockTransactionsNestedInput
    medicineInstance?: MedicineInstanceUpdateOneRequiredWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicalStoreId?: IntFieldUpdateOperationsInput | number
    medicineInstanceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsCreateManyOrderInput = {
    id?: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    saleDate?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnedItemsCreateManyOrderInput = {
    id?: number
    medicineId: number
    batchId?: number | null
    subUnitId?: number | null
    packing?: string | null
    quantity: number
    retailPrice: number
    discountPrice?: number | null
    margin: number
    returnType: $Enums.ReturnType
    returnedDate?: Date | string
    updatedAt?: Date | string
  }

  export type SoldItemsUpdateWithoutOrderInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutSoldItemsNestedInput
    batch?: BatchUpdateOneWithoutSoldItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutSoldItemsNestedInput
  }

  export type SoldItemsUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoldItemsUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUpdateWithoutOrderInput = {
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutReturnedItemsNestedInput
    batch?: BatchUpdateOneWithoutReturnedItemsNestedInput
    subUnit?: SubUnitUpdateOneWithoutReturnedItemsNestedInput
  }

  export type ReturnedItemsUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnedItemsUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    subUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    packing?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    returnType?: EnumReturnTypeFieldUpdateOperationsInput | $Enums.ReturnType
    returnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    userId: number
    customerName?: string | null
    customerLocation?: string | null
    customerContact?: string | null
    paymentMethod: $Enums.PaymentMethod
    changeCash?: number | null
    discount?: number | null
    discountType?: $Enums.DiscountType | null
    itemsCost: number
    tax?: number | null
    sellingPrice: number
    profit?: number | null
    bill: number
    invoiceDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    soldItems?: SoldItemsUpdateManyWithoutOrderNestedInput
    returnedItems?: ReturnedItemsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldItems?: SoldItemsUncheckedUpdateManyWithoutOrderNestedInput
    returnedItems?: ReturnedItemsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    customerContact?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    changeCash?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    itemsCost?: FloatFieldUpdateOperationsInput | number
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    bill?: FloatFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}